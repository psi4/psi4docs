
<!DOCTYPE html>


<html lang="en" >

  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="viewport" content="width=device-width, initial-scale=1" />

    <title>HF: Hartree–Fock Theory</title>
  
  
  
  <script data-cfasync="false">
    document.documentElement.dataset.mode = localStorage.getItem("mode") || "";
    document.documentElement.dataset.theme = localStorage.getItem("theme") || "light";
  </script>
  
  <!-- Loaded before other Sphinx assets -->
  <link href="_static/styles/theme.css?digest=ac02cc09edc035673794" rel="stylesheet" />
<link href="_static/styles/bootstrap.css?digest=ac02cc09edc035673794" rel="stylesheet" />
<link href="_static/styles/pydata-sphinx-theme.css?digest=ac02cc09edc035673794" rel="stylesheet" />

  
  <link href="_static/vendor/fontawesome/6.1.2/css/all.min.css?digest=ac02cc09edc035673794" rel="stylesheet" />
  <link rel="preload" as="font" type="font/woff2" crossorigin href="_static/vendor/fontawesome/6.1.2/webfonts/fa-solid-900.woff2" />
<link rel="preload" as="font" type="font/woff2" crossorigin href="_static/vendor/fontawesome/6.1.2/webfonts/fa-brands-400.woff2" />
<link rel="preload" as="font" type="font/woff2" crossorigin href="_static/vendor/fontawesome/6.1.2/webfonts/fa-regular-400.woff2" />

    <link rel="stylesheet" type="text/css" href="_static/pygments.css?v=fa44fd50" />
    <link rel="stylesheet" type="text/css" href="_static/graphviz.css?v=eafc0fe6" />
    <link rel="stylesheet" type="text/css" href="_static/autodoc_pydantic.css?v=c7cf8c76" />
  
  <!-- Pre-loaded scripts that we'll load fully later -->
  <link rel="preload" as="script" href="_static/scripts/bootstrap.js?digest=ac02cc09edc035673794" />
<link rel="preload" as="script" href="_static/scripts/pydata-sphinx-theme.js?digest=ac02cc09edc035673794" />
  <script src="_static/vendor/fontawesome/6.1.2/js/all.min.js?digest=ac02cc09edc035673794"></script>

    <script src="_static/documentation_options.js?v=0a908d79"></script>
    <script src="_static/doctools.js?v=888ff710"></script>
    <script src="_static/sphinx_highlight.js?v=dc90522c"></script>
    <script crossorigin="anonymous" integrity="sha256-Ae2Vz/4ePdIu6ZyI/5ZGsYnb+m0JlOmKPjt6XZ9JJkA=" src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.4/require.min.js"></script>
    <script>window.MathJax = {"tex": {"inlineMath": [["$", "$"], ["\\(", "\\)"]], "processEscapes": true}, "options": {"ignoreHtmlClass": "tex2jax_ignore|mathjax_ignore|document", "processHtmlClass": "tex2jax_process|mathjax_process|math|output_area"}}</script>
    <script defer="defer" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <script>DOCUMENTATION_OPTIONS.pagename = 'scf';</script>
    <link rel="icon" href="_static/favicon-psi4.ico"/>
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="next" title="DFT: Density Functional Theory" href="dft.html" />
    <link rel="prev" title="Notes on Options" href="notes_c.html" />
  <meta name="viewport" content="width=device-width, initial-scale=1"/>
  <meta name="docsearch:language" content="en"/>
    <meta name="docbuild:last-update" content="Tuesday, 26 September 2023 02:05AM"/>
  </head>
  
  
  <body data-bs-spy="scroll" data-bs-target=".bd-toc-nav" data-offset="180" data-bs-root-margin="0px 0px -60%" data-default-mode="">

  
  
  <a class="skip-link" href="#main-content">Skip to main content</a>
  
  <div id="pst-scroll-pixel-helper"></div>

  
  <button type="button" class="btn rounded-pill" id="pst-back-to-top">
    <i class="fa-solid fa-arrow-up"></i>
    Back to top
  </button>

  
  <input type="checkbox"
          class="sidebar-toggle"
          name="__primary"
          id="__primary"/>
  <label class="overlay overlay-primary" for="__primary"></label>
  
  <input type="checkbox"
          class="sidebar-toggle"
          name="__secondary"
          id="__secondary"/>
  <label class="overlay overlay-secondary" for="__secondary"></label>
  
  <div class="search-button__wrapper">
    <div class="search-button__overlay"></div>
    <div class="search-button__search-container">
<form class="bd-search d-flex align-items-center"
      action="search.html"
      method="get">
  <i class="fa-solid fa-magnifying-glass"></i>
  <input type="search"
         class="form-control"
         name="q"
         id="search-input"
         placeholder="Search the docs ..."
         aria-label="Search the docs ..."
         autocomplete="off"
         autocorrect="off"
         autocapitalize="off"
         spellcheck="false"/>
  <span class="search-button__kbd-shortcut"><kbd class="kbd-shortcut__modifier">Ctrl</kbd>+<kbd>K</kbd></span>
</form></div>
  </div>
  
    <nav class="bd-header navbar navbar-expand-lg bd-navbar">
<div class="bd-header__inner bd-page-width">
  <label class="sidebar-toggle primary-toggle" for="__primary">
    <span class="fa-solid fa-bars"></span>
  </label>
  
  
  <div class="col-lg-3 navbar-header-items__start">
    
      <div class="navbar-item">
  

<a class="navbar-brand logo" href="index.html">
  
  
  
  
    
    
      
    
    
    <img src="_static/psi4square.png" class="logo__image only-light" alt="Logo image"/>
    <script>document.write(`<img src="_static/psi4square.png" class="logo__image only-dark" alt="Logo image"/>`);</script>
  
  
</a></div>
    
  </div>
  
  <div class="col-lg-9 navbar-header-items">
    
    
    <div class="navbar-header-items__end">
      
        <div class="navbar-item navbar-persistent--container">
          
<script>
document.write(`
  <button class="btn btn-sm navbar-btn search-button search-button__button" title="Search" aria-label="Search" data-bs-placement="bottom" data-bs-toggle="tooltip">
    <i class="fa-solid fa-magnifying-glass fa-lg"></i>
  </button>
`);
</script>
        </div>
      
      
    </div>
    
  </div>
  
  
    <div class="navbar-persistent--mobile">
<script>
document.write(`
  <button class="btn btn-sm navbar-btn search-button search-button__button" title="Search" aria-label="Search" data-bs-placement="bottom" data-bs-toggle="tooltip">
    <i class="fa-solid fa-magnifying-glass fa-lg"></i>
  </button>
`);
</script>
    </div>
  

  
    <label class="sidebar-toggle secondary-toggle" for="__secondary" tabindex="0">
      <span class="fa-solid fa-outdent"></span>
    </label>
  
</div>

    </nav>
  
  <div class="bd-container">
    <div class="bd-container__inner bd-page-width">
      
      <div class="bd-sidebar-primary bd-sidebar">
        

  
  <div class="sidebar-header-items sidebar-primary__section">
    
    
    
    
  </div>
  
    <div class="sidebar-primary-items__start sidebar-primary__section">
        <div class="sidebar-primary-item">
  <div>
    <h3><a href="index.html">Table of Contents</a></h3>
    <ul>
<li><a class="reference internal" href="#">HF: Hartree–Fock Theory</a><ul>
<li><a class="reference internal" href="#introduction">Introduction</a></li>
<li><a class="reference internal" href="#theory">Theory</a></li>
<li><a class="reference internal" href="#minimal-input">Minimal Input</a></li>
<li><a class="reference internal" href="#spin-symmetry-treatment">Spin/Symmetry Treatment</a></li>
<li><a class="reference internal" href="#broken-symmetry">Broken Symmetry</a></li>
<li><a class="reference internal" href="#orthogonalization">Orthogonalization</a></li>
<li><a class="reference internal" href="#initial-guess">Initial Guess</a></li>
<li><a class="reference internal" href="#restarting-the-scf">Restarting the SCF</a></li>
<li><a class="reference internal" href="#convergence-stabilization">Convergence Stabilization</a></li>
<li><a class="reference internal" href="#eri-algorithms">ERI Algorithms</a></li>
<li><a class="reference internal" href="#integral-direct-density-fitted-coulomb-construction">Integral-Direct Density-Fitted Coulomb Construction</a></li>
<li><a class="reference internal" href="#cosx-exchange">COSX Exchange</a></li>
<li><a class="reference internal" href="#linear-exchange">Linear Exchange</a></li>
<li><a class="reference internal" href="#second-order-convergence">Second-order Convergence</a></li>
<li><a class="reference internal" href="#stability-analysis">Stability Analysis</a></li>
<li><a class="reference internal" href="#effective-core-potentials-ecps">Effective core potentials (ECPs)</a></li>
<li><a class="reference internal" href="#external-potentials-and-qm-mm">External potentials and QM/MM</a></li>
<li><a class="reference internal" href="#convergence-and-algorithm-defaults">Convergence and Algorithm Defaults</a></li>
<li><a class="reference internal" href="#recommendations">Recommendations</a></li>
</ul>
</li>
</ul>

  </div></div>
        <div class="sidebar-primary-item">
  <div>
    <h4>Previous topic</h4>
    <p class="topless"><a href="notes_c.html"
                          title="previous chapter">Notes on Options</a></p>
  </div>
  <div>
    <h4>Next topic</h4>
    <p class="topless"><a href="dft.html"
                          title="next chapter">DFT: Density Functional Theory</a></p>
  </div></div>
        <div class="sidebar-primary-item">
  <div class="tocsection sourcelink">
    <a href="_sources/scf.rst.txt">
      <i class="fa-solid fa-file-lines"></i> Show Source
    </a>
  </div>
</div>
        <div class="sidebar-primary-item">
<div id="searchbox"></div></div>
    </div>
  
  
  <div class="sidebar-primary-items__end sidebar-primary__section">
  </div>
  
  <div id="rtd-footer-container"></div>


      </div>
      
      <main id="main-content" class="bd-main">
        
        
          <div class="bd-content">
            <div class="bd-article-container">
              
              <div class="bd-header-article">
<div class="header-article-items header-article__inner">
  
    <div class="header-article-items__start">
      
        <div class="header-article-item">



<nav aria-label="Breadcrumb">
  <ul class="bd-breadcrumbs">
    
    <li class="breadcrumb-item breadcrumb-home">
      <a href="index.html" class="nav-link" aria-label="Home">
        <i class="fa-solid fa-home"></i>
      </a>
    </li>
    
    <li class="breadcrumb-item"><a href="methods.html" class="nav-link">Theoretical Methods: SCF to FCI</a></li>
    
    <li class="breadcrumb-item active" aria-current="page">HF:...</li>
  </ul>
</nav>
</div>
      
    </div>
  
  
</div>
</div>
              
              
              
                
<div id="searchbox"></div>
                <article class="bd-article" role="main">
                  
  <section id="hf-hartree-fock-theory">
<span id="sec-scf"></span><span id="index-0"></span><h1>HF: Hartree–Fock Theory<a class="headerlink" href="#hf-hartree-fock-theory" title="Link to this heading">#</a></h1>
<p><em>Code author: Justin M. Turney, Robert M. Parrish, and Andrew C. Simmonett</em></p>
<p><em>Section author: Robert M. Parrish and Jerome F. Gonthier</em></p>
<p><em>Module:</em> <a class="reference internal" href="autodir_options_c/module__scf.html#apdx-scf"><span class="std std-ref">Keywords</span></a>, <a class="reference internal" href="autodir_psivariables/module__scf.html#apdx-scf-psivar"><span class="std std-ref">PSI Variables</span></a>, <a class="reference external" href="https://github.com/psi4/psi4/blob/master/psi4/src/psi4/libscf_solver">LIBSCF_SOLVER</a>, <a class="reference external" href="https://github.com/psi4/psi4/blob/master/psi4/src/psi4/libmints">LIBMINTS</a>, <a class="reference external" href="https://github.com/psi4/psi4/blob/master/psi4/src/psi4/libfock">LIBFOCK</a>, <a class="reference external" href="https://github.com/psi4/psi4/blob/master/psi4/src/psi4/libdiis">LIBDIIS</a></p>
<section id="introduction">
<span id="sec-scfintro"></span><h2>Introduction<a class="headerlink" href="#introduction" title="Link to this heading">#</a></h2>
<p>Self-Consistent-Field (SCF) theory forms the cornerstone of <em>ab initio</em> quantum
chemistry. Here SCF refers both to conventional Hartree–Fock (HF) molecular
orbital theory and also to generalized Kohn–Sham Density Functional Theory
(KS-DFT). <span style="font-family: Optima, sans-serif; text-transform: none;">P<span style="font-size: 82%;">SI</span>4</span> contains a wholly rewritten SCF code, including many of the
most popular spin specializations, several efficient numerical methods for
treating Fock Matrix construction, and a brand new KS-DFT code featuring many of
the most popular DFT functional technologies.</p>
<p>An illustrative example of using the SCF module is as follows:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">molecule</span> <span class="p">{</span>
<span class="mi">0</span> <span class="mi">3</span>
<span class="n">O</span>
<span class="n">O</span> <span class="mi">1</span> <span class="mf">1.21</span>
<span class="p">}</span>

<span class="nb">set</span> <span class="p">{</span>
<span class="n">basis</span> <span class="n">cc</span><span class="o">-</span><span class="n">pvdz</span>
<span class="n">guess</span> <span class="n">sad</span>
<span class="n">reference</span> <span class="n">uhf</span>
<span class="n">scf_type</span> <span class="n">direct</span>
<span class="p">}</span>

<span class="n">energy</span><span class="p">(</span><span class="s1">&#39;scf&#39;</span><span class="p">)</span>
</pre></div>
</div>
<p>This will run a UHF computation for triplet molecular oxygen (the ground state)
using a Direct algorithm for the Electron Repulsion Integrals (ERI) and starting
from a Superposition of Atomic Densities (SAD) guess. DF integrals are
automatically used to converge the DF-SCF solution before the Direct algorithm is
activated.  After printing all manner of titles, geometries, sizings, and
algorithm choices, the SCF finally reaches the iterations:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span>                         <span class="n">Total</span> <span class="n">Energy</span>        <span class="n">Delta</span> <span class="n">E</span>     <span class="n">RMS</span> <span class="o">|</span><span class="p">[</span><span class="n">F</span><span class="p">,</span><span class="n">P</span><span class="p">]</span><span class="o">|</span>

 <span class="nd">@DF</span><span class="o">-</span><span class="n">UHF</span> <span class="nb">iter</span>   <span class="mi">0</span><span class="p">:</span>  <span class="o">-</span><span class="mf">149.80032977420572</span>   <span class="o">-</span><span class="mf">1.49800e+02</span>   <span class="mf">1.48808e-01</span>
 <span class="nd">@DF</span><span class="o">-</span><span class="n">UHF</span> <span class="nb">iter</span>   <span class="mi">1</span><span class="p">:</span>  <span class="o">-</span><span class="mf">149.59496320631871</span>    <span class="mf">2.05367e-01</span>   <span class="mf">2.58009e-02</span>
 <span class="nd">@DF</span><span class="o">-</span><span class="n">UHF</span> <span class="nb">iter</span>   <span class="mi">2</span><span class="p">:</span>  <span class="o">-</span><span class="mf">149.62349901753706</span>   <span class="o">-</span><span class="mf">2.85358e-02</span>   <span class="mf">6.68980e-03</span> <span class="n">DIIS</span>
 <span class="nd">@DF</span><span class="o">-</span><span class="n">UHF</span> <span class="nb">iter</span>   <span class="mi">3</span><span class="p">:</span>  <span class="o">-</span><span class="mf">149.62639942687878</span>   <span class="o">-</span><span class="mf">2.90041e-03</span>   <span class="mf">2.19285e-03</span> <span class="n">DIIS</span>
 <span class="nd">@DF</span><span class="o">-</span><span class="n">UHF</span> <span class="nb">iter</span>   <span class="mi">4</span><span class="p">:</span>  <span class="o">-</span><span class="mf">149.62689561367233</span>   <span class="o">-</span><span class="mf">4.96187e-04</span>   <span class="mf">5.99497e-04</span> <span class="n">DIIS</span>
 <span class="nd">@DF</span><span class="o">-</span><span class="n">UHF</span> <span class="nb">iter</span>   <span class="mi">5</span><span class="p">:</span>  <span class="o">-</span><span class="mf">149.62694151275420</span>   <span class="o">-</span><span class="mf">4.58991e-05</span>   <span class="mf">1.27338e-04</span> <span class="n">DIIS</span>
 <span class="nd">@DF</span><span class="o">-</span><span class="n">UHF</span> <span class="nb">iter</span>   <span class="mi">6</span><span class="p">:</span>  <span class="o">-</span><span class="mf">149.62694337910040</span>   <span class="o">-</span><span class="mf">1.86635e-06</span>   <span class="mf">1.65616e-05</span> <span class="n">DIIS</span>
 <span class="nd">@DF</span><span class="o">-</span><span class="n">UHF</span> <span class="nb">iter</span>   <span class="mi">7</span><span class="p">:</span>  <span class="o">-</span><span class="mf">149.62694340915198</span>   <span class="o">-</span><span class="mf">3.00516e-08</span>   <span class="mf">2.68990e-06</span> <span class="n">DIIS</span>
 <span class="nd">@DF</span><span class="o">-</span><span class="n">UHF</span> <span class="nb">iter</span>   <span class="mi">8</span><span class="p">:</span>  <span class="o">-</span><span class="mf">149.62694340999315</span>   <span class="o">-</span><span class="mf">8.41169e-10</span>   <span class="mf">2.61249e-07</span> <span class="n">DIIS</span>

<span class="n">DF</span> <span class="n">guess</span> <span class="n">converged</span><span class="o">.</span>
<span class="o">...</span>

 <span class="nd">@UHF</span> <span class="nb">iter</span>   <span class="mi">9</span><span class="p">:</span>  <span class="o">-</span><span class="mf">149.62730705472407</span>   <span class="o">-</span><span class="mf">3.63645e-04</span>   <span class="mf">8.63697e-05</span> <span class="n">DIIS</span>
 <span class="nd">@UHF</span> <span class="nb">iter</span>  <span class="mi">10</span><span class="p">:</span>  <span class="o">-</span><span class="mf">149.62730737348096</span>   <span class="o">-</span><span class="mf">3.18757e-07</span>   <span class="mf">1.50223e-05</span> <span class="n">DIIS</span>
 <span class="nd">@UHF</span> <span class="nb">iter</span>  <span class="mi">11</span><span class="p">:</span>  <span class="o">-</span><span class="mf">149.62730738537113</span>   <span class="o">-</span><span class="mf">1.18902e-08</span>   <span class="mf">3.80466e-06</span> <span class="n">DIIS</span>
 <span class="nd">@UHF</span> <span class="nb">iter</span>  <span class="mi">12</span><span class="p">:</span>  <span class="o">-</span><span class="mf">149.62730738624032</span>   <span class="o">-</span><span class="mf">8.69193e-10</span>   <span class="mf">7.06634e-07</span> <span class="n">DIIS</span>
</pre></div>
</div>
<p>The first set of iterations are from the DF portion of the computation, the
second set uses the exact (but much slower) Direct algorithm. Within the DF portion
of the computation, the zeroth-iteration uses a non-idempotent density matrix
obtained from the SAD guess, so the energy is unphysically low. However, the
first true iteration is quite close to the final DF energy, highlighting the
efficiency of the SAD guess. Pulay’s DIIS procedure is then used to accelerate
SCF convergence, with the DF phase reaching convergence in eight true
iterations. When used together, SAD and DIIS are usually sufficient to converge
the SCF for all but the most difficult systems. Additional convergence
techniques are available for more difficult cases, and are detailed below. At
this point, the code switches on the requested Direct integrals technology, which
requires only four full iterations to reach convergence, starting from the DF
guess. This hybrid DF/Direct procedure can significantly accelerate SCF
computations requiring exact integrals.</p>
<p>After the iterations are completed, a number of one-electron properties are
printed, and some bookkeeping is performed to set up possible correlated
computations. Additional one-electron properties are available by increasing the
<a class="reference internal" href="autodoc_glossary_options_c.html#term-PRINT-GLOBALS"><span class="xref std std-term">PRINT</span></a> option. Also printed are the occupied and virtual orbital energies,
which are useful in elucidating the stability and reactivity of the system.</p>
</section>
<section id="theory">
<span id="sec-scftheory"></span><span id="index-1"></span><h2>Theory<a class="headerlink" href="#theory" title="Link to this heading">#</a></h2>
<p>The objective of Hartree–Fock (HF) Theory is to produce the optimized Molecular
Orbitals (MOs) <span class="math notranslate nohighlight">\(\{\psi_i\}\)</span>,</p>
<div class="math notranslate nohighlight">
\[\psi_i(\vec x_1) = C_{\mu i} \phi_{\mu} (\vec x_1).\]</div>
<p>Here, <span class="math notranslate nohighlight">\(\{\phi_{\mu}\}\)</span> are the basis functions, which, in <span style="font-family: Optima, sans-serif; text-transform: none;">P<span style="font-size: 82%;">SI</span>4</span> are
contracted Cartesian Gaussian functions often referred to as Atomic Orbitals
(AOs). The matrix <span class="math notranslate nohighlight">\(C_{\mu i}\)</span> contains the MO coefficients, which are the
constrained variational parameters in Hartree–Fock. The molecular orbitals are
used to build the simplest possible antisymmetric wavefunction, a single Slater
determinant,</p>
<div class="math notranslate nohighlight">
\[\begin{split}| \Psi_0 \rangle =
\frac{1}{\sqrt{N!}} \left | \begin{array}{cccc}
\psi_1 (\vec x_1) &amp; \psi_2(\vec x_1) &amp; \ldots &amp; \psi_N (\vec x_1) \\
\psi_1 (\vec x_2) &amp; \psi_2(\vec x_2) &amp; \ldots &amp; \psi_N (\vec x_2) \\
\vdots &amp; \vdots &amp; \ddots &amp; \vdots \\
\psi_1 (\vec x_N) &amp; \psi_2(\vec x_N) &amp; \ldots &amp; \psi_N (\vec x_N) \\
\end{array}\right |\end{split}\]</div>
<p>This form for the Hartree–Fock wavefunction is actually entirely equivalent to
treating the electron correlation as a mean field repulsion in
<span class="math notranslate nohighlight">\(\mathbb{R}^6\)</span> instead of a more complicated effect in
<span class="math notranslate nohighlight">\(\mathbb{R}^N\)</span>.</p>
<p>Considering the electronic Hamiltonian,</p>
<div class="math notranslate nohighlight">
\[\hat H = \sum_{i} -\frac{1}{2} \nabla_i^2 + \sum_{i} \sum_{A} -
\frac{Z_A}{r_{iA}} + \sum_{i&gt;j} \frac{1}{r_{ij}},\]</div>
<p>the Hartree–Fock energy is, by Slater’s rules,</p>
<div class="math notranslate nohighlight">
\[E_{\mathrm{HF}} =
\langle \Psi_0 | \hat H | \Psi_0 \rangle
= \sum_{i} \langle i | \hat h | i \rangle
+ \frac 1 2 \sum_{i,j} [ii|jj] - [ij|ji]\]</div>
<div class="math notranslate nohighlight">
\[=
D_{\mu\nu}^\alpha \left(H_{\mu\nu} + F_{\mu\nu}^{\alpha} \right)
+ D_{\mu\nu}^\beta \left(H_{\mu\nu} + F_{\mu\nu}^{\beta} \right)\]</div>
<p>Here <span class="math notranslate nohighlight">\(H\)</span> is the AO-basis one-electron potential, encapsulating both
electron-nuclear attraction and kinetic energy,</p>
<div class="math notranslate nohighlight">
\[H_{\mu\nu} =
\left(\mu \left| -\frac{1}{2} \nabla^2 + \sum_{A} -\frac{Z_A}{r_{1A}} \right
| \nu \right),\]</div>
<p><span class="math notranslate nohighlight">\(D\)</span> is the AO-basis density matrix, build from the occupied orbital
coefficients,</p>
<div class="math notranslate nohighlight">
\[D_{\mu\nu}^{\alpha} =
C_{\mu i}^{\alpha} C_{\nu i}^{\alpha},\]</div>
<p>and <span class="math notranslate nohighlight">\(F\)</span> is the Fock matrix, which is the effective one-body potential at
the current value of the density,</p>
<div class="math notranslate nohighlight">
\[F_{\mu\nu}^{\alpha} = H_{\mu\nu}
+ \underbrace{\left(D_{\lambda\sigma}^{\alpha} + D_{\lambda\sigma}^{\beta}\right)
(\mu\nu|\lambda\sigma)}_{J}
+ \underbrace{D_{\lambda\sigma}^{\alpha} (\mu\lambda|\sigma\nu)}_{K^{\alpha}}\]</div>
<p>Here the tensor <span class="math notranslate nohighlight">\((\mu\nu|\lambda\sigma)\)</span> is an AO Electron-Repulsion
Integral (ERI) in chemists’ notation,</p>
<div class="math notranslate nohighlight">
\[(\mu\nu|\lambda\sigma) = \iint_{\mathbb{R}^6}
\phi_{\mu} (\vec r_1)
\phi_{\nu} (\vec r_1)
\frac{1}{r_{12}}
\phi_{\lambda} (\vec r_2)
\phi_{\sigma} (\vec r_2)
\ \mathrm{d}^3 r_1
\ \mathrm{d}^3 r_2.\]</div>
<p>The MO coefficients are found as the generalized eigenvectors of the Fock Matrix,</p>
<div class="math notranslate nohighlight">
\[F^\alpha C^\alpha = S C^\alpha \epsilon^\alpha\]</div>
<p>The eigenvalues <span class="math notranslate nohighlight">\(\epsilon\)</span> are the orbital energies, and the metric matrix
<span class="math notranslate nohighlight">\(S\)</span> is the AO-basis overlap matrix</p>
<div class="math notranslate nohighlight">
\[S_{\mu\nu} = (\mu | \nu )\]</div>
<p>Note that the Fock Matrix depends on the density (both alpha and beta), and
therefore the orbitals. Because of this, SCF is a nonlinear procedure, which
terminates when the generating orbitals are self-consistent with the Fock matrix
they generate.</p>
<p>The formation of the Coulomb matrix <span class="math notranslate nohighlight">\(J\)</span> and the exchange matrix
<span class="math notranslate nohighlight">\(K^{\alpha}\)</span> dominate the computational effort of the SCF procedure. For
very large systems, diagonalization of the Fock matrix can also present a
significant hurdle.</p>
</section>
<section id="minimal-input">
<span id="sec-scfinput"></span><h2>Minimal Input<a class="headerlink" href="#minimal-input" title="Link to this heading">#</a></h2>
<p>Minimal input for a Hartree–Fock computation is a molecule block, basis set
option, and a call to <code class="docutils literal notranslate"><span class="pre">energy('scf')</span></code>:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">molecule</span> <span class="p">{</span>
<span class="n">He</span>
<span class="p">}</span>

<span class="nb">set</span> <span class="n">basis</span> <span class="n">sto</span><span class="o">-</span><span class="mi">3</span><span class="n">g</span>

<span class="n">energy</span><span class="p">(</span><span class="s1">&#39;scf&#39;</span><span class="p">)</span>
</pre></div>
</div>
<p>This will run a Restricted Hartree–Fock (RHF) on neutral singlet Helium in
<span class="math notranslate nohighlight">\(D_{2h}\)</span> spatial symmetry with a minimal <code class="docutils literal notranslate"><span class="pre">STO-3G</span></code> basis, 1.0E-6
energy and density convergence criteria (since single-point, see
<a class="reference internal" href="#table-conv-scf"><span class="std std-ref">SCF Convergence &amp; Algorithm</span></a>), a DF ERI algorithm, symmetric
orthogonalization, DIIS, and a core Hamiltonian guess. For more
information on any of these options, see the relevant section below.</p>
</section>
<section id="spin-symmetry-treatment">
<span id="sec-scfsymm"></span><h2>Spin/Symmetry Treatment<a class="headerlink" href="#spin-symmetry-treatment" title="Link to this heading">#</a></h2>
<p><span style="font-family: Optima, sans-serif; text-transform: none;">P<span style="font-size: 82%;">SI</span>4</span> implements the most popular spin specializations of Hartree–Fock
theory, including:</p>
<dl class="simple">
<dt>Restricted Hartree–Fock (RHF) [Default]</dt><dd><p>Appropriate only for closed-shell singlet systems, but twice as efficient
as the other flavors, as the alpha and beta densities are constrained to be
identical.</p>
</dd>
<dt>Unrestricted Hartree–Fock (UHF)</dt><dd><p>Appropriate for most open-shell systems and fairly easy to converge.
The spatial parts of the alpha and beta orbitals are fully independent of each
other, which allows a considerable amount of flexibility in the wavefunction.
However, this flexibility comes at the cost of spin symmetry; UHF wavefunctions
need not be eigenfunctions of the <span class="math notranslate nohighlight">\(\hat S^2\)</span> operator. The deviation of
this operator from its expectation value is printed on the output file. If the
deviation is greater than a few hundredths, it is advisable to switch to a
ROHF to avoid this “spin-contamination” problem.</p>
</dd>
<dt>Restricted Open-Shell Hartree–Fock (ROHF)</dt><dd><p>Appropriate for open-shell systems where spin-contamination is problem.
Sometimes more difficult to converge, and assumes uniformly positive spin
polarization (the alpha and beta doubly-occupied orbitals are identical).</p>
</dd>
<dt>Constrained Unrestricted Hartree–Fock (CUHF)</dt><dd><p>A variant of ROHF that starts from a UHF ansatz and is therefore often
easier to converge.</p>
</dd>
</dl>
<p>These can be invoked by the <a class="reference internal" href="autodoc_glossary_options_c.html#term-REFERENCE-SCF"><span class="xref std std-term">REFERENCE</span></a> keyword, which defaults to <code class="docutils literal notranslate"><span class="pre">RHF</span></code>.
The charge and multiplicity may either be specified in the molecule definition:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">molecule</span> <span class="n">h</span> <span class="p">{</span>
<span class="mi">0</span> <span class="mi">2</span>  <span class="c1"># Neutral doublet</span>
<span class="n">H</span>
<span class="p">}</span>
</pre></div>
</div>
<p>or, dynamically, by setting the relevant attributes in the Python molecule
object:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">h</span><span class="o">.</span><span class="n">set_molecular_charge</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
<span class="n">h</span><span class="o">.</span><span class="n">set_multiplicity</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
</pre></div>
</div>
<p>Abelian spatial symmetry is fully supported in <span style="font-family: Optima, sans-serif; text-transform: none;">P<span style="font-size: 82%;">SI</span>4</span> and can be used to
obtain physical interpretation of the molecular orbitals, to assist in difficult
convergence cases, and, in some methods, to obtain significant performance
gains. The point group of the molecule is inferred when reading the molecule
section, and may be overridden by the <a class="reference internal" href="psithonmol.html#sec-moleculekeywords"><span class="std std-ref">symmetry</span></a> flag, as in:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">molecule</span> <span class="n">h</span> <span class="p">{</span>
<span class="mi">0</span> <span class="mi">2</span>
<span class="n">H</span>
<span class="n">symmetry</span> <span class="n">c1</span>
<span class="p">}</span>
</pre></div>
</div>
<p>or by the <code class="docutils literal notranslate"><span class="pre">reset_point_group</span></code> Python molecule attribute:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">h</span><span class="o">.</span><span class="n">reset_point_group</span><span class="p">(</span><span class="s1">&#39;c2v&#39;</span><span class="p">)</span>
</pre></div>
</div>
<p>During the SCF procedure, the occupation of orbitals is typically determined by
the Aufbau principal across all spatial symmetries. This may result in the
occupation shifting between iterations. If the occupations are known <em>a priori</em>,
they may be clamped throughout the procedure by using the <a class="reference internal" href="autodoc_glossary_options_c.html#term-DOCC-GLOBALS"><span class="xref std std-term">DOCC</span></a> and
<a class="reference internal" href="autodoc_glossary_options_c.html#term-SOCC-GLOBALS"><span class="xref std std-term">SOCC</span></a> options. For instance, all good quantum chemists know that
<span class="math notranslate nohighlight">\(C_{2v}\)</span> water is
actually,:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">molecule</span> <span class="n">h2o</span> <span class="p">{</span>
<span class="mi">0</span> <span class="mi">1</span>
<span class="n">O</span>
<span class="n">H</span> <span class="mi">1</span> <span class="mf">1.0</span>
<span class="n">H</span> <span class="mi">1</span> <span class="mf">1.0</span> <span class="mi">2</span> <span class="mf">104.5</span>
<span class="p">}</span>

<span class="nb">set</span> <span class="p">{</span>
<span class="n">docc</span> <span class="p">[</span><span class="mi">3</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span>  <span class="c1"># 1A1 2A1 1B1 3A1 1B2</span>
<span class="n">basis</span> <span class="n">cc</span><span class="o">-</span><span class="n">pvdz</span>
<span class="p">}</span>

<span class="n">energy</span><span class="p">(</span><span class="s1">&#39;scf&#39;</span><span class="p">)</span>
</pre></div>
</div>
</section>
<section id="broken-symmetry">
<span id="sec-scfbrokensymm"></span><h2>Broken Symmetry<a class="headerlink" href="#broken-symmetry" title="Link to this heading">#</a></h2>
<p>For certain problems, such diradicals, allowing the spin-up and spin-down
orbitals to differ in closed-shell computations can be advantageous;
this is known as symmetry breaking.  The resulting unrestricted wavefunction
will often provide superior energetics, due to the increased flexibility,
but it will suffer non-physical spin contamination from higher multiplicity states.
A convenient approach to break symmetry is to perform a UHF or UKS calculation
with the guess HOMO and LUMO orbitals mixed.
Mixing of the guess orbitals can be requested by setting the <a class="reference internal" href="autodoc_glossary_options_c.html#term-GUESS_MIX-SCF"><span class="xref std std-term">GUESS_MIX</span></a>
keyword to true:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="nb">set</span> <span class="n">reference</span> <span class="n">uhf</span>
<span class="nb">set</span> <span class="n">guess_mix</span> <span class="n">true</span>
<span class="n">energy</span><span class="p">(</span><span class="s1">&#39;scf&#39;</span><span class="p">)</span>
</pre></div>
</div>
</section>
<section id="orthogonalization">
<span id="sec-scflindep"></span><h2>Orthogonalization<a class="headerlink" href="#orthogonalization" title="Link to this heading">#</a></h2>
<p>One of the first steps in the SCF procedure is the determination of an
orthogonal basis (known as the OSO basis) from the atomic orbital
basis (known as the AO basis). The Molecular Orbital basis (MO basis)
is then built as a particular unitary transformation of the OSO
basis. In <span style="font-family: Optima, sans-serif; text-transform: none;">P<span style="font-size: 82%;">SI</span>4</span>, the determination of the OSO basis is
accomplished via either symmetric, canonical, or partial Cholesky
orthogonalization.</p>
<p>Symmetric orthogonalization uses the symmetric inverse square root of
the overlap matrix for the orthogonalization matrix. Use of symmetric
orthogonalization always yields the same number of OSO functions (and
thereby MOs) as AO functions. However, this may lead to numerical
problems if the overlap matrix has small eigenvalues, which may occur
for large systems or for systems where diffuse basis sets are used.</p>
<p>This problem may be avoided by using canonical orthogonalization, in
which an asymmetric inverse square root of the overlap matrix is
formed, with numerical stability enhanced by the elimination of
eigenvectors corresponding to very small eigenvalues. As a few
combinations of AO basis functions may be discarded, the number of
canonical-orthogonalized OSOs and MOs may be slightly smaller than the
number of AOs.</p>
<p>When the basis set is too overcomplete, the eigendecomposition of the
overlap matrix is no longer numerically stable. In this case the
partial Cholesky decomposition can be used to pick a subset of basis
functions that span a sufficiently complete set, see
<a class="reference internal" href="bibliography.html#lehtola-2019-241102" id="id1"><span>[Lehtola:2019:241102]</span></a> and <a class="reference internal" href="bibliography.html#lehtola-2020-032504" id="id2"><span>[Lehtola:2020:032504]</span></a>. This subset can then
be orthonormalized as usual; the rest of the basis functions are
hidden from the calculation. The Cholesky approach allows reaching
accurate energies even in the presence of significant linear
dependencies <a class="reference internal" href="bibliography.html#lehtola-2020-134108" id="id3"><span>[Lehtola:2020:134108]</span></a>.</p>
<p>In <span style="font-family: Optima, sans-serif; text-transform: none;">P<span style="font-size: 82%;">SI</span>4</span>, symmetric orthogonalization is used by default, unless
the smallest overlap eigenvalue falls below the user-supplied double
option <a class="reference internal" href="autodoc_glossary_options_c.html#term-S_TOLERANCE-SCF"><span class="xref std std-term">S_TOLERANCE</span></a>, which defaults to 1E-7. If the smallest
eigenvalue is below this cutoff, canonical orthogonalization is
forced, and all eigenvectors corresponding to eigenvalues below the
cutoff are eliminated.</p>
<p>If the eigendecomposition is detected to be numerically unstable - the
reciprocal condition number of the overlap matrix to be smaller than
the machine epsilon - the partial Cholesky decomposition is undertaken
until <a class="reference internal" href="autodoc_glossary_options_c.html#term-S_CHOLESKY_TOLERANCE-SCF"><span class="xref std std-term">S_CHOLESKY_TOLERANCE</span></a>, which defaults to 1E-8.</p>
<p>Use of symmetric, canonical, and partial Cholesky orthogonalization
can be forced by setting the <a class="reference internal" href="autodoc_glossary_options_c.html#term-S_ORTHOGONALIZATION-SCF"><span class="xref std std-term">S_ORTHOGONALIZATION</span></a> option to
<code class="docutils literal notranslate"><span class="pre">SYMMETRIC</span></code>, <code class="docutils literal notranslate"><span class="pre">CANONICAL</span></code>, or <code class="docutils literal notranslate"><span class="pre">PARTIALCHOLESKY</span></code>,
respectively.</p>
<p>Note that in practice, the MOs and OSOs are built separately within
each irrep from the symmetry-adapted combinations of AOs known as
Unique Symmetry Orbitals (USOs).  For canonical orthogonalization,
this implies that the number of MOs and OSOs per irrep may be slightly
smaller than the number of USOs per irrep.</p>
<p>A contrived example demonstrating OSOs/MOs vs. AOs with symmetry is shown
below:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">molecule</span> <span class="n">h2o</span> <span class="p">{</span>
<span class="mi">0</span> <span class="mi">1</span>
<span class="n">O</span>
<span class="n">H</span> <span class="mi">1</span> <span class="mf">1.0</span>
<span class="n">H</span> <span class="mi">1</span> <span class="mf">1.0</span> <span class="mi">2</span> <span class="mf">104.5</span>
<span class="n">symmetry</span> <span class="n">c2</span>  <span class="c1"># Two irreps is easier to comprehend</span>
<span class="p">}</span>

<span class="nb">set</span> <span class="p">{</span>
<span class="n">s_tolerance</span> <span class="mf">0.0001</span>      <span class="c1"># Set an unreasonably tight</span>
                        <span class="c1"># tolerance to force canonical</span>
<span class="n">basis</span> <span class="n">aug</span><span class="o">-</span><span class="n">cc</span><span class="o">-</span><span class="n">pv5z</span>       <span class="c1"># This diffuse basis will have</span>
                        <span class="c1"># small-ish eigenvalues for even H2O</span>
<span class="nb">print</span> <span class="mi">3</span>
<span class="p">}</span>

<span class="n">energy</span><span class="p">(</span><span class="s1">&#39;scf&#39;</span><span class="p">)</span>
</pre></div>
</div>
<p>Output:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="o">==&gt;</span> <span class="n">Pre</span><span class="o">-</span><span class="n">Iterations</span> <span class="o">&lt;==</span>

 <span class="o">-------------------------------------------------------</span>
  <span class="n">Irrep</span>   <span class="n">Nso</span>     <span class="n">Nmo</span>     <span class="n">Nalpha</span>   <span class="n">Nbeta</span>   <span class="n">Ndocc</span>  <span class="n">Nsocc</span>
 <span class="o">-------------------------------------------------------</span>
   <span class="n">A</span>        <span class="mi">145</span>     <span class="mi">145</span>       <span class="mi">0</span>       <span class="mi">0</span>       <span class="mi">0</span>       <span class="mi">0</span>
   <span class="n">B</span>        <span class="mi">142</span>     <span class="mi">142</span>       <span class="mi">0</span>       <span class="mi">0</span>       <span class="mi">0</span>       <span class="mi">0</span>
 <span class="o">-------------------------------------------------------</span>
  <span class="n">Total</span>     <span class="mi">287</span>     <span class="mi">287</span>       <span class="mi">5</span>       <span class="mi">5</span>       <span class="mi">5</span>       <span class="mi">0</span>
 <span class="o">-------------------------------------------------------</span>

<span class="o">...</span>

<span class="n">Minimum</span> <span class="n">eigenvalue</span> <span class="ow">in</span> <span class="n">the</span> <span class="n">overlap</span> <span class="n">matrix</span> <span class="ow">is</span> <span class="mf">1.6888063568E-05</span><span class="o">.</span>
<span class="n">Using</span> <span class="n">Canonical</span> <span class="n">Orthogonalization</span> <span class="k">with</span> <span class="n">cutoff</span> <span class="n">of</span> <span class="mf">1.0000000000E-04</span><span class="o">.</span>
<span class="n">Irrep</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span> <span class="n">of</span> <span class="mi">145</span> <span class="n">possible</span> <span class="n">MOs</span> <span class="n">eliminated</span><span class="o">.</span>
<span class="n">Irrep</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span> <span class="n">of</span> <span class="mi">142</span> <span class="n">possible</span> <span class="n">MOs</span> <span class="n">eliminated</span><span class="o">.</span>
<span class="n">Overall</span><span class="p">,</span> <span class="mi">3</span> <span class="n">of</span> <span class="mi">287</span> <span class="n">possible</span> <span class="n">MOs</span> <span class="n">eliminated</span><span class="o">.</span>
</pre></div>
</div>
<p>In this example, there are 287 AO basis functions after spherical harmonics are
applied. These are used to produce 287 symmetry adapted USOs, 145 of which are
assigned to irrep A, and 142 of which are assigned to irrep B. Within irrep A,
144 OSOs fall above the eigenvalue cutoff, and within irrep B 140 OSOs fall
above the eigenvalue cutoff. In total, 284 molecular orbitals are chosen from
287 AOs/USOs.</p>
</section>
<section id="initial-guess">
<span id="sec-scfguess"></span><h2>Initial Guess<a class="headerlink" href="#initial-guess" title="Link to this heading">#</a></h2>
<p>In each step of the SCF procedure, a new Fock or Kohn–Sham potential is built
according to the previous density, following which the potential is diagonalized
to produce new molecular orbitals, from which a new density is computed. This
procedure is continued until either convergence is reached or a preset maximum
number of iterations is exceeded. Convergence is determined by both change in
energy and root-mean-square change in density matrix values, which must be below
the user-specified <a class="reference internal" href="autodoc_glossary_options_c.html#term-E_CONVERGENCE-SCF"><span class="xref std std-term">E_CONVERGENCE</span></a> and <a class="reference internal" href="autodoc_glossary_options_c.html#term-D_CONVERGENCE-SCF"><span class="xref std std-term">D_CONVERGENCE</span></a>, respectively.
The maximum number of iterations is specified by the <a class="reference internal" href="autodoc_glossary_options_c.html#term-MAXITER-SCF"><span class="xref std std-term">MAXITER</span></a> option. It
should be noted that SCF is a chaotic process, and, as such, often requires
careful selection of initial orbitals and damping during iterations to ensure
convergence. This is particularly likely for large systems, metallic systems,
multireference systems, open-shell systems, anions, and systems with diffuse
basis sets.</p>
<p>For initial orbital selection, several options are available. These include:</p>
<dl class="simple">
<dt>CORE</dt><dd><p>Diagonalization of the core Hamiltonian, removing even mean-field electron
repulsion. Simple, but often too far from the final solution for larger
systems. This is the default for single atoms.</p>
</dd>
<dt>SAD [<a class="reference internal" href="autodoc_glossary_options_c.html#term-GUESS-SCF"><span class="xref std std-term">Default</span></a>]</dt><dd><p>Superposition of Atomic Densities. Builds the initial density as the
spin-averaged sum of atomic UHF computations in the current basis. If an
open-shell system, uniform scaling of the spin-averaged density matrices is
performed. If orbitals are needed (<em>e.g.</em>, in density fitting), a partial
Cholesky factorization of the density matrices is used. Often extremely
accurate, particularly for closed-shell systems. This is the default for
systems of more than one atom.</p>
</dd>
<dt>SADNO</dt><dd><p>Natural orbitals from Superposition of Atomic Densities. Similar
to the above, but it forms natural orbitals from the SAD density
matrix to get proper orbitals which are used to start the
calculation, see <a class="reference internal" href="bibliography.html#lehtola-2019-1593" id="id4"><span>[Lehtola:2019:1593]</span></a>.</p>
</dd>
<dt>GWH</dt><dd><p>A generalized Wolfsberg-Helmholtz modification of the core
Hamiltonian matrix. Usually less accurate than the core guess: the
latter is exact for one-electron systems, GWH is not; see
<a class="reference internal" href="bibliography.html#lehtola-2019-1593" id="id5"><span>[Lehtola:2019:1593]</span></a>).</p>
</dd>
<dt>HUCKEL</dt><dd><p>An extended Hückel guess based on on-the-fly atomic UHF
calculations alike SAD, see <a class="reference internal" href="bibliography.html#lehtola-2019-1593" id="id6"><span>[Lehtola:2019:1593]</span></a>.</p>
</dd>
<dt>MODHUCKEL</dt><dd><p>Like HUCKEL, an extended Hückel guess based on
on-the-fly atomic UHF calculations alike SAD, see
<a class="reference internal" href="bibliography.html#lehtola-2019-1593" id="id7"><span>[Lehtola:2019:1593]</span></a>. This variant employs an updated rule for the
generalized Wolfsberg-Helmholz formula from <a class="reference internal" href="bibliography.html#ammeter-1978-3686" id="id8"><span>[Ammeter:1978:3686]</span></a>.</p>
</dd>
<dt>READ</dt><dd><p>Read the previous orbitals from a <code class="docutils literal notranslate"><span class="pre">wfn</span></code> file, casting from
one basis to another if needed. Useful for starting anion
computations from neutral orbitals, or after small geometry
changes. At present, casting from a different molecular point
group is not supported.  This becomes the default for the second
and later iterations of geometry optimizations.</p>
</dd>
<dt>SAP</dt><dd><p>Superposition of Atomic Potentials. This is essentially a
modification of the core Hamiltonian, which includes screening
effects by using a radially screened effective atomic charge. The
screening effects have been calculated at the complete basis set
limit with finite-element calculations, see <a class="reference internal" href="bibliography.html#lehtola-2019-25945" id="id9"><span>[Lehtola:2019:25945]</span></a>
and <a class="reference internal" href="bibliography.html#lehtola-2020-012516" id="id10"><span>[Lehtola:2020:012516]</span></a>. The guess and its implementation have
been described in <a class="reference internal" href="bibliography.html#lehtola-2019-1593" id="id11"><span>[Lehtola:2019:1593]</span></a>. The guess is evaluated on a
DFT quadrature grid, so the guess energy depends slightly on the
used DFT quadrature. The current implementation is based on
exchange-only local density calculations that are but nanohartree
away from the complete basis set limit <a class="reference internal" href="bibliography.html#lehtola-2020-012516" id="id12"><span>[Lehtola:2020:012516]</span></a>.</p>
</dd>
<dt>SAPGAU</dt><dd><p>Superposition of Atomic Potentials, but using error function based
fits to the atomic radial potentials as discussed in
<a class="reference internal" href="bibliography.html#lehtola-2020-144105" id="id13"><span>[Lehtola:2020:144105]</span></a>. The main difference to the SAP guess
discussed above <a class="reference internal" href="bibliography.html#lehtola-2019-25945" id="id14"><span>[Lehtola:2019:25945]</span></a> is that the SAPGAU scheme is
analytic, and can be efficiently formed in terms of three-center
two-electron integrals <a class="reference internal" href="bibliography.html#lehtola-2020-144105" id="id15"><span>[Lehtola:2020:144105]</span></a>. The potential in
the SAPGAU scheme is passed with the <a class="reference internal" href="autodoc_glossary_options_c.html#term-SAPGAU_BASIS-SCF"><span class="xref std std-term">SAPGAU_BASIS</span></a>
keyword. The default potential is given by the large fit to the
HelFEM potential, sap_helfem_large, described in
<a class="reference internal" href="bibliography.html#lehtola-2020-144105" id="id16"><span>[Lehtola:2020:144105]</span></a>. Note that this guess is known in the DIRAC
program as .SCRPOT and in the ERKALE program as SAPFIT.</p>
</dd>
</dl>
<p>These are all set by the <a class="reference internal" href="autodoc_glossary_options_c.html#term-GUESS-SCF"><span class="xref std std-term">GUESS</span></a> keyword. Also, an automatic Python
procedure has been developed for converging the SCF in a small basis, and then
casting up to the true basis. This can be done by adding
<a class="reference internal" href="autodoc_glossary_options_c.html#term-BASIS_GUESS-SCF"><span class="xref std std-term">BASIS_GUESS</span></a> = SMALL_BASIS to the options list. We recommend the
3-21G or pcseg-0 basis for the small basis due to its efficient mix of flexibility and
compactness. An example of performing an RHF solution of water by SAD guessing
in a 3-21G basis and then casting up to cc-pVTZ is shown below:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">molecule</span> <span class="n">h2o</span> <span class="p">{</span>
<span class="mi">0</span> <span class="mi">1</span>
<span class="n">O</span>
<span class="n">H</span> <span class="mi">1</span> <span class="mf">1.0</span>
<span class="n">H</span> <span class="mi">1</span> <span class="mf">1.0</span> <span class="mi">2</span> <span class="mf">104.5</span>
<span class="p">}</span>

<span class="nb">set</span> <span class="p">{</span>
<span class="n">basis</span> <span class="n">cc</span><span class="o">-</span><span class="n">pvtz</span>
<span class="n">basis_guess</span> <span class="mi">3</span><span class="o">-</span><span class="mi">21</span><span class="n">G</span>
<span class="n">guess</span> <span class="n">sad</span>
<span class="p">}</span>

<span class="n">energy</span><span class="p">(</span><span class="s1">&#39;scf&#39;</span><span class="p">)</span>
</pre></div>
</div>
</section>
<section id="restarting-the-scf">
<span id="sec-scfrestart"></span><h2>Restarting the SCF<a class="headerlink" href="#restarting-the-scf" title="Link to this heading">#</a></h2>
<p>Reading orbital data from a previous calculations is done via the <code class="docutils literal notranslate"><span class="pre">restart_file</span></code> option,
where the actual file is a serialized <code class="docutils literal notranslate"><span class="pre">wfn</span></code> object (see <a class="reference internal" href="external.html#sec-save-wfn"><span class="std std-ref">saving the wfn</span></a>)
By default, the orbital data file of the converged SCF(<code class="docutils literal notranslate"><span class="pre">psi.PID.name.180.npy</span></code>) is deleted
after <span style="font-family: Optima, sans-serif; text-transform: none;">P<span style="font-size: 82%;">SI</span>4</span> exits or the <code class="docutils literal notranslate"><span class="pre">clean()</span></code> function is called. The orbital guess is automatically
set to <code class="docutils literal notranslate"><span class="pre">READ</span></code> when <code class="docutils literal notranslate"><span class="pre">restart_file</span></code> is given a <code class="docutils literal notranslate"><span class="pre">wfn</span></code> file.
To write the orbitals after every iteration and keep the orbitals from the last iteration, the <code class="docutils literal notranslate"><span class="pre">write_orbitals</span></code> options is available:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">energy</span><span class="p">(</span><span class="s1">&#39;scf&#39;</span><span class="p">,</span> <span class="n">write_orbitals</span><span class="o">=</span><span class="s1">&#39;my_mos&#39;</span><span class="p">),</span>
</pre></div>
</div>
<p>which writes a <code class="docutils literal notranslate"><span class="pre">Wavefunction</span></code> object converted (serialized) to a numpy file called <code class="docutils literal notranslate"><span class="pre">my_mos.npy</span></code>.
The restart can then be done as follows:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">energy</span><span class="p">(</span><span class="s1">&#39;scf&#39;</span><span class="p">,</span> <span class="n">restart_file</span><span class="o">=</span><span class="s1">&#39;my_mos&#39;</span><span class="p">)</span>
</pre></div>
</div>
<p>Specifying the <code class="docutils literal notranslate"><span class="pre">.npy</span></code> suffix when writing and reading restart files is optional.</p>
<p>Alternatively, the restart can also be done from any previously saved <code class="docutils literal notranslate"><span class="pre">wfn</span></code> object.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">energy</span><span class="p">,</span> <span class="n">scf_wfn</span> <span class="o">=</span> <span class="n">energy</span><span class="p">(</span><span class="s1">&#39;scf&#39;</span><span class="p">,</span><span class="n">return_wfn</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="n">scf_wfn</span><span class="o">.</span><span class="n">to_file</span><span class="p">(</span><span class="s1">&#39;my_wfn&#39;</span><span class="p">)</span>
<span class="n">energy</span><span class="p">(</span><span class="s1">&#39;scf&#39;</span><span class="p">,</span> <span class="n">restart_file</span><span class="o">=</span><span class="s1">&#39;my_wfn&#39;</span><span class="p">)</span>
</pre></div>
</div>
<p>For advanced users manipulating or writing custom wavefunction files, note
that <span style="font-family: Optima, sans-serif; text-transform: none;">P<span style="font-size: 82%;">SI</span>4</span> expects the numpy file on disk to have the <code class="docutils literal notranslate"><span class="pre">.npy</span></code> extension, not, e.g., <cite>.npz</cite>.</p>
</section>
<section id="convergence-stabilization">
<span id="sec-scfconv"></span><span id="index-2"></span><h2>Convergence Stabilization<a class="headerlink" href="#convergence-stabilization" title="Link to this heading">#</a></h2>
<p>A summary of Psi’s supported convergence stabilization techniques is presented below:</p>
<dl class="simple">
<dt>DIIS [On by Default]</dt><dd><p>DIIS uses previous iterates of the Fock matrix together
with an error criterion based on the orbital gradient to produce an informed
estimate of the next Fock Matrix. DIIS is almost always necessary to converge
the SCF procedure and is therefore turned on by default. In rare cases, the
DIIS algorithm may need to be modified or turned off altogether, which may be
accomplished via <a class="reference internal" href="autodoc_glossary_options_c.html#term-DIIS-SCF"><span class="xref std std-term">options</span></a>.</p>
</dd>
<dt>ADIIS [On by Default]</dt><dd><p>ADIIS uses previous iterates of the Fock and density matrices to produce an
informed estimate of the next Fock matrix. ADIIS estimates are based on minimizing
an energy estimate rather than zeroing the residual, so this performs best in the early
iterations. By default, Psi will start using ADIIS before blending the ADIIS step with
the DIIS step, eventually using the pure DIIS step. The closely-related EDIIS procedure
may be used instead by setting <a class="reference internal" href="autodoc_glossary_options_c.html#term-SCF_INITIAL_ACCELERATOR-SCF"><span class="xref std std-term">SCF_INITIAL_ACCELERATOR</span></a>. This is formally identical
to ADIIS for HF, but the methods will differ for more general DFT.</p>
</dd>
<dt>MOM [Off by Default]</dt><dd><p>MOM was developed to combat a particular class of convergence failure:
occupation flipping. In some cases, midway though the SCF procedure, a partially
converged orbital which should be occupied in the fully-optimized SCF solution
has a slightly higher orbital eigenvalue than some other orbital which should be
destined to be a virtual orbital. This results in the virtual orbital being
spuriously occupied for one or more iterations. Sometimes this resolves itself
without help, other times the occupation flips back and forth between two, four,
or more orbitals. This is typically visible in the output as a non-converging
SCF which eventually settles down to steady oscillation between two (or more)
different total energies. This behavior can be ameliorated by choosing occupied
orbitals by “shape” instead of by orbital eigenvalue, <em>i.e.</em>, by choosing the set
of new orbitals which looks most like some previously known “good” set.  The
“good” set is typically the occupied orbitals from one of the oscillating
iterations with the lowest total energy. For an oscillating system where the
lowest total energy occurs on iterations <span class="math notranslate nohighlight">\(N,N+2,\ldots\)</span>, invoking
<a class="reference internal" href="autodoc_glossary_options_c.html#term-MOM_START-SCF"><span class="xref std std-term">MOM_START</span></a> <code class="docutils literal notranslate"><span class="pre">N</span></code> can often rescue the convergence of the SCF. MOM can
be used in concert with DIIS, though care should be taken to not turn MOM on
until the oscillatory behavior begins.</p>
</dd>
<dt>Damping [Off by Default]</dt><dd><p>In some cases, a static mixing of Fock Matrices from adjacent
iterations can quench oscillations. This mixing, known as
“damping” can be activated by setting the
<a class="reference internal" href="autodoc_glossary_options_c.html#term-DAMPING_PERCENTAGE-SCF"><span class="xref std std-term">DAMPING_PERCENTAGE</span></a> keyword to a nonzero percent. Damping is
turned off when the DIIS error is smaller than
<a class="reference internal" href="autodoc_glossary_options_c.html#term-DAMPING_CONVERGENCE-SCF"><span class="xref std std-term">DAMPING_CONVERGENCE</span></a>.</p>
</dd>
<dt>Level shifting [Off by default]</dt><dd><p>A commonly used alternative to damping is to use level shifting,
which decreases the mixing of occupied and unoccupied orbitals in
the SCF update by moving the unoccupied orbitals up in energy. It
can be shown that the SCF procedure always converges with a
suitably large level shift; however, the larger the shift is, the
slower the convergence becomes, and the calculation may end up
converging onto a higher lying SCF solution. Because of this, in
practice level shifting is most useful in the initial phase of the
calculation to reduce the orbital error enough for DIIS to work
well. The level shift is controlled by the parameter
<a class="reference internal" href="autodoc_glossary_options_c.html#term-LEVEL_SHIFT-SCF"><span class="xref std std-term">LEVEL_SHIFT</span></a>, and it is turned off when the DIIS error is
smaller than <a class="reference internal" href="autodoc_glossary_options_c.html#term-LEVEL_SHIFT_CUTOFF-SCF"><span class="xref std std-term">LEVEL_SHIFT_CUTOFF</span></a>. Reasonable values for
the shift and convergence threshold are 5.0 and 1e-2,
respectively.</p>
</dd>
<dt>SOSCF [Off by Default]</dt><dd><p>See <a class="reference internal" href="#sec-soscf"><span class="std std-ref">Second-order Convergence</span></a></p>
</dd>
</dl>
</section>
<section id="eri-algorithms">
<span id="sec-scferi"></span><h2>ERI Algorithms<a class="headerlink" href="#eri-algorithms" title="Link to this heading">#</a></h2>
<p>The key difficulty in the SCF procedure is treatment of the four-index ERI
contributions to the Fock Matrix. A number of algorithms are available in
<span style="font-family: Optima, sans-serif; text-transform: none;">P<span style="font-size: 82%;">SI</span>4</span> for these terms. The algorithm is selected by the <a class="reference internal" href="autodoc_glossary_options_c.html#term-SCF_TYPE-GLOBALS"><span class="xref std std-term">SCF_TYPE</span></a>
keyword. Most consist of a single algorithm applied to
the construction of both the Coulomb and Exchange parts
of the Fock Matrix:</p>
<dl class="simple">
<dt>PK [<a class="reference internal" href="#table-conv-scf"><span class="std std-ref">Default</span></a>]</dt><dd><p>An out-of-core, presorted algorithm using exact ERIs. Quite fast for a
zero-error algorithm if enough memory is available. Integrals are
generated only once, and symmetry is utilized to reduce number of
integrals.</p>
</dd>
<dt>OUT_OF_CORE</dt><dd><p>An out-of-core, unsorted algorithm using exact ERIs. Overcomes the
memory bottleneck of the current PK algorithm. Integrals are generated
only once, and symmetry is utilized to reduce number of integrals.</p>
</dd>
<dt>DIRECT</dt><dd><p>A threaded, sieved, integral-direct algorithm, with full permutational
symmetry. This algorithm is brand new, but seems to be reasonably fast
up to 1500 basis functions, uses zero disk (if DF pre-iterations are
turned off), and can obtain significant
speedups with negligible error loss if <a class="reference internal" href="autodoc_glossary_options_c.html#term-INTS_TOLERANCE-SCF"><span class="xref std std-term">INTS_TOLERANCE</span></a>
is set to 1.0E-8 or so.</p>
</dd>
<dt>DF [<a class="reference internal" href="#table-conv-scf"><span class="std std-ref">Default</span></a>]</dt><dd><p>A density-fitted algorithm designed for computations with thousands of
basis functions. This algorithm is highly optimized, and is threaded
with a mixture of parallel BLAS and OpenMP. Note that this algorithm
should use the -JKFIT series of auxiliary bases, <em>not</em> the -RI or
-MP2FIT bases. The default guess for auxiliary basis set should work
for most bases, otherwise the <a class="reference internal" href="autodoc_glossary_options_c.html#term-DF_BASIS_SCF-SCF"><span class="xref std std-term">DF_BASIS_SCF</span></a> keyword can
be used to manually specify the auxiliary basis.  This algorithm is
preferred unless either absolute accuracy is required
[<span class="math notranslate nohighlight">\(\gtrsim\)</span>CCSD(T)] or a -JKFIT auxiliary basis is unavailable
for the orbital basis/atoms involved.</p>
</dd>
<dt>CD</dt><dd><p>A threaded algorithm using approximate ERIs obtained by Cholesky
decomposition of the ERI tensor.  The accuracy of the Cholesky
decomposition is controlled by the keyword <a class="reference internal" href="autodoc_glossary_options_c.html#term-CHOLESKY_TOLERANCE-SCF"><span class="xref std std-term">CHOLESKY_TOLERANCE</span></a>.
This algorithm is similar to the DF algorithm, but it is not suitable
for gradient computations.  The algorithm to obtain the Cholesky
vectors is not designed for computations with thousands of basis
functions.</p>
</dd>
</dl>
<p><span style="font-family: Optima, sans-serif; text-transform: none;">P<span style="font-size: 82%;">SI</span>4</span> also features the capability to use “composite” Fock matrix build
algorithms - arbitrary combinations of specialized algorithms that construct
either the Coulomb or the Exchange matrix separately. In general, since
separate Coulomb and Exchange matrix build algorithms exploit properties specific to
their respective matrix, composite algorithms display lower
scaling factors than their combined Fock build counterparts. However, composite algorithms also
introduce redundant ERI computations into the calculation. Therefore, composite Fock build
algorithms tend to perform better for larger systems, but worse for smaller systems. Arbitrary
composite algorithms can be accessed by setting <a class="reference internal" href="autodoc_glossary_options_c.html#term-SCF_TYPE-GLOBALS"><span class="xref std std-term">SCF_TYPE</span></a> to <code class="docutils literal notranslate"><span class="pre">J_alg+K_alg</span></code>,
where <em>J_alg</em> and <em>K_alg</em> are the names of the separate Coulomb
and Exchange construction algorithms to use, respectively.</p>
<p>Specialized algorithms available to construct the Coulomb term within a composite framework
are as follows:</p>
<dl class="simple">
<dt>DFDIRJ</dt><dd><p>An integral-direct algorithm constructing the Coulomb term based on <a class="reference internal" href="bibliography.html#weigend-2002-4285" id="id17"><span>[Weigend:2002:4285]</span></a>
The DFDIRJ algorithm combines the benefits of integral-direct SCF approaches
with that of density-fitting. Specifically, DFJ utilizes no I/O and displays
strong performance with large system size through a combination of
effective parallelization and utilization of density-fitting to minimize
ERI computational cost. See the <a class="reference internal" href="#sec-scfddfj"><span class="std std-ref">Integral-Direct Density-Fitted Coulomb Construction</span></a> section for more information.</p>
</dd>
</dl>
<p>Specialized algorithms available to construct the Exchange term within a composite framework
are as follows:</p>
<dl class="simple">
<dt>COSX</dt><dd><p>An algorithm based on the semi-numerical “chain of spheres exchange” (COSX)
approach described in <a class="reference internal" href="bibliography.html#neese-2009-98" id="id18"><span>[Neese:2009:98]</span></a>. The coulomb term is computed with a
direct density-fitting algorithm. The COSX algorithm uses no I/O, scales
well with system size, and requires minimal memory, making it ideal for
large systems and multi-core CPUs. See <a class="reference internal" href="#sec-scfcosx"><span class="std std-ref">COSX Exchange</span></a> for more information.</p>
</dd>
<dt>LINK</dt><dd><p>An implementation of the linear-scaling “Linear Exchange” (LinK)
algorithm described in <a class="reference internal" href="bibliography.html#ochsenfeld-1998-1663" id="id19"><span>[Ochsenfeld:1998:1663]</span></a>. The LINK algorithm provides
many of the benefits of integral-direct SCF algorithms, including no disk I/O,
low memory usage, and effective parallelization. Additionally, the
LINK implementation scales well with system size
while simultaneously providing a formally-exact computation of the
Exchange term. See <a class="reference internal" href="#sec-scflink"><span class="std std-ref">Linear Exchange</span></a> for more information.</p>
</dd>
</dl>
<p>In some cases the above algorithms have multiple implementations that return
the same result, but are optimal under different molecules sizes and hardware
configurations. Psi4 will automatically detect the correct algorithm to run and
only expert users should manually select the below implementations. The DF
algorithm has the following two implementations</p>
<dl class="simple">
<dt>MEM_DF</dt><dd><p>A DF algorithm optimized around memory layout and is optimal as long as
there is sufficient memory to hold the three-index DF tensors in memory. This
algorithm may be faster for builds that require disk if SSDs are used.</p>
</dd>
<dt>DISK_DF</dt><dd><p>A DF algorithm (the default DF algorithm before Psi4 1.2) optimized to
minimize Disk IO by sacrificing some performance due to memory layout.</p>
</dd>
</dl>
<p>Note that these algorithms have both in-memory and on-disk options, but
performance penalties up to a factor of 2.5 can be found if the incorrect
algorithm is chosen. It is therefore highly recommended that the keyword “DF”
be selected in all cases so that the correct implementation can be selected by
<span style="font-family: Optima, sans-serif; text-transform: none;">P<span style="font-size: 82%;">SI</span>4</span>‘s internal routines. Expert users can manually switch between MEM_DF and
DISK_DF; however, they may find documented exceptions during use as several
post SCF algorithms require a specific implementation. Additionally, expert users
can manually switch between the in-memory and on-disk options <em>within</em> MEM_DF or DISK_DF using
the <a class="reference internal" href="autodoc_glossary_options_c.html#term-SCF_SUBTYPE-SCF"><span class="xref std std-term">SCF_SUBTYPE</span></a> option. Using <code class="docutils literal notranslate"><span class="pre">SCF_SUBTYPE</span> <span class="pre">=</span> <span class="pre">AUTO</span></code>, where <span style="font-family: Optima, sans-serif; text-transform: none;">P<span style="font-size: 82%;">SI</span>4</span>
automatically selects the in-memory or on-disk option for MEM_DF/DISK_DF based on memory and molecule, is the default
and recommended option. However, the in-memory or on-disk algorithms for MEM_DF and DISK_DF can be forced by using
<code class="docutils literal notranslate"><span class="pre">SCF_SUBTYPE</span> <span class="pre">=</span> <span class="pre">INCORE</span></code> or <code class="docutils literal notranslate"><span class="pre">SCF_SUBTYPE</span> <span class="pre">=</span> <span class="pre">OUT_OF_CORE</span></code>, respectively.
Note that an exception will be thrown if
<code class="docutils literal notranslate"><span class="pre">SCF_SUBTYPE</span> <span class="pre">=</span> <span class="pre">INCORE</span></code> is used without allocating sufficient memory to
<span style="font-family: Optima, sans-serif; text-transform: none;">P<span style="font-size: 82%;">SI</span>4</span>.</p>
<p>For some of these algorithms, Schwarz and/or density sieving can be used to
identify negligible integral contributions in extended systems. To activate
sieving, set the <a class="reference internal" href="autodoc_glossary_options_c.html#term-INTS_TOLERANCE-SCF"><span class="xref std std-term">INTS_TOLERANCE</span></a> keyword to your desired cutoff
(1.0E-12 is recommended for most applications). To choose the type of sieving, set
the <a class="reference internal" href="autodoc_glossary_options_c.html#term-SCREENING-GLOBALS"><span class="xref std std-term">SCREENING</span></a> keyword to your desired option. For Schwarz screening, set it
to <code class="docutils literal notranslate"><span class="pre">SCHWARZ</span></code>, for CSAM, <code class="docutils literal notranslate"><span class="pre">CSAM</span></code>, and for density matrix-based screening, <code class="docutils literal notranslate"><span class="pre">DENSITY</span></code>.</p>
<dl class="simple">
<dt>SCHWARZ</dt><dd><p>Uses the Cauchy-Schwarz inequality to calculate an upper bounded value of a shell quartet,</p>
</dd>
</dl>
<div class="math notranslate nohighlight">
\[(PQ|RS) &lt;= \sqrt{(PQ|PQ)(RS|RS)}\]</div>
<dl class="simple">
<dt>CSAM</dt><dd><p>An extension of the Schwarz estimate that also screens over the long range 1/r operator, described in <a class="reference internal" href="bibliography.html#thompson-2017-144101" id="id20"><span>[Thompson:2017:144101]</span></a>.</p>
</dd>
<dt>DENSITY</dt><dd><p>An extension of the Schwarz estimate that also screens over elements of the density matrix.
For the RHF case, described in <a class="reference internal" href="bibliography.html#haser-1989-104" id="id21"><span>[Haser:1989:104]</span></a></p>
</dd>
</dl>
<div class="math notranslate nohighlight">
\[CON(PQ|RS) &lt;= \sqrt{(PQ|PQ)(RS|RS)} \cdot DCON(PQ, RS)\]</div>
<div class="math notranslate nohighlight">
\[DCON(PQ, RS) = max(4D_{PQ}, 4D_{RS}, D_{PR}, D_{PS}, D_{QR}, D_{QS})\]</div>
<p>When using density-matrix based integral screening, it is useful to build the J and K matrices
incrementally, also described in <a class="reference internal" href="bibliography.html#haser-1989-104" id="id22"><span>[Haser:1989:104]</span></a>, using the difference in the density matrix between iterations, rather than the
full density matrix. To turn on this option, set <a class="reference internal" href="autodoc_glossary_options_c.html#term-INCFOCK-SCF"><span class="xref std std-term">INCFOCK</span></a> to <code class="docutils literal notranslate"><span class="pre">true</span></code>.</p>
<p>We have added the automatic capability to use the extremely fast DF
code for intermediate convergence of the orbitals, for <a class="reference internal" href="autodoc_glossary_options_c.html#term-SCF_TYPE-GLOBALS"><span class="xref std std-term">SCF_TYPE</span></a>
<code class="docutils literal notranslate"><span class="pre">DIRECT</span></code>. At the moment, the code defaults to cc-pVDZ-JKFIT as the
auxiliary basis, unless the user specifies <a class="reference internal" href="autodoc_glossary_options_c.html#term-DF_BASIS_SCF-SCF"><span class="xref std std-term">DF_BASIS_SCF</span></a> manually. For
some atoms, cc-pVDZ-JKFIT is not defined, so a very large fitting basis of last
resort will be used.
To avoid this, either set <a class="reference internal" href="autodoc_glossary_options_c.html#term-DF_BASIS_SCF-SCF"><span class="xref std std-term">DF_BASIS_SCF</span></a> to an auxiliary
basis set defined for all atoms in the system, or set <a class="reference internal" href="autodoc_glossary_options_c.html#term-DF_SCF_GUESS-SCF"><span class="xref std std-term">DF_SCF_GUESS</span></a>
to false, which disables this acceleration entirely.</p>
</section>
<section id="integral-direct-density-fitted-coulomb-construction">
<span id="sec-scfddfj"></span><h2>Integral-Direct Density-Fitted Coulomb Construction<a class="headerlink" href="#integral-direct-density-fitted-coulomb-construction" title="Link to this heading">#</a></h2>
<p>The Resolution of the Identity (RI) can be used to decompose the normally 4-center ERI tensor into a combination of 3-center and 2-center components.
By reducing the dimensionality of the ERI tensor, application of the RI (often referred to as density-fitting, or DF) can be used to greatly speed up
SCF calculations. The reduction in ERI tensor rank also makes DF an appealing option for conventional SCF calculations, where the ERIs are stored
in core or on disk. However, even when using DF, I/O becomes a significant bottleneck for systems of a sufficient size when performing conventional SCF
calculations. In principle, though, DF approaches can be utilized in an integral-direct context, gaining the benefits of DF methods without suffering the
I/O bottlenecks that conventional DF methods will eventually run into. One such approach, outlined by Weigend in <a class="reference internal" href="bibliography.html#weigend-2002-4285" id="id23"><span>[Weigend:2002:4285]</span></a>,
is available for use in Psi4 for the separate construction of the Coulomb contribution to the Fock matrix.  This implementation can be used alongside
Psi4’s separate Exchange construction algorithms for composite Fock matrix construction by using the keyword DFDIRJ as the Coulomb construction
algorithm when specifying <a class="reference internal" href="autodoc_glossary_options_c.html#term-SCF_TYPE-GLOBALS"><span class="xref std std-term">SCF_TYPE</span></a> to use a composite algorithm combination (<code class="docutils literal notranslate"><span class="pre">DFDIRJ+K_alg</span></code>).</p>
<p>DFDIRJ supports multiple capabilities to improve performance. Specifically, DFDIRJ allows for a combination of density-matrix based ERI
screening (set <a class="reference internal" href="autodoc_glossary_options_c.html#term-SCREENING-GLOBALS"><span class="xref std std-term">SCREENING</span></a> to <code class="docutils literal notranslate"><span class="pre">DENSITY</span></code>) and incremental Fock matrix construction (set <a class="reference internal" href="autodoc_glossary_options_c.html#term-INCFOCK-SCF"><span class="xref std std-term">INCFOCK</span></a> to <code class="docutils literal notranslate"><span class="pre">TRUE</span></code>). These two, when combined,
enable more aggressive screening of ERI contributions to the Coulomb matrix and thus greatly improve performance.</p>
</section>
<section id="cosx-exchange">
<span id="sec-scfcosx"></span><h2>COSX Exchange<a class="headerlink" href="#cosx-exchange" title="Link to this heading">#</a></h2>
<p>The semi-numerical COSX algorithm described in <a class="reference internal" href="bibliography.html#neese-2009-98" id="id24"><span>[Neese:2009:98]</span></a> evaluates
two-electron ERIs analytically over one electron coordinate and numerically
over the other electron coordinate, and belongs to the family of pseudospectral
methods originally suggested by Friesner. In COSX, numerical integration is performed on standard
DFT quadrature grids, which are described in <a class="reference internal" href="dft.html#sec-dft"><span class="std std-ref">DFT: Density Functional Theory</span></a>.
Both the accuracy of the COSX algorithm and also the computational
cost are directly determined by the size of the integration grid, so selection
of the grid is important. This COSX implementation uses two separate grids.
By default, the SCF algorithm is first converged on a smaller grid, followed by a
number of SCF iterations up to a maximum value (controlled by the <a class="reference internal" href="autodoc_glossary_options_c.html#term-COSX_MAXITER_FINAL-SCF"><span class="xref std std-term">COSX_MAXITER_FINAL</span></a> keyword)
on a larger grid. By default, <a class="reference internal" href="autodoc_glossary_options_c.html#term-COSX_MAXITER_FINAL-SCF"><span class="xref std std-term">COSX_MAXITER_FINAL</span></a> is set to 1, a single
SCF iteration, which results in numerical errors comparable to
performing the entire SCF on the expensive larger grid at a computational cost
much closer to the smaller grid. Setting <a class="reference internal" href="autodoc_glossary_options_c.html#term-COSX_MAXITER_FINAL-SCF"><span class="xref std std-term">COSX_MAXITER_FINAL</span></a> to 0 disables the
larger grid entirely. Setting <a class="reference internal" href="autodoc_glossary_options_c.html#term-COSX_MAXITER_FINAL-SCF"><span class="xref std std-term">COSX_MAXITER_FINAL</span></a> to -1 allows
for the SCF to fully converge on the larger grid, useful for the study of wavefunction
properties such as gradients. The size of the initial grid is controlled by the keywords
<a class="reference internal" href="autodoc_glossary_options_c.html#term-COSX_RADIAL_POINTS_INITIAL-SCF"><span class="xref std std-term">COSX_RADIAL_POINTS_INITIAL</span></a> and <a class="reference internal" href="autodoc_glossary_options_c.html#term-COSX_SPHERICAL_POINTS_INITIAL-SCF"><span class="xref std std-term">COSX_SPHERICAL_POINTS_INITIAL</span></a>.
The final grid is controlled by <a class="reference internal" href="autodoc_glossary_options_c.html#term-COSX_RADIAL_POINTS_FINAL-SCF"><span class="xref std std-term">COSX_RADIAL_POINTS_FINAL</span></a> and
<a class="reference internal" href="autodoc_glossary_options_c.html#term-COSX_SPHERICAL_POINTS_FINAL-SCF"><span class="xref std std-term">COSX_SPHERICAL_POINTS_FINAL</span></a>. The defaults for both grids aim to balance
cost and accuracy.</p>
<p>Screening thresholds over integrals, densities, and basis extents are set
with the <a class="reference internal" href="autodoc_glossary_options_c.html#term-COSX_INTS_TOLERANCE-SCF"><span class="xref std std-term">COSX_INTS_TOLERANCE</span></a>, <a class="reference internal" href="autodoc_glossary_options_c.html#term-COSX_DENSITY_TOLERANCE-SCF"><span class="xref std std-term">COSX_DENSITY_TOLERANCE</span></a>, and
<a class="reference internal" href="autodoc_glossary_options_c.html#term-COSX_BASIS_TOLERANCE-SCF"><span class="xref std std-term">COSX_BASIS_TOLERANCE</span></a> keywords, respectively. <a class="reference internal" href="autodoc_glossary_options_c.html#term-COSX_INTS_TOLERANCE-SCF"><span class="xref std std-term">COSX_INTS_TOLERANCE</span></a>
is the most consequential of the three thresholds in both cost and accuracy.
This keyword determines screening of negligible one-electron integrals.
<a class="reference internal" href="autodoc_glossary_options_c.html#term-COSX_DENSITY_TOLERANCE-SCF"><span class="xref std std-term">COSX_DENSITY_TOLERANCE</span></a> controls the threshold for significant
shell pairs in the density matrix. Lastly, <a class="reference internal" href="autodoc_glossary_options_c.html#term-COSX_BASIS_TOLERANCE-SCF"><span class="xref std std-term">COSX_BASIS_TOLERANCE</span></a> is
a cutoff for the value of basis functions at grid points. This keyword is
used to determine the radial extent of the each basis shell, and it is the
COSX analogue to <a class="reference internal" href="autodoc_glossary_options_c.html#term-DFT_BASIS_TOLERANCE-SCF"><span class="xref std std-term">DFT_BASIS_TOLERANCE</span></a>.</p>
<p>The <a class="reference internal" href="autodoc_glossary_options_c.html#term-INCFOCK-SCF"><span class="xref std std-term">INCFOCK</span></a> keyword (defaults to <code class="docutils literal notranslate"><span class="pre">false</span></code>) increases performance
by constructing the Fock matrix from differences in the density matrix, which
are more amenable to screening. This option is disabled by default because of
potential SCF convergence issues, particularly when using diffuse basis functions.
The <a class="reference internal" href="autodoc_glossary_options_c.html#term-COSX_OVERLAP_FITTING-SCF"><span class="xref std std-term">COSX_OVERLAP_FITTING</span></a> keyword (defaults to <code class="docutils literal notranslate"><span class="pre">true</span></code>) reduces numerical
integration errors using the method described in <a class="reference internal" href="bibliography.html#izsak-2011-144105" id="id25"><span>[Izsak:2011:144105]</span></a> and is
always recommended.</p>
</section>
<section id="linear-exchange">
<span id="sec-scflink"></span><h2>Linear Exchange<a class="headerlink" href="#linear-exchange" title="Link to this heading">#</a></h2>
<p>Large SCF calculations can benefit from specialized screening procedures that further reduce the scaling of the ERI contribution to the Fock matrix.
LinK, the linear-scaling exchange method described in <a class="reference internal" href="bibliography.html#ochsenfeld-1998-1663" id="id26"><span>[Ochsenfeld:1998:1663]</span></a>, is available in Psi4 in conjunction with composite algorithms that build J (<a class="reference internal" href="autodoc_glossary_options_c.html#term-SCF_TYPE-GLOBALS"><span class="xref std std-term">SCF_TYPE</span></a> set to <code class="docutils literal notranslate"><span class="pre">J_alg+LINK</span></code>).
LinK achieves linear-scaling by exploiting shell pair sparsity in the density matrix and overlap sparsity between shell pairs. Specifically, LinK exploits the fact that the Exchange term
requires only a linear-scaling number of significant elements through reformulating the
shell quartet screening process to scale linearly with system size.
LinK is most competitive when used with non-diffuse orbital basis sets, since orbital and density overlaps decay slower with diffuse functions.
LinK is especially powerful when combined with density-matrix based ERI screening (set <a class="reference internal" href="autodoc_glossary_options_c.html#term-SCREENING-GLOBALS"><span class="xref std std-term">SCREENING</span></a> to <code class="docutils literal notranslate"><span class="pre">DENSITY</span></code>) and incremental Fock builds (set <a class="reference internal" href="autodoc_glossary_options_c.html#term-INCFOCK-SCF"><span class="xref std std-term">INCFOCK</span></a> to <code class="docutils literal notranslate"><span class="pre">TRUE</span></code>), which decrease the number of significant two-electron integrals to calculate.</p>
<p>To control the LinK algorithm, here are the list of options provided.</p>
<blockquote>
<div><p><a class="reference internal" href="autodoc_glossary_options_c.html#term-LINK_INTS_TOLERANCE-SCF"><span class="xref std std-term">LINK_INTS_TOLERANCE</span></a>: The integral screening tolerance used for sparsity-prep in the LinK algorithm. Defaults to the <a class="reference internal" href="autodoc_glossary_options_c.html#term-INTS_TOLERANCE-SCF"><span class="xref std std-term">INTS_TOLERANCE</span></a> option.</p>
</div></blockquote>
</section>
<section id="second-order-convergence">
<span id="sec-soscf"></span><span id="index-3"></span><h2>Second-order Convergence<a class="headerlink" href="#second-order-convergence" title="Link to this heading">#</a></h2>
<p>Second-order convergence takes into account both the gradient and Hessian to
take a full Newton step with respect to the orbital parameters. This results in
quadratic convergence with respect to density for SCF methods. For cases where
normal acceleration methods either fail or take many iterations to converge,
second-order can reduce the total time to solution.</p>
<p>Solving second-order (SO) methods exactly would require an inversion of the
orbital Hessian (an expensive <span class="math notranslate nohighlight">\(\mathbb{N}^6\)</span> operation); however, these
equations are normally solved iteratively where each iteration costs the same
as a normal Fock build (<span class="math notranslate nohighlight">\(\mathbb{N}^4\)</span>). The overall SOSCF operation is
thus broken down into micro- and macroiterations where the microiterations
refer to solving the SOSCF equations and macroiterations are the construction
of a new Fock matrix based on the orbitals from a SOSCF step.</p>
<p>SOSCF requires that all elements of the gradient to be less than one before the
method is valid. To this end, pre-SOSCF SCF iterations use normal
gradient-based extrapolation procedures (<em>e.g.</em>, DIIS) until the gradient
conditions are met. Note that while the total number of macroiterations will be
less for SOSCF than gradient-based convergence acceleration, the cost of solving
the microiterations typically results in the overall cost being greater for
SOSCF than for gradient-based methods. Therefore, SOSCF should only be used if
it is difficult to locate a stable minimum.</p>
<p>SOSCF is available for all HF and DFT references with the exception of meta-
GGA functionals. To enable, set the option <a class="reference internal" href="autodoc_glossary_options_c.html#term-SOSCF-SCF"><span class="xref std std-term">SOSCF</span></a> to <code class="docutils literal notranslate"><span class="pre">true</span></code>.
Additional options to modify the number of microiterations taken are as
follows:</p>
<blockquote>
<div><p><a class="reference internal" href="autodoc_glossary_options_c.html#term-SOSCF_START_CONVERGENCE-SCF"><span class="xref std std-term">SOSCF_START_CONVERGENCE</span></a>: when to start SOSCF based on the current density RMS</p>
<p><a class="reference internal" href="autodoc_glossary_options_c.html#term-SOSCF_MAX_ITER-SCF"><span class="xref std std-term">SOSCF_MAX_ITER</span></a>: the maximum number of SOSCF microiterations per macroiteration</p>
<p><a class="reference internal" href="autodoc_glossary_options_c.html#term-SOSCF_CONV-SCF"><span class="xref std std-term">SOSCF_CONV</span></a>: the relative convergence tolerance of the SOSCF microiterations</p>
<p><a class="reference internal" href="autodoc_glossary_options_c.html#term-SOSCF_PRINT-SCF"><span class="xref std std-term">SOSCF_PRINT</span></a>: option to print the microiterations or not</p>
</div></blockquote>
</section>
<section id="stability-analysis">
<span id="sec-scfstability-doc"></span><h2>Stability Analysis<a class="headerlink" href="#stability-analysis" title="Link to this heading">#</a></h2>
<p>SCF algorithms attempt to minimize the gradient of the energy with respect
to orbital variation parameters. At convergence, the gradient should be approximately zero
given a convergence criterion. Although this is enough to make sure the SCF converged to a
stationary point, this is not a sufficient condition for a minimal SCF solution. It may be
a saddle point or a maximum.</p>
<p>To ensure that a minimum has been found, the electronic Hessian, <em>i.e.</em> the matrix of second
derivatives of the energy with respect to orbital variation parameters, must be computed.
If one or more eigenvalues of the electronic Hessian are negative, the SCF solution is not a minimum.
In that case, orbital parameters can be varied along the lowest Hessian eigenvector to lower the energy.</p>
<p>Orbital variation parameters are usually constrained. For example, in RHF the
spatial parts of the <span class="math notranslate nohighlight">\(\alpha\)</span> and <span class="math notranslate nohighlight">\(\beta\)</span> orbitals are the same. In
UHF, the orbital coefficients are usually constrained to be real. A stability analysis
can check whether a lower SCF solution exists while respecting the constraints of the original
solution; this is an internal instability. If one or more constraints have to be relaxed to reach
a lower-energy solution, there is an external instability. In <span style="font-family: Optima, sans-serif; text-transform: none;">P<span style="font-size: 82%;">SI</span>4</span>, the only external instability
that can be checked at present is the RHF <span class="math notranslate nohighlight">\(\rightarrow\)</span> UHF one.</p>
<p>Currently, two algorithms exist in <span style="font-family: Optima, sans-serif; text-transform: none;">P<span style="font-size: 82%;">SI</span>4</span> for stability analysis: the original
Direct Inversion and the newly implemented Davidson algorithms. We will first describe
options common to both algorithms. To request a stability analysis at the end of the SCF,
set the keyword <a class="reference internal" href="autodoc_glossary_options_c.html#term-STABILITY_ANALYSIS-SCF"><span class="xref std std-term">STABILITY_ANALYSIS</span></a>. Value <code class="docutils literal notranslate"><span class="pre">CHECK</span></code> only computes the electronic
Hessian eigenvalue and checks if an actual SCF minimum has been found, while value <code class="docutils literal notranslate"><span class="pre">FOLLOW</span></code>
rotates the converged orbitals along the lowest eigenvector, then invokes the SCF
procedure again to lower the energy. In case the minimization does not succeed
or ends up on the same unstable solution, you can tune the scale factor for the orbital
rotation through the keyword <a class="reference internal" href="autodoc_glossary_options_c.html#term-FOLLOW_STEP_SCALE-SCF"><span class="xref std std-term">FOLLOW_STEP_SCALE</span></a>.
The rotation angle is <span class="math notranslate nohighlight">\(\frac{\pi}{2}\mbox{ } \cdot\)</span> (<a class="reference internal" href="autodoc_glossary_options_c.html#term-FOLLOW_STEP_SCALE-SCF"><span class="xref std std-term">FOLLOW_STEP_SCALE</span></a>). The default value of
0.5 usually provides a good guess, and modification is only recommended in difficult cases.
The default behavior for the stability code is to stop after trying to reoptimize the orbitals once
if the instability still exists. For more attempts, set <a class="reference internal" href="autodoc_glossary_options_c.html#term-MAX_ATTEMPTS-SCF"><span class="xref std std-term">MAX_ATTEMPTS</span></a>;
the default value of 1 is recommended. In case the SCF ends up in the same minimum, modification
of <a class="reference internal" href="autodoc_glossary_options_c.html#term-FOLLOW_STEP_SCALE-SCF"><span class="xref std std-term">FOLLOW_STEP_SCALE</span></a> is recommended over increasing <a class="reference internal" href="autodoc_glossary_options_c.html#term-MAX_ATTEMPTS-SCF"><span class="xref std std-term">MAX_ATTEMPTS</span></a>.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Setting the option <a class="reference internal" href="autodoc_glossary_options_c.html#term-STABILITY_ANALYSIS-SCF"><span class="xref std std-term">STABILITY_ANALYSIS</span></a> to <code class="docutils literal notranslate"><span class="pre">FOLLOW</span></code> is only avalible for UHF. When using
RHF and ROHF instabilities can be checked, but not followed. If you want to attempt to find a lower energy solution
you should re-run the calculation with <a class="reference internal" href="autodoc_glossary_options_c.html#term-REFERENCE-SCF"><span class="xref std std-term">REFERENCE</span></a> set to <code class="docutils literal notranslate"><span class="pre">UHF</span></code>.</p>
</div>
<p>The main algorithm available in <span style="font-family: Optima, sans-serif; text-transform: none;">P<span style="font-size: 82%;">SI</span>4</span> is the Direct Inversion algorithm. It can <em>only</em>
work with <a class="reference internal" href="autodoc_glossary_options_c.html#term-SCF_TYPE-GLOBALS"><span class="xref std std-term">SCF_TYPE</span></a> <code class="docutils literal notranslate"><span class="pre">PK</span></code>, and it explicitly builds the full electronic Hessian
matrix before explicitly inverting it. As such, this algorithm is very slow and it should
be avoided whenever possible. Direct Inversion is automatically invoked if the newer algorithm
is not available.</p>
<p>The Davidson algorithm for stability analysis was implemented recently.
Only the lowest eigenvalues of the electronic Hessian are computed, and Hessian-vector
products are computed instead of the full Hessian. This algorithm is thus
much more efficient than the Direct Inversion, but at present, it is only available for UHF <span class="math notranslate nohighlight">\(\rightarrow\)</span> UHF stability
analysis. The capabilities of both algorithms are summarized below:</p>
<span id="table-stab-methods"></span><table class="table" id="id37">
<caption><span class="caption-text">Stability analysis methods available in <span style="font-family: Optima, sans-serif; text-transform: none;">P<span style="font-size: 82%;">SI</span>4</span></span><a class="headerlink" href="#id37" title="Link to this table">#</a></caption>
<thead>
<tr class="row-odd"><th class="head"><p>Algorithm</p></th>
<th class="head"><p><a class="reference internal" href="autodoc_glossary_options_c.html#term-REFERENCE-SCF"><span class="xref std std-term">REFERENCE</span></a></p></th>
<th class="head"><p>Stability checked</p></th>
<th class="head"><p><a class="reference internal" href="autodoc_glossary_options_c.html#term-STABILITY_ANALYSIS-SCF"><span class="xref std std-term">STABILITY_ANALYSIS</span></a></p></th>
<th class="head"><p><a class="reference internal" href="autodoc_glossary_options_c.html#term-SCF_TYPE-GLOBALS"><span class="xref std std-term">SCF_TYPE</span></a></p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td rowspan="2"><p>Direct Inversion</p></td>
<td><p>RHF</p></td>
<td><p>Internal, External (<span class="math notranslate nohighlight">\(\rightarrow\)</span> UHF)</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">CHECK</span></code></p></td>
<td><p>PK only</p></td>
</tr>
<tr class="row-odd"><td><p>ROHF</p></td>
<td><p>Internal</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">CHECK</span></code></p></td>
<td><p>PK only</p></td>
</tr>
<tr class="row-even"><td><p>Davidson</p></td>
<td><p>UHF</p></td>
<td><p>Internal</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">CHECK</span></code> or <code class="docutils literal notranslate"><span class="pre">FOLLOW</span></code></p></td>
<td><p>Anything</p></td>
</tr>
</tbody>
</table>
<p>The best algorithm is automatically selected, <em>i.e.</em> Davidson for UHF <span class="math notranslate nohighlight">\(\rightarrow\)</span> UHF and Direct Inversion otherwise.</p>
<p>In addition to the options available for Direct Inversion, the Davidson algorithm can automatically
adapt <a class="reference internal" href="autodoc_glossary_options_c.html#term-FOLLOW_STEP_SCALE-SCF"><span class="xref std std-term">FOLLOW_STEP_SCALE</span></a> to find a new SCF minimum. If <a class="reference internal" href="autodoc_glossary_options_c.html#term-MAX_ATTEMPTS-SCF"><span class="xref std std-term">MAX_ATTEMPTS</span></a> &gt; 1, additional attempts
will automatically increment <a class="reference internal" href="autodoc_glossary_options_c.html#term-FOLLOW_STEP_SCALE-SCF"><span class="xref std std-term">FOLLOW_STEP_SCALE</span></a> by 0.2 every time the SCF falls back to the previously
found unstable minimum. The increment can be adjusted by setting <a class="reference internal" href="autodoc_glossary_options_c.html#term-FOLLOW_STEP_INCREMENT-SCF"><span class="xref std std-term">FOLLOW_STEP_INCREMENT</span></a>.
The default value is 0.2; adjust if needed to try different values of <a class="reference internal" href="autodoc_glossary_options_c.html#term-FOLLOW_STEP_SCALE-SCF"><span class="xref std std-term">FOLLOW_STEP_SCALE</span></a> in a single computation.</p>
<p>The Davidson solver for the eigenvalues is controlled through several keywords.</p>
<blockquote>
<div><p><a class="reference internal" href="autodoc_glossary_options_c.html#term-SOLVER_MAXITER-SCF"><span class="xref std std-term">SOLVER_MAXITER</span></a>: maximum number of iterations</p>
<p><a class="reference internal" href="autodoc_glossary_options_c.html#term-SOLVER_CONVERGENCE-SCF"><span class="xref std std-term">SOLVER_CONVERGENCE</span></a>: eigenvector convergence threshold</p>
<p><a class="reference internal" href="autodoc_glossary_options_c.html#term-SOLVER_N_ROOT-SCF"><span class="xref std std-term">SOLVER_N_ROOT</span></a>: Solve for N eigenvectors in each irreducible representation</p>
<p><a class="reference internal" href="autodoc_glossary_options_c.html#term-SOLVER_ROOTS_PER_IRREP-SCF"><span class="xref std std-term">SOLVER_ROOTS_PER_IRREP</span></a>: The number of eigenvectors to solve in each irreducible representation. An array of as many integers as there are irreducible representations.</p>
<p><a class="reference internal" href="autodoc_glossary_options_c.html#term-SOLVER_N_GUESS-SCF"><span class="xref std std-term">SOLVER_N_GUESS</span></a>: Use N guess vectors, this needs to be larger than the number of roots so that the lowest ones can be captured reliably. Defaults to 4 guess vectors per root.</p>
</div></blockquote>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>Prior to Dec 2022, v1.7, Psi4 had a different set of keywords controlling instability analysis, and those were included in the CPHF module rather than the SCF module.</p>
</div>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>Extending Davidson instability analysis to Kohn-Sham references is under development. As of 1.7, only LDA functionals are currently supported.</p>
</div>
<p>In case convergence problems are encountered during the Davidson procedure, file a bug report.
If the solver seems to converge on the wrong eigenvalue, try increasing <a class="reference internal" href="autodoc_glossary_options_c.html#term-SOLVER_N_GUESS-SCF"><span class="xref std std-term">SOLVER_N_GUESS</span></a>.
Otherwise, if the solver is almost converged but reaches the maximum number of iterations, try increasing
<a class="reference internal" href="autodoc_glossary_options_c.html#term-SOLVER_MAXITER-SCF"><span class="xref std std-term">SOLVER_MAXITER</span></a>.</p>
</section>
<section id="effective-core-potentials-ecps">
<span id="sec-scf-ecps"></span><h2>Effective core potentials (ECPs)<a class="headerlink" href="#effective-core-potentials-ecps" title="Link to this heading">#</a></h2>
<p><span style="font-family: Optima, sans-serif; text-transform: none;">P<span style="font-size: 82%;">SI</span>4</span> supports the use of effective core potentials to describe the
innermost electrons in heavy elements.
ECPs are only available if <span style="font-family: Optima, sans-serif; text-transform: none;">P<span style="font-size: 82%;">SI</span>4</span> is compiled with the <a class="reference internal" href="ecpint.html#cmake-ecpint"><span class="std std-ref">LibECPInt</span></a> library.
If a basis set is designed to use an
effective core potential, the ECP definition should be simply placed alongside
the orbital basis set definition, <em>c.f.</em> <a class="reference internal" href="basissets.html#sec-basissets-ecps"><span class="std std-ref">Inputting effective core potentials (ECPs)</span></a>.  All
information related to the definition and number of core electrons will
automatically be detected and no further input is required to use the
ECP-containing basis set.  See <a class="reference external" href="https://github.com/psi4/psi4/blob/master/samples/scf-ecp/input.dat">scf-ecp</a> and <a class="reference external" href="https://github.com/psi4/psi4/blob/master/samples/dfmp2-ecp/input.dat">dfmp2-ecp</a>
for examples of computations with ECP-containing basis sets.</p>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>Prior to May 2022, v1.6, Psi4 used a built-in ECP code. Analytic derivatives of ECPs were not available. The HF and DFT derivatives were implemented in a semi-numerical scheme, where numerical ECP gradients were added to analytic SCF gradients. For post-SCF methods, the entire gradient computation needed to be run as finite difference of energies.</p>
</div>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>As of May 2022, v1.6, Psi4 uses the LibECPInt library, and analytic derivatives and Hessians of ECPs are available. Analytic derivatives of molecular systems including ECPs should be available whenever the method has analytic derivatives, but these have so far only been verified for HF and DFT.</p>
</div>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>ECPs have not been tested with projected basis set guesses or with FI-SAPT calculations.  If you require this functionality, please contact the developers on GitHub and/or the <a class="reference external" href="http://forum.psicode.org">forum</a>.</p>
</div>
</section>
<section id="external-potentials-and-qm-mm">
<span id="sec-scfqmmm"></span><h2>External potentials and QM/MM<a class="headerlink" href="#external-potentials-and-qm-mm" title="Link to this heading">#</a></h2>
<p>In addition to the implementation of <a class="reference internal" href="libefp.html#sec-libefp"><span class="std std-ref">EFP</span></a> for accurate QM/MM
computations, <span style="font-family: Optima, sans-serif; text-transform: none;">P<span style="font-size: 82%;">SI</span>4</span> can perform more rudimentary QM/MM procedures via the
<a class="reference internal" href="autodoc_glossary_options_c.html#term-EXTERN-SCF"><span class="xref std std-term">EXTERN</span></a> keyword.  The following snippet, extracted from the
<a class="reference external" href="https://github.com/psi4/psi4/blob/master/samples/extern1/input.dat">extern1</a> test case, demonstrates its use for a TIP3P external potential:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="n">external_potentials</span> <span class="o">=</span> <span class="p">[</span>
    <span class="p">[</span><span class="o">-</span><span class="mf">0.834</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mf">1.649232019048</span><span class="p">,</span><span class="mf">0.0</span><span class="p">,</span><span class="o">-</span><span class="mf">2.356023604706</span><span class="p">])</span> <span class="o">/</span> <span class="n">psi_bohr2angstroms</span><span class="p">],</span>
    <span class="p">[</span> <span class="mf">0.417</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mf">0.544757019107</span><span class="p">,</span><span class="mf">0.0</span><span class="p">,</span><span class="o">-</span><span class="mf">3.799961446760</span><span class="p">])</span> <span class="o">/</span> <span class="n">psi_bohr2angstroms</span><span class="p">],</span>
    <span class="p">[</span> <span class="mf">0.417</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mf">0.544757019107</span><span class="p">,</span><span class="mf">0.0</span><span class="p">,</span><span class="o">-</span><span class="mf">0.912085762652</span><span class="p">])</span> <span class="o">/</span> <span class="n">psi_bohr2angstroms</span><span class="p">]]</span>

<span class="n">gradient</span><span class="p">(</span><span class="s1">&#39;scf&#39;</span><span class="p">,</span> <span class="n">external_potentials</span><span class="o">=</span><span class="n">external_potentials</span><span class="p">)</span>
</pre></div>
</div>
<p>The <code class="docutils literal notranslate"><span class="pre">external_potentials</span></code> array has three rows for three separate
particles, and it is passed to the SCF code on the last line. The
rows are composed of the atomic charge, x coordinate, y coordinate,
and z coordinate in that order. The atomic charge and coordinates are
specified in atomic units, [e] and [a0]. Add as many particle rows as
needed to describe the full MM region.</p>
<div class="admonition caution">
<p class="admonition-title">Caution</p>
<p>In <span style="font-family: Optima, sans-serif; text-transform: none;">P<span style="font-size: 82%;">SI</span>4</span> previous to Spring 2022 and v1.6, setting an
external potential like the above looked like</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">Chrgfield</span> <span class="o">=</span> <span class="n">QMMM</span><span class="p">()</span>
<span class="n">Chrgfield</span><span class="o">.</span><span class="n">extern</span><span class="o">.</span><span class="n">addCharge</span><span class="p">(</span><span class="o">-</span><span class="mf">0.834</span><span class="p">,</span> <span class="mf">1.649232019048</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">,</span> <span class="o">-</span><span class="mf">2.356023604706</span><span class="p">)</span>
<span class="n">Chrgfield</span><span class="o">.</span><span class="n">extern</span><span class="o">.</span><span class="n">addCharge</span><span class="p">(</span> <span class="mf">0.417</span><span class="p">,</span> <span class="mf">0.544757019107</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">,</span> <span class="o">-</span><span class="mf">3.799961446760</span><span class="p">)</span>
<span class="n">Chrgfield</span><span class="o">.</span><span class="n">extern</span><span class="o">.</span><span class="n">addCharge</span><span class="p">(</span> <span class="mf">0.417</span><span class="p">,</span> <span class="mf">0.544757019107</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">,</span> <span class="o">-</span><span class="mf">0.912085762652</span><span class="p">)</span>
<span class="n">psi4</span><span class="o">.</span><span class="n">set_global_option_python</span><span class="p">(</span><span class="s1">&#39;EXTERN&#39;</span><span class="p">,</span> <span class="n">Chrgfield</span><span class="o">.</span><span class="n">extern</span><span class="p">)</span>

<span class="n">gradient</span><span class="p">(</span><span class="s1">&#39;scf&#39;</span><span class="p">)</span>
</pre></div>
</div>
<p>The main differences are that (1) the specification of
charge locations in the old way used the units of the active
molecule, whereas the new way always uses Bohr and (2) the
specification of the charge and locations in the old way used the
<a class="reference internal" href="api/psi4.driver.QMMM.html#psi4.driver.QMMM" title="psi4.driver.QMMM"><code class="xref py py-class docutils literal notranslate"><span class="pre">psi4.driver.QMMM</span></code></a> class directly and added one charge
per command, whereas the new way consolidates all into an array and
passes it by keyword argument to the calculation.</p>
<p>The successor to the <a class="reference internal" href="api/psi4.driver.QMMM.html#psi4.driver.QMMM" title="psi4.driver.QMMM"><code class="xref py py-class docutils literal notranslate"><span class="pre">psi4.driver.QMMM</span></code></a> class,
<a class="reference internal" href="api/psi4.driver.QMMMbohr.html#psi4.driver.QMMMbohr" title="psi4.driver.QMMMbohr"><code class="xref py py-class docutils literal notranslate"><span class="pre">psi4.driver.QMMMbohr</span></code></a>, is operable, but it is discouraged
from being used directly.</p>
</div>
<p>To run a computation in a constant dipole field, the <a class="reference internal" href="autodoc_glossary_options_c.html#term-PERTURB_H-SCF"><span class="xref std std-term">PERTURB_H</span></a>,
<a class="reference internal" href="autodoc_glossary_options_c.html#term-PERTURB_WITH-SCF"><span class="xref std std-term">PERTURB_WITH</span></a> and <a class="reference internal" href="autodoc_glossary_options_c.html#term-PERTURB_DIPOLE-SCF"><span class="xref std std-term">PERTURB_DIPOLE</span></a> keywords can be used.  As an
example, to add a dipole field of magnitude 0.05 a.u. in the y direction and
0.1 a.u. in the z direction, we can use the following keywords:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="nb">set</span> <span class="n">perturb_h</span> <span class="n">true</span>
<span class="nb">set</span> <span class="n">perturb_with</span> <span class="n">dipole</span>
<span class="nb">set</span> <span class="n">perturb_dipole</span> <span class="p">[</span> <span class="mi">0</span><span class="p">,</span> <span class="mf">0.05</span><span class="p">,</span> <span class="mf">0.1</span> <span class="p">]</span>
</pre></div>
</div>
<p>Note that if any specified fields do not fall along a symmetry axis, the
symmetry of the calculation should be reduced accordingly; if in doubt run the
calculation in C1 symmetry.  For examples of SCF and MP2 calculations in an
external field, see <a class="reference external" href="https://github.com/psi4/psi4/blob/master/samples/scf7/input.dat">scf7</a> and <a class="reference external" href="https://github.com/psi4/psi4/blob/master/samples/dfmp2-grad5/input.dat">dfmp2-grad5</a>.</p>
</section>
<section id="convergence-and-algorithm-defaults">
<span id="sec-scfdefault"></span><h2>Convergence and Algorithm Defaults<a class="headerlink" href="#convergence-and-algorithm-defaults" title="Link to this heading">#</a></h2>
<span id="table-conv-scf"></span><table class="table" id="id38">
<caption><span class="caption-text">SCF algorithm and convergence criteria defaults by calculation type <a class="footnote-reference brackets" href="#f1" id="id27" role="doc-noteref"><span class="fn-bracket">[</span>1<span class="fn-bracket">]</span></a></span><a class="headerlink" href="#id38" title="Link to this table">#</a></caption>
<thead>
<tr class="row-odd"><th class="head"><p><em>Ab Initio</em> Method</p></th>
<th class="head"><p>Calculation Type</p></th>
<th class="head"><p><a class="reference internal" href="autodoc_glossary_options_c.html#term-E_CONVERGENCE-SCF"><span class="xref std std-term">E_CONVERGENCE</span></a></p></th>
<th class="head"><p><a class="reference internal" href="autodoc_glossary_options_c.html#term-D_CONVERGENCE-SCF"><span class="xref std std-term">D_CONVERGENCE</span></a></p></th>
<th class="head"><p><a class="reference internal" href="autodoc_glossary_options_c.html#term-SCF_TYPE-GLOBALS"><span class="xref std std-term">SCF_TYPE</span></a></p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td rowspan="3"><p>SCF of HF or DFT</p></td>
<td><p>energy</p></td>
<td><p>6</p></td>
<td><p>6</p></td>
<td rowspan="3"><p>DF</p></td>
</tr>
<tr class="row-odd"><td><p>optimization</p></td>
<td><p>8</p></td>
<td><p>8</p></td>
</tr>
<tr class="row-even"><td><p>frequency <a class="footnote-reference brackets" href="#f7" id="id28" role="doc-noteref"><span class="fn-bracket">[</span>7<span class="fn-bracket">]</span></a></p></td>
<td><p>8</p></td>
<td><p>8</p></td>
</tr>
<tr class="row-odd"><td rowspan="4"><p>SCF of post-HF</p></td>
<td><p>energy</p></td>
<td><p>8</p></td>
<td><p>8</p></td>
<td rowspan="4"><p>PK <a class="footnote-reference brackets" href="#f3" id="id29" role="doc-noteref"><span class="fn-bracket">[</span>3<span class="fn-bracket">]</span></a></p></td>
</tr>
<tr class="row-even"><td><p>optimization</p></td>
<td><p>10</p></td>
<td><p>10</p></td>
</tr>
<tr class="row-odd"><td><p>frequency <a class="footnote-reference brackets" href="#f7" id="id30" role="doc-noteref"><span class="fn-bracket">[</span>7<span class="fn-bracket">]</span></a></p></td>
<td><p>10</p></td>
<td><p>10</p></td>
</tr>
<tr class="row-even"><td><p>CC property <a class="footnote-reference brackets" href="#f2" id="id31" role="doc-noteref"><span class="fn-bracket">[</span>2<span class="fn-bracket">]</span></a></p></td>
<td><p>10</p></td>
<td><p>10</p></td>
</tr>
</tbody>
</table>
<span id="table-conv-corl"></span><table class="table" id="id39">
<caption><span class="caption-text">Post-SCF convergence criteria defaults by calculation type <a class="footnote-reference brackets" href="#f4" id="id32" role="doc-noteref"><span class="fn-bracket">[</span>4<span class="fn-bracket">]</span></a></span><a class="headerlink" href="#id39" title="Link to this table">#</a></caption>
<thead>
<tr class="row-odd"><th class="head"><p><em>Ab Initio</em> Method</p></th>
<th class="head"><p>Calculation Type</p></th>
<th class="head"><p>E_CONVERGENCE <a class="footnote-reference brackets" href="#f5" id="id33" role="doc-noteref"><span class="fn-bracket">[</span>5<span class="fn-bracket">]</span></a></p></th>
<th class="head"><p>R_CONVERGENCE <a class="footnote-reference brackets" href="#f6" id="id34" role="doc-noteref"><span class="fn-bracket">[</span>6<span class="fn-bracket">]</span></a></p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td rowspan="4"><p>post-HF of post-HF</p></td>
<td><p>energy</p></td>
<td><p>6</p></td>
<td></td>
</tr>
<tr class="row-odd"><td><p>optimization</p></td>
<td><p>8</p></td>
<td></td>
</tr>
<tr class="row-even"><td><p>frequency <a class="footnote-reference brackets" href="#f7" id="id35" role="doc-noteref"><span class="fn-bracket">[</span>7<span class="fn-bracket">]</span></a></p></td>
<td><p>8</p></td>
<td></td>
</tr>
<tr class="row-odd"><td><p>CC property <a class="footnote-reference brackets" href="#f2" id="id36" role="doc-noteref"><span class="fn-bracket">[</span>2<span class="fn-bracket">]</span></a></p></td>
<td><p>8</p></td>
<td></td>
</tr>
</tbody>
</table>
<p class="rubric">Footnotes</p>
<aside class="footnote-list brackets">
<aside class="footnote brackets" id="f1" role="doc-footnote">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id27">1</a><span class="fn-bracket">]</span></span>
<p>Note that this table applies only the SCF module,
not to the final convergence criteria for post-HF methods or to methods
that use an alternate starting point, like MCSCF. SAPT computations, too,
set tighter values.</p>
</aside>
<aside class="footnote brackets" id="f2" role="doc-footnote">
<span class="label"><span class="fn-bracket">[</span>2<span class="fn-bracket">]</span></span>
<span class="backrefs">(<a role="doc-backlink" href="#id31">1</a>,<a role="doc-backlink" href="#id36">2</a>)</span>
<p>This applies to properties computed through the <a class="reference internal" href="api/psi4.driver.properties.html#psi4.driver.properties" title="psi4.driver.properties"><code class="xref py py-func docutils literal notranslate"><span class="pre">properties()</span></code></a> function.</p>
</aside>
<aside class="footnote brackets" id="f3" role="doc-footnote">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id29">3</a><span class="fn-bracket">]</span></span>
<p>Post-HF methods that do not rely upon the usual 4-index AO integrals use a
density-fitted SCF reference. That is, for DF-MP2 and SAPT, the default <a class="reference internal" href="autodoc_glossary_options_c.html#term-SCF_TYPE-GLOBALS"><span class="xref std std-term">SCF_TYPE</span></a> is DF.</p>
</aside>
<aside class="footnote brackets" id="f4" role="doc-footnote">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id32">4</a><span class="fn-bracket">]</span></span>
<p>Note that this table applies to the final convergence criteria for
all the post-SCF modules that define a <a class="reference internal" href="autodoc_glossary_options_c.html#term-E_CONVERGENCE-CCENERGY"><span class="xref std std-term">E_CONVERGENCE</span></a> keyword.</p>
</aside>
<aside class="footnote brackets" id="f5" role="doc-footnote">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id33">5</a><span class="fn-bracket">]</span></span>
<p>The E_CONVERGENCE keyword is implemented for most post-SCF modules.
See a list beginning at <a class="reference internal" href="autodoc_glossary_options_c.html#term-E_CONVERGENCE-CCENERGY"><span class="xref std std-term">E_CONVERGENCE</span></a>.</p>
</aside>
<aside class="footnote brackets" id="f6" role="doc-footnote">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id34">6</a><span class="fn-bracket">]</span></span>
<p>The R_CONVERGENCE keyword places a convergence check on an internal
residual error measure and is implemented for several post-SCF
modules (see list beginning at <a class="reference internal" href="autodoc_glossary_options_c.html#term-R_CONVERGENCE-CCENERGY"><span class="xref std std-term">R_CONVERGENCE</span></a>). It is defined
according to the quantum chemical method and so its default value is set
by each module individually.</p>
</aside>
<aside class="footnote brackets" id="f7" role="doc-footnote">
<span class="label"><span class="fn-bracket">[</span>7<span class="fn-bracket">]</span></span>
<span class="backrefs">(<a role="doc-backlink" href="#id28">1</a>,<a role="doc-backlink" href="#id30">2</a>,<a role="doc-backlink" href="#id35">3</a>)</span>
<p>For frequency computations by finite difference of energies,
convergence criteria are tightened further still to 10 for
<a class="reference internal" href="autodoc_glossary_options_c.html#term-E_CONVERGENCE-SCF"><span class="xref std std-term">E_CONVERGENCE</span></a> and <a class="reference internal" href="autodoc_glossary_options_c.html#term-D_CONVERGENCE-SCF"><span class="xref std std-term">D_CONVERGENCE</span></a> for SCF of HF or DFT, 11
for <a class="reference internal" href="autodoc_glossary_options_c.html#term-E_CONVERGENCE-SCF"><span class="xref std std-term">E_CONVERGENCE</span></a> and <a class="reference internal" href="autodoc_glossary_options_c.html#term-D_CONVERGENCE-SCF"><span class="xref std std-term">D_CONVERGENCE</span></a> for SCF of post-HF,
and 10 for E_CONVERGENCE for post-HF of post-HF.</p>
</aside>
</aside>
</section>
<section id="recommendations">
<span id="sec-scfrec"></span><h2>Recommendations<a class="headerlink" href="#recommendations" title="Link to this heading">#</a></h2>
<p>The SCF code is quite flexible and powerful.
We have tried as much as possible to keep the number of options to
a minimum and to allow all options to be used in the presence of all other
options. Below are some rough words of advice about using the SCF code for
practical calculations:</p>
<ul class="simple">
<li><p>For <a class="reference internal" href="autodoc_glossary_options_c.html#term-GUESS-SCF"><span class="xref std std-term">GUESS</span></a>, the <code class="docutils literal notranslate"><span class="pre">SAD</span></code> guess is usually your
friend, even for open-shell systems (at the very least, it gets the right
number of electrons, unlike some other programs). For instance, we have found
that a simple SAD guess is often as good as doing a full SCF in a 3-21G basis
and then performing a cast-up, at a fraction of the cost.  However, SAD and
DOCC/SOCC arrays do not play very well together at the moment.</p></li>
<li><p>For wall time, <code class="docutils literal notranslate"><span class="pre">DF</span></code> may be a factor of ten or more faster than the exact
integral technologies available in <span style="font-family: Optima, sans-serif; text-transform: none;">P<span style="font-size: 82%;">SI</span>4</span>.
Use <code class="docutils literal notranslate"><span class="pre">DF</span></code> unless you need absolute accuracy or do not
have a -JKFIT auxiliary set for your orbital basis/atom type. Then use
<code class="docutils literal notranslate"><span class="pre">DIRECT</span></code>.</p></li>
<li><p>Don’t mess with the DIIS convergence options unless convergence is a problem.
We have optimized the parameters for efficiency over a wide array of system
types.</p></li>
<li><p>Buy a developer a beer!</p></li>
</ul>
<p>The “best-practice” input file for HF is:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">memory</span> <span class="mi">1</span> <span class="n">GB</span>  <span class="c1"># As much as you&#39;ve got, the DF algorithm can use</span>

<span class="n">molecule</span> <span class="p">{</span>
<span class="n">O</span>
<span class="n">H</span> <span class="mi">1</span> <span class="mf">1.0</span>
<span class="n">H</span> <span class="mi">1</span> <span class="mf">1.0</span> <span class="mi">2</span> <span class="mf">104.5</span>
<span class="p">}</span>

<span class="nb">set</span> <span class="p">{</span>
<span class="n">basis</span> <span class="n">cc</span><span class="o">-</span><span class="n">pvdz</span>
<span class="n">scf_type</span> <span class="n">df</span>
<span class="n">guess</span> <span class="n">sad</span>
<span class="n">ints_tolerance</span> <span class="mf">1.0E-10</span>  <span class="c1"># Even this is epically tight, 1.0E-8 is OK</span>
<span class="p">}</span>

<span class="n">energy</span><span class="p">(</span><span class="s1">&#39;scf&#39;</span><span class="p">)</span>
</pre></div>
</div>
</section>
</section>


                </article>
              
              
              
              
              
                <footer class="prev-next-footer">
                  <!-- Previous / next buttons -->
<div class="prev-next-area">
    <a class="left-prev"
       href="notes_c.html"
       title="previous page">
      <i class="fa-solid fa-angle-left"></i>
      <div class="prev-next-info">
        <p class="prev-next-subtitle">previous</p>
        <p class="prev-next-title">Notes on Options</p>
      </div>
    </a>
    <a class="right-next"
       href="dft.html"
       title="next page">
      <div class="prev-next-info">
        <p class="prev-next-subtitle">next</p>
        <p class="prev-next-title">DFT: Density Functional Theory</p>
      </div>
      <i class="fa-solid fa-angle-right"></i>
    </a>
</div>
                </footer>
              
            </div>
            
            
              
                <div class="bd-sidebar-secondary bd-toc"><div class="sidebar-secondary-items sidebar-secondary__inner">

  <div class="sidebar-secondary-item">
  <div class="page-toc tocsection onthispage">
    <i class="fa-solid fa-list"></i> On this page
  </div>
  <nav class="bd-toc-nav page-toc">
    <ul class="visible nav section-nav flex-column">
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#introduction">Introduction</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#theory">Theory</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#minimal-input">Minimal Input</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#spin-symmetry-treatment">Spin/Symmetry Treatment</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#broken-symmetry">Broken Symmetry</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#orthogonalization">Orthogonalization</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#initial-guess">Initial Guess</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#restarting-the-scf">Restarting the SCF</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#convergence-stabilization">Convergence Stabilization</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#eri-algorithms">ERI Algorithms</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#integral-direct-density-fitted-coulomb-construction">Integral-Direct Density-Fitted Coulomb Construction</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#cosx-exchange">COSX Exchange</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#linear-exchange">Linear Exchange</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#second-order-convergence">Second-order Convergence</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#stability-analysis">Stability Analysis</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#effective-core-potentials-ecps">Effective core potentials (ECPs)</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#external-potentials-and-qm-mm">External potentials and QM/MM</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#convergence-and-algorithm-defaults">Convergence and Algorithm Defaults</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#recommendations">Recommendations</a></li>
</ul>
  </nav></div>

  <div class="sidebar-secondary-item">
  <div class="tocsection sourcelink">
    <a href="_sources/scf.rst.txt">
      <i class="fa-solid fa-file-lines"></i> Show Source
    </a>
  </div>
</div>

</div></div>
              
            
          </div>
          <footer class="bd-footer-content">
            
          </footer>
        
      </main>
    </div>
  </div>
  
  <!-- Scripts loaded after <body> so the DOM is not blocked -->
  <script src="_static/scripts/bootstrap.js?digest=ac02cc09edc035673794"></script>
<script src="_static/scripts/pydata-sphinx-theme.js?digest=ac02cc09edc035673794"></script>

  <footer class="bd-footer">
<div class="bd-footer__inner bd-page-width">
  
    <div class="footer-items__start">
      
        <div class="footer-item">
  <p class="copyright">
    
      © Copyright 2007-2023, The Psi4 Project.
      <br/>
    
  </p>
</div>
      
        <div class="footer-item">
  <p class="sphinx-version">
    Created using <a href="https://www.sphinx-doc.org/">Sphinx</a> 7.2.6.
    <br/>
  </p>
</div>
      
    </div>
  
  
  
    <div class="footer-items__end">
      
        <div class="footer-item"><p class="theme-version">
  Built with the <a href="https://pydata-sphinx-theme.readthedocs.io/en/stable/index.html">PyData Sphinx Theme</a> 0.14.1.
</p></div>
      
    </div>
  
</div>

  </footer>
  </body>
</html>