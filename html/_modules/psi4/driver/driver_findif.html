<!-- 
#
# @BEGIN LICENSE
#
# Psi4: an open-source quantum chemistry software package
#
# Copyright (c) 2007-2017 The Psi4 Developers.
#
# The copyrights for code used from other parties are included in
# the corresponding files.
#
# This file is part of Psi4.
#
# Psi4 is free software; you can redistribute it and/or modify
# it under the terms of the GNU Lesser General Public License as published by
# the Free Software Foundation, version 3.
#
# Psi4 is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU Lesser General Public License for more details.
#
# You should have received a copy of the GNU Lesser General Public License along
# with Psi4; if not, write to the Free Software Foundation, Inc.,
# 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
#
# @END LICENSE
# -->






<!DOCTYPE html>

<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>psi4.driver.driver_findif</title>
    <link rel="stylesheet" type="text/css" href="../../../_static/pygments.css" />
    <link rel="stylesheet" type="text/css" href="../../../_static/psi4.css" />
    <link rel="stylesheet" type="text/css" href="../../../_static/graphviz.css" />
    <link rel="stylesheet" type="text/css" href="../../../_static/autodoc_pydantic.css" />
    <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/font-awesome/4.4.0/css/font-awesome.min.css" type="text/css" />
    <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Noticia+Text:400,i,b,bi|Open+Sans:400,i,b,bi|Roboto+Mono:400,i,b,bi&amp;display=swap" type="text/css" />
    
    <script data-url_root="../../../" id="documentation_options" src="../../../_static/documentation_options.js"></script>
    <script src="../../../_static/doctools.js"></script>
    <script src="../../../_static/sphinx_highlight.js"></script>
    <script crossorigin="anonymous" integrity="sha256-Ae2Vz/4ePdIu6ZyI/5ZGsYnb+m0JlOmKPjt6XZ9JJkA=" src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.4/require.min.js"></script>

    
    
     
        <script src="../../../_static/jquery.cookie.js"></script>
    

    
     
        <script src="../../../_static/cloud.base.js"></script>
    

    
     
        <script src="../../../_static/cloud.js"></script>
    

    <link rel="icon" href="../../../_static/favicon-psi4.ico"/>
    <link rel="index" title="Index" href="../../../genindex.html" />
    <link rel="search" title="Search" href="../../../search.html" /> 
        <meta name="viewport" content="width=device-width, initial-scale=1">
  </head><body>
    <div class="relbar-top">
        
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../../genindex.html" title="General Index"
             accesskey="I">Index</a></li>
        <li class="right" >
          <a href="../../../py-modindex.html" title="Python Module Index"
             >modules</a> &nbsp; &nbsp;</li>
        <li class="right" >
          <a href="../../../index.html" title="Table Of Contents"
             accesskey="C"><i class="fa fa-book fa-lg"></i></a> &nbsp; &nbsp;</li>
    <li><a href="http://psicode.org/"><i class="fa fa-home fa-lg"></i></a></li>
    <li><a href="http://github.com/psi4/psi4"><i class="fa fa-github fa-lg"></i></a></li>
    <li><a href="http://forum.psicode.org"><i class="fa fa-comments-o fa-lg"></i></a></li>
    <li><a href="http://github.com/psi4/psi4/edit/master/doc/sphinxman/source/_modules/psi4/driver/driver_findif.rst"><i class="fa fa-pencil fa-lg"></i></a></li>
    <li style="color: #1a4162">&nbsp;&middot;&nbsp;</li>
    <li><a href="http://github.com/psi4/psi4/tree/a0155c3">1.9a1.dev38</a></li>
    <li style="color: #1a4162">&nbsp;&middot;&nbsp;</li>
    <li class="nav-item nav-item-0"><a href="../../../index.html">
        <span style="font-family: Optima, sans-serif;">P<span style="font-size: 82%;">SI</span>4</span>
        </a><i class="fa fa-angle-double-right" style="color: #a2a7b3; text-shadow: none;"></i></li>

          <li class="nav-item nav-item-1"><a href="../../index.html" accesskey="U">Module code</a><i class="fa fa-angle-double-right" style="color: #a2a7b3; text-shadow: none;"></i></li>
        <li class="nav-item nav-item-this"><a href="">psi4.driver.driver_findif</a></li> 
      </ul>
    </div>
    </div>
  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <h1>Source code for psi4.driver.driver_findif</h1><div class="highlight"><pre>
<span></span><span class="c1">#</span>
<span class="c1"># @BEGIN LICENSE</span>
<span class="c1">#</span>
<span class="c1"># Psi4: an open-source quantum chemistry software package</span>
<span class="c1">#</span>
<span class="c1"># Copyright (c) 2007-2023 The Psi4 Developers.</span>
<span class="c1">#</span>
<span class="c1"># The copyrights for code used from other parties are included in</span>
<span class="c1"># the corresponding files.</span>
<span class="c1">#</span>
<span class="c1"># This file is part of Psi4.</span>
<span class="c1">#</span>
<span class="c1"># Psi4 is free software; you can redistribute it and/or modify</span>
<span class="c1"># it under the terms of the GNU Lesser General Public License as published by</span>
<span class="c1"># the Free Software Foundation, version 3.</span>
<span class="c1">#</span>
<span class="c1"># Psi4 is distributed in the hope that it will be useful,</span>
<span class="c1"># but WITHOUT ANY WARRANTY; without even the implied warranty of</span>
<span class="c1"># MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the</span>
<span class="c1"># GNU Lesser General Public License for more details.</span>
<span class="c1">#</span>
<span class="c1"># You should have received a copy of the GNU Lesser General Public License along</span>
<span class="c1"># with Psi4; if not, write to the Free Software Foundation, Inc.,</span>
<span class="c1"># 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.</span>
<span class="c1">#</span>
<span class="c1"># @END LICENSE</span>
<span class="c1">#</span>
<span class="sd">&quot;&quot;&quot;Plan, run, and assemble QC tasks to obtain derivatives by finite difference of lesser derivatives.</span>

<span class="sd">===========</span>
<span class="sd">FINDIF Flow</span>
<span class="sd">===========</span>
<span class="sd">Bullet points are major actions</span>
<span class="sd">Lines of dashes denote function calls</span>
<span class="sd">e/d/dd=dg/g/h := energy, dipole, dipole derivative = dipole gradient, gradient, Hessian</span>

<span class="sd">-----------------------------------</span>
<span class="sd">FiniteDifferenceComputer.__init__()</span>
<span class="sd">-----------------------------------</span>
<span class="sd">* collect findif_stencil_size, findif_step_size from initializer kwargs</span>
<span class="sd">* BaseComputer.__init__()</span>
<span class="sd">* negotiate safety and user wishes on translation and rotation projection</span>

<span class="sd">    gradient_from_energies_geometries()</span>
<span class="sd">    -----------------------------------</span>
<span class="sd">    hessian_from_gradients_geometries()</span>
<span class="sd">    -----------------------------------</span>
<span class="sd">    hessian_from_energies_geometries()</span>
<span class="sd">    ----------------------------------</span>

<span class="sd">        _geom_generator()</span>
<span class="sd">        -----------------</span>

<span class="sd">            _initialize_findif()</span>
<span class="sd">            --------------------</span>
<span class="sd">            * initialize CdSalcs, partition them per irrep, apply user irreps</span>

<span class="sd">        * start the governing dict findifrec with parameters, size, mol</span>
<span class="sd">        * for each irrep, for each relevant salc ...</span>

<span class="sd">            _displace_cart()</span>
<span class="sd">            ----------------</span>
<span class="sd">            * form new geometry by linear combination</span>

<span class="sd">        * ... and collect geometry into a field of findifrec[&quot;displacements&quot;].&lt;label&gt;</span>
<span class="sd">        * for (2, 0) also collect off-diagonal displacements</span>
<span class="sd">        * also collect undisplaced geometry into field reference</span>
<span class="sd">        * return findifrec</span>

<span class="sd">* form AtomicComputers for each displacement, particularly changing mol and driver, and possibly relaxing disp symm</span>
<span class="sd">* form dict task_list with keys findifrec labels and vals AtomicComputers</span>

<span class="sd">--------------------------------------</span>
<span class="sd">FiniteDifferenceComputer.build_tasks()</span>
<span class="sd">--------------------------------------</span>
<span class="sd">* pass</span>

<span class="sd">----------------------------------</span>
<span class="sd">FiniteDifferenceComputer.compute()</span>
<span class="sd">----------------------------------</span>
<span class="sd">* compute() for each job in task list</span>

<span class="sd">------------------------------------------</span>
<span class="sd">FiniteDifferenceComputer.get_psi_results()</span>
<span class="sd">------------------------------------------</span>

<span class="sd">    Computer.get_results()</span>
<span class="sd">    ----------------------</span>

<span class="sd">        Computer._prepare_results()</span>
<span class="sd">        ---------------------------</span>
<span class="sd">        * get_results() for each job in task list</span>
<span class="sd">        * arrange atomicresult data into e/d/g/h fields as available on each of reference and displacements entries</span>

<span class="sd">            assemble_hessian_from_energies()</span>
<span class="sd">            --------------------------------</span>
<span class="sd">            assemble_hessian_from_gradients()</span>
<span class="sd">            ---------------------------------</span>

<span class="sd">                _process_hessian_symmetry_block()</span>
<span class="sd">                ---------------------------------</span>
<span class="sd">                * resymmetrize each H block</span>

<span class="sd">                _process_hessian()</span>
<span class="sd">                ------------------</span>
<span class="sd">                * transform H to Cartesians and unmasswt</span>

<span class="sd">            assemble_gradient_from_energies()</span>
<span class="sd">            ---------------------------------</span>
<span class="sd">            assemble_dipder_from_dipoles()</span>
<span class="sd">            ------------------------------</span>

<span class="sd">            * form DD, G, H from lower derivative points</span>

<span class="sd">        * place as many of DD, G, H as available onto reference entry</span>

<span class="sd">    * pull qcvars off reference job</span>
<span class="sd">    * from reference job, set add&#39;l mol, DD, G, H as available</span>
<span class="sd">    * form model, including detailed dict at atomicresult.extras[&quot;findif_record&quot;]</span>

<span class="sd">* convert result to psi4.core.Matrix</span>

<span class="sd">    _findif_schema_to_wfn()</span>
<span class="sd">    -----------------------</span>
<span class="sd">    * build wfn from findif mol and basis (if singular) and module (if singular)</span>
<span class="sd">    * push qcvars to P::e and wfn</span>

<span class="sd">    gradient_write()</span>
<span class="sd">    ----------------</span>
<span class="sd">    * write .grad file if requested</span>

<span class="sd">    hessian_write()</span>
<span class="sd">    ---------------</span>
<span class="sd">    * write .hess file if requested</span>

<span class="sd">* return dd/g/h and wfn</span>

<span class="sd">&quot;&quot;&quot;</span>

<span class="kn">import</span> <span class="nn">copy</span>
<span class="kn">import</span> <span class="nn">logging</span>
<span class="kn">from</span> <span class="nn">functools</span> <span class="kn">import</span> <span class="n">partial</span>
<span class="kn">from</span> <span class="nn">typing</span> <span class="kn">import</span> <span class="n">Any</span><span class="p">,</span> <span class="n">Callable</span><span class="p">,</span> <span class="n">Dict</span><span class="p">,</span> <span class="n">Iterator</span><span class="p">,</span> <span class="n">List</span><span class="p">,</span> <span class="n">Optional</span><span class="p">,</span> <span class="n">Tuple</span><span class="p">,</span> <span class="n">Union</span><span class="p">,</span> <span class="n">TYPE_CHECKING</span>

<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="k">try</span><span class="p">:</span>
    <span class="kn">from</span> <span class="nn">pydantic.v1</span> <span class="kn">import</span> <span class="n">Field</span><span class="p">,</span> <span class="n">validator</span>
<span class="k">except</span> <span class="ne">ImportError</span><span class="p">:</span>
    <span class="kn">from</span> <span class="nn">pydantic</span> <span class="kn">import</span> <span class="n">Field</span><span class="p">,</span> <span class="n">validator</span>
<span class="kn">from</span> <span class="nn">qcelemental.models</span> <span class="kn">import</span> <span class="n">DriverEnum</span><span class="p">,</span> <span class="n">AtomicResult</span>
<span class="kn">from</span> <span class="nn">qcelemental</span> <span class="kn">import</span> <span class="n">constants</span>

<span class="kn">from</span> <span class="nn">psi4</span> <span class="kn">import</span> <span class="n">core</span>
<span class="kn">from</span> <span class="nn">psi4.driver</span> <span class="kn">import</span> <span class="n">p4util</span><span class="p">,</span> <span class="n">pp</span><span class="p">,</span> <span class="n">qcdb</span><span class="p">,</span> <span class="n">nppp10</span>
<span class="kn">from</span> <span class="nn">psi4.driver.p4util.exceptions</span> <span class="kn">import</span> <span class="n">ValidationError</span>
<span class="kn">from</span> <span class="nn">psi4.driver.task_base</span> <span class="kn">import</span> <span class="n">AtomicComputer</span><span class="p">,</span> <span class="n">BaseComputer</span><span class="p">,</span> <span class="n">EnergyGradientHessianWfnReturn</span>

<span class="k">if</span> <span class="n">TYPE_CHECKING</span><span class="p">:</span>
    <span class="kn">import</span> <span class="nn">qcportal</span>

<span class="n">logger</span> <span class="o">=</span> <span class="n">logging</span><span class="o">.</span><span class="n">getLogger</span><span class="p">(</span><span class="vm">__name__</span><span class="p">)</span>

<span class="c1"># CONVENTIONS:</span>
<span class="c1"># n_ at the start of a variable name is short for &quot;number of.&quot;</span>
<span class="c1"># _pi at the end of a variable name is short for &quot;per irrep.&quot;</span>
<span class="c1"># h is the index of an irrep.</span>


<span class="k">def</span> <span class="nf">_displace_cart</span><span class="p">(</span><span class="n">mass</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">geom</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">salc_list</span><span class="p">:</span> <span class="n">core</span><span class="o">.</span><span class="n">CdSalcList</span><span class="p">,</span> <span class="n">i_m</span><span class="p">:</span> <span class="n">Iterator</span><span class="p">[</span><span class="n">Tuple</span><span class="p">],</span> <span class="n">step_size</span><span class="p">:</span> <span class="nb">float</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Tuple</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="nb">str</span><span class="p">]:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Displace a geometry along the specified displacement SALCs.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    mass</span>
<span class="sd">        (nat, ) masses [u] of atoms of the molecule (const).</span>
<span class="sd">    geom</span>
<span class="sd">        (nat, 3) reference geometry [a0] of the molecule (const).</span>
<span class="sd">    salc_list</span>
<span class="sd">        A list of Cartesian displacement SALCs</span>
<span class="sd">    i_m</span>
<span class="sd">        An iterator containing tuples. Each tuple has the index of a salc in</span>
<span class="sd">        salc_list and the number of steps (positive or negative) to displace</span>
<span class="sd">        the salc at that index.</span>
<span class="sd">    step_size</span>
<span class="sd">        The size of a single &quot;step,&quot; i.e., the stencil size.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    disp_geom</span>
<span class="sd">        (nat, 3) Displaced geometry.</span>
<span class="sd">    label</span>
<span class="sd">        Displacement label for the metadata dictionary.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">label</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">disp_geom</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="n">geom</span><span class="p">)</span>
    <span class="c1"># This for loop and tuple unpacking is why the function can handle</span>
    <span class="c1"># an arbitrary number of SALCs.</span>
    <span class="k">for</span> <span class="n">salc_index</span><span class="p">,</span> <span class="n">disp_steps</span> <span class="ow">in</span> <span class="n">i_m</span><span class="p">:</span>
        <span class="c1"># * Python error if iterate through `salc_list`</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">salc_list</span><span class="p">[</span><span class="n">salc_index</span><span class="p">])):</span>
            <span class="n">component</span> <span class="o">=</span> <span class="n">salc_list</span><span class="p">[</span><span class="n">salc_index</span><span class="p">][</span><span class="n">i</span><span class="p">]</span>
            <span class="n">disp_geom</span><span class="p">[</span><span class="n">component</span><span class="o">.</span><span class="n">atom</span><span class="p">,</span> <span class="n">component</span><span class="o">.</span><span class="n">xyz</span><span class="p">]</span> <span class="o">+=</span> <span class="n">disp_steps</span> <span class="o">*</span> <span class="n">step_size</span> <span class="o">*</span> <span class="n">component</span><span class="o">.</span><span class="n">coef</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">mass</span><span class="p">[</span><span class="n">component</span><span class="o">.</span><span class="n">atom</span><span class="p">])</span>
        <span class="n">label</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">salc_index</span><span class="si">}</span><span class="s2">: </span><span class="si">{</span><span class="n">disp_steps</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

    <span class="c1"># salc_index is in descending order. We want the label in ascending order, so...</span>
    <span class="c1"># ...add the new label part from the left of the string, not the right.</span>
    <span class="n">label</span> <span class="o">=</span> <span class="s1">&#39;, &#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="nb">reversed</span><span class="p">(</span><span class="n">label</span><span class="p">))</span>
    <span class="k">return</span> <span class="n">disp_geom</span><span class="p">,</span> <span class="n">label</span>


<span class="k">def</span> <span class="nf">_initialize_findif</span><span class="p">(</span><span class="n">mol</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="s2">&quot;qcdb.Molecule&quot;</span><span class="p">,</span> <span class="n">core</span><span class="o">.</span><span class="n">Molecule</span><span class="p">],</span>
                       <span class="n">freq_irrep_only</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span>
                       <span class="n">mode</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span>
                       <span class="n">stencil_size</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span>
                       <span class="n">step_size</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span>
                       <span class="n">initialize_string</span><span class="p">:</span> <span class="n">Callable</span><span class="p">,</span>
                       <span class="n">t_project</span><span class="p">:</span> <span class="nb">bool</span><span class="p">,</span>
                       <span class="n">r_project</span><span class="p">:</span> <span class="nb">bool</span><span class="p">,</span>
                       <span class="n">initialize</span><span class="p">:</span> <span class="nb">bool</span><span class="p">,</span>
                       <span class="n">verbose</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">0</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Dict</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Perform initialization tasks needed by all primary functions.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    mol</span>
<span class="sd">        The molecule to displace</span>
<span class="sd">    freq_irrep_only</span>
<span class="sd">        The Cotton ordered irrep to get frequencies for. Choose -1 for all</span>
<span class="sd">        irreps.</span>
<span class="sd">    mode</span>
<span class="sd">        {&quot;1_0&quot;, &quot;2_0&quot;, &quot;2_1&quot;}</span>
<span class="sd">         The first number specifies the derivative level determined from</span>
<span class="sd">         displacements, and the second number is the level determined at.</span>
<span class="sd">    stencil_size</span>
<span class="sd">        {3, 5}</span>
<span class="sd">        Number of points to evaluate for each displacement basis vector inclusive of central reference geometry.</span>
<span class="sd">    step_size</span>
<span class="sd">        [a0]</span>
<span class="sd">    initialize_string</span>
<span class="sd">         A function that returns the string to print to show the caller was entered.</span>
<span class="sd">         The string is both caller-specific and dependent on values determined</span>
<span class="sd">         in this function.</span>
<span class="sd">    initialize</span>
<span class="sd">        For printing, whether call is from generator or assembly stages.</span>
<span class="sd">    verbose</span>
<span class="sd">         Set to 0 to silence extra print information, regardless of the print level.</span>
<span class="sd">         Used so the information is printed only during geometry generation, and not</span>
<span class="sd">         during the derivative computation as well.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    data</span>
<span class="sd">        Miscellaneous information required by callers.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">info</span> <span class="o">=</span> <span class="s2">&quot;&quot;&quot;</span>
<span class="s2">         ----------------------------------------------------------</span>
<span class="s2">                                   FINDIF</span>
<span class="s2">                     R. A. King and Jonathon Misiewicz</span>
<span class="s2">         ----------------------------------------------------------</span>

<span class="s2">&quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">initialize</span><span class="p">:</span>
        <span class="n">core</span><span class="o">.</span><span class="n">print_out</span><span class="p">(</span><span class="n">info</span><span class="p">)</span>
        <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="n">info</span><span class="p">)</span>

    <span class="n">print_lvl</span> <span class="o">=</span> <span class="n">core</span><span class="o">.</span><span class="n">get_option</span><span class="p">(</span><span class="s2">&quot;FINDIF&quot;</span><span class="p">,</span> <span class="s2">&quot;PRINT&quot;</span><span class="p">)</span>

    <span class="n">data</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;print_lvl&quot;</span><span class="p">:</span> <span class="n">print_lvl</span><span class="p">,</span> <span class="s2">&quot;stencil_size&quot;</span><span class="p">:</span> <span class="n">stencil_size</span><span class="p">,</span> <span class="s2">&quot;step_size&quot;</span><span class="p">:</span> <span class="n">step_size</span><span class="p">}</span>

    <span class="k">if</span> <span class="n">print_lvl</span><span class="p">:</span>
        <span class="n">info</span> <span class="o">=</span> <span class="n">initialize_string</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
        <span class="n">core</span><span class="o">.</span><span class="n">print_out</span><span class="p">(</span><span class="n">info</span><span class="p">)</span>
        <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="n">info</span><span class="p">)</span>

    <span class="c1"># Get settings for CdSalcList, then get the CdSalcList.</span>
    <span class="n">method_allowed_irreps</span> <span class="o">=</span> <span class="mh">0x1</span> <span class="k">if</span> <span class="n">mode</span> <span class="o">==</span> <span class="s2">&quot;1_0&quot;</span> <span class="k">else</span> <span class="mh">0xFF</span>
    <span class="c1"># core.get_option returns an int, but CdSalcList expect a bool, so re-cast</span>
    <span class="n">salc_list</span> <span class="o">=</span> <span class="n">core</span><span class="o">.</span><span class="n">CdSalcList</span><span class="p">(</span><span class="n">mol</span><span class="p">,</span> <span class="n">method_allowed_irreps</span><span class="p">,</span> <span class="n">t_project</span><span class="p">,</span> <span class="n">r_project</span><span class="p">)</span>

    <span class="n">n_atom</span> <span class="o">=</span> <span class="n">mol</span><span class="o">.</span><span class="n">natom</span><span class="p">()</span>
    <span class="n">n_irrep</span> <span class="o">=</span> <span class="n">salc_list</span><span class="o">.</span><span class="n">nirrep</span><span class="p">()</span>
    <span class="n">n_salc</span> <span class="o">=</span> <span class="n">salc_list</span><span class="o">.</span><span class="n">ncd</span><span class="p">()</span>

    <span class="k">if</span> <span class="n">print_lvl</span> <span class="ow">and</span> <span class="n">verbose</span><span class="p">:</span>
        <span class="n">info</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;    Number of atoms is </span><span class="si">{</span><span class="n">n_atom</span><span class="si">}</span><span class="s2">.</span><span class="se">\n</span><span class="s2">&quot;</span>
        <span class="k">if</span> <span class="n">method_allowed_irreps</span> <span class="o">!=</span> <span class="mh">0x1</span><span class="p">:</span>
            <span class="n">info</span> <span class="o">+=</span> <span class="sa">f</span><span class="s2">&quot;    Number of irreps is </span><span class="si">{</span><span class="n">n_irrep</span><span class="si">}</span><span class="s2">.</span><span class="se">\n</span><span class="s2">&quot;</span>
        <span class="n">info</span> <span class="o">+=</span> <span class="s2">&quot;    Number of </span><span class="si">{!s}</span><span class="s2">SALCs is </span><span class="si">{:d}</span><span class="s2">.</span><span class="se">\n</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="s2">&quot;&quot;</span> <span class="k">if</span> <span class="n">method_allowed_irreps</span> <span class="o">!=</span> <span class="mh">0x1</span> <span class="k">else</span> <span class="s2">&quot;symmetric &quot;</span><span class="p">,</span>
                                                            <span class="n">n_salc</span><span class="p">)</span>
        <span class="n">info</span> <span class="o">+=</span> <span class="sa">f</span><span class="s2">&quot;    Translations projected? </span><span class="si">{</span><span class="n">t_project</span><span class="si">:</span><span class="s2">d</span><span class="si">}</span><span class="s2">. Rotations projected? </span><span class="si">{</span><span class="n">r_project</span><span class="si">:</span><span class="s2">d</span><span class="si">}</span><span class="s2">.</span><span class="se">\n</span><span class="s2">&quot;</span>
        <span class="n">core</span><span class="o">.</span><span class="n">print_out</span><span class="p">(</span><span class="n">info</span><span class="p">)</span>
        <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="n">info</span><span class="p">)</span>

    <span class="c1"># TODO: Replace with a generator from a stencil to a set of points.</span>
    <span class="c1"># Diagonal displacements differ between the totally symmetric irrep, compared to all others.</span>
    <span class="c1"># Off-diagonal displacements are the same for both.</span>
    <span class="n">pts_dict</span> <span class="o">=</span> <span class="p">{</span>
        <span class="mi">3</span><span class="p">:</span> <span class="p">{</span>
            <span class="s2">&quot;sym_irr&quot;</span><span class="p">:</span> <span class="p">((</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="p">),</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="p">)),</span>
            <span class="s2">&quot;asym_irr&quot;</span><span class="p">:</span> <span class="p">((</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="p">),</span> <span class="p">),</span>
            <span class="s2">&quot;off&quot;</span><span class="p">:</span> <span class="p">((</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span> <span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">))</span>
        <span class="p">},</span>
        <span class="mi">5</span><span class="p">:</span> <span class="p">{</span>
            <span class="s2">&quot;sym_irr&quot;</span><span class="p">:</span> <span class="p">((</span><span class="o">-</span><span class="mi">2</span><span class="p">,</span> <span class="p">),</span> <span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="p">),</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="p">),</span> <span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="p">)),</span>
            <span class="s2">&quot;asym_irr&quot;</span><span class="p">:</span> <span class="p">((</span><span class="o">-</span><span class="mi">2</span><span class="p">,</span> <span class="p">),</span> <span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="p">)),</span>
            <span class="s2">&quot;off&quot;</span><span class="p">:</span> <span class="p">((</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">2</span><span class="p">),</span> <span class="p">(</span><span class="o">-</span><span class="mi">2</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">),</span> <span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">),</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">),</span> <span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span> <span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">))</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="k">try</span><span class="p">:</span>
        <span class="n">disps</span> <span class="o">=</span> <span class="n">pts_dict</span><span class="p">[</span><span class="n">stencil_size</span><span class="p">]</span>
    <span class="k">except</span> <span class="ne">KeyError</span><span class="p">:</span>
        <span class="k">raise</span> <span class="n">ValidationError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;FINDIF: Number of points (</span><span class="si">{</span><span class="n">stencil_size</span><span class="si">}</span><span class="s2">) not among </span><span class="si">{</span><span class="n">pts_dict</span><span class="o">.</span><span class="n">keys</span><span class="p">()</span><span class="si">}</span><span class="s2">!&quot;</span><span class="p">)</span>

    <span class="c1"># Convention: x_pi means x_per_irrep. The ith element is x for irrep i, with Cotton ordering.</span>
    <span class="n">salc_indices_pi</span> <span class="o">=</span> <span class="p">[[]</span> <span class="k">for</span> <span class="n">h</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_irrep</span><span class="p">)]</span>

    <span class="c1"># Validate that we have an irrep matching the user-specified irrep, if any.</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="n">salc_indices_pi</span><span class="p">[</span><span class="n">freq_irrep_only</span><span class="p">]</span>
    <span class="k">except</span> <span class="p">(</span><span class="ne">TypeError</span><span class="p">,</span> <span class="ne">IndexError</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">freq_irrep_only</span> <span class="o">!=</span> <span class="o">-</span><span class="mi">1</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">ValidationError</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;FINDIF: 0-indexed Irrep value (</span><span class="si">{</span><span class="n">freq_irrep_only</span><span class="si">}</span><span class="s2">) not in valid range: &lt;</span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">salc_indices_pi</span><span class="p">)</span><span class="si">}</span><span class="s2">.&quot;</span><span class="p">)</span>

    <span class="c1"># Populate salc_indices_pi for all irreps.</span>
    <span class="c1"># * Python error if iterate through `salc_list`</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">salc_list</span><span class="p">)):</span>
        <span class="n">salc_indices_pi</span><span class="p">[</span><span class="n">salc_list</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">irrep_index</span><span class="p">()]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>

    <span class="c1"># If the method allows more than one irrep, print how the irreps partition the SALCS.</span>
    <span class="k">if</span> <span class="n">print_lvl</span> <span class="ow">and</span> <span class="n">method_allowed_irreps</span> <span class="o">!=</span> <span class="mh">0x1</span> <span class="ow">and</span> <span class="n">verbose</span><span class="p">:</span>
        <span class="n">info</span> <span class="o">=</span> <span class="s2">&quot;    Index of SALCs per irrep:</span><span class="se">\n</span><span class="s2">&quot;</span>
        <span class="k">for</span> <span class="n">h</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_irrep</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">print_lvl</span> <span class="o">&gt;</span> <span class="mi">1</span> <span class="ow">or</span> <span class="n">freq_irrep_only</span> <span class="ow">in</span> <span class="p">{</span><span class="n">h</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">}:</span>
                <span class="n">tmp</span> <span class="o">=</span> <span class="p">(</span><span class="s2">&quot; </span><span class="si">{:d}</span><span class="s2"> &quot;</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="n">salc_indices_pi</span><span class="p">[</span><span class="n">h</span><span class="p">]))</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="o">*</span><span class="n">salc_indices_pi</span><span class="p">[</span><span class="n">h</span><span class="p">])</span>
                <span class="n">info</span> <span class="o">+=</span> <span class="s2">&quot;      </span><span class="si">{:d}</span><span class="s2"> : &quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">h</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">+</span> <span class="n">tmp</span> <span class="o">+</span> <span class="s2">&quot;</span><span class="se">\n</span><span class="s2">&quot;</span>
        <span class="n">info</span> <span class="o">+=</span> <span class="s2">&quot;    Number of SALCs per irrep:</span><span class="se">\n</span><span class="s2">&quot;</span>
        <span class="k">for</span> <span class="n">h</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_irrep</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">print_lvl</span> <span class="o">&gt;</span> <span class="mi">1</span> <span class="ow">or</span> <span class="n">freq_irrep_only</span> <span class="ow">in</span> <span class="p">{</span><span class="n">h</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">}:</span>
                <span class="n">info</span> <span class="o">+=</span> <span class="s2">&quot;      Irrep </span><span class="si">{:d}</span><span class="s2">: </span><span class="si">{:d}</span><span class="se">\n</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">h</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">salc_indices_pi</span><span class="p">[</span><span class="n">h</span><span class="p">]))</span>
        <span class="n">core</span><span class="o">.</span><span class="n">print_out</span><span class="p">(</span><span class="n">info</span><span class="p">)</span>
        <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="n">info</span><span class="p">)</span>

    <span class="c1"># Now that we&#39;ve printed the SALCs, clear any that are not of user-specified symmetry.</span>
    <span class="k">if</span> <span class="n">freq_irrep_only</span> <span class="o">!=</span> <span class="o">-</span><span class="mi">1</span><span class="p">:</span>
        <span class="k">for</span> <span class="n">h</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_irrep</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">h</span> <span class="o">!=</span> <span class="n">freq_irrep_only</span><span class="p">:</span>
                <span class="n">salc_indices_pi</span><span class="p">[</span><span class="n">h</span><span class="p">]</span><span class="o">.</span><span class="n">clear</span><span class="p">()</span>

    <span class="n">n_disp_pi</span> <span class="o">=</span> <span class="p">[]</span>

    <span class="k">for</span> <span class="n">irrep</span><span class="p">,</span> <span class="n">indices</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">salc_indices_pi</span><span class="p">):</span>
        <span class="n">n_disp</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">indices</span><span class="p">)</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="n">disps</span><span class="p">[</span><span class="s2">&quot;asym_irr&quot;</span> <span class="k">if</span> <span class="n">irrep</span> <span class="o">!=</span> <span class="mi">0</span> <span class="k">else</span> <span class="s2">&quot;sym_irr&quot;</span><span class="p">])</span>
        <span class="k">if</span> <span class="n">mode</span> <span class="o">==</span> <span class="s2">&quot;2_0&quot;</span><span class="p">:</span>
            <span class="c1"># Either len(indices) or len(indices)-1 is even, so dividing by two is safe.</span>
            <span class="n">n_disp</span> <span class="o">+=</span> <span class="nb">len</span><span class="p">(</span><span class="n">indices</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">indices</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">//</span> <span class="mi">2</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="n">disps</span><span class="p">[</span><span class="s2">&quot;off&quot;</span><span class="p">])</span>
        <span class="n">n_disp_pi</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">n_disp</span><span class="p">)</span>

    <span class="c1"># Let&#39;s print out the number of geometries, the displacement multiplicity, and the CdSALCs!</span>
    <span class="k">if</span> <span class="n">print_lvl</span> <span class="ow">and</span> <span class="n">verbose</span><span class="p">:</span>
        <span class="n">info</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;    Number of geometries (including reference) is </span><span class="si">{</span><span class="nb">sum</span><span class="p">(</span><span class="n">n_disp_pi</span><span class="p">)</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="si">}</span><span class="s2">.</span><span class="se">\n</span><span class="s2">&quot;</span>
        <span class="k">if</span> <span class="n">method_allowed_irreps</span> <span class="o">!=</span> <span class="mh">0x1</span><span class="p">:</span>
            <span class="n">info</span> <span class="o">+=</span> <span class="s2">&quot;    Number of displacements per irrep:</span><span class="se">\n</span><span class="s2">&quot;</span>
            <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">ndisp</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">n_disp_pi</span><span class="p">,</span> <span class="n">start</span><span class="o">=</span><span class="mi">1</span><span class="p">):</span>
                <span class="n">info</span> <span class="o">+=</span> <span class="sa">f</span><span class="s2">&quot;      Irrep </span><span class="si">{</span><span class="n">i</span><span class="si">}</span><span class="s2">: </span><span class="si">{</span><span class="n">ndisp</span><span class="si">}</span><span class="se">\n</span><span class="s2">&quot;</span>
        <span class="n">core</span><span class="o">.</span><span class="n">print_out</span><span class="p">(</span><span class="n">info</span><span class="p">)</span>
        <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="n">info</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">print_lvl</span> <span class="o">&gt;</span> <span class="mi">1</span> <span class="ow">and</span> <span class="n">verbose</span><span class="p">:</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">salc_list</span><span class="p">)):</span>
            <span class="n">salc_list</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">print_out</span><span class="p">()</span>

    <span class="n">data</span><span class="o">.</span><span class="n">update</span><span class="p">({</span>
        <span class="s2">&quot;n_disp_pi&quot;</span><span class="p">:</span> <span class="n">n_disp_pi</span><span class="p">,</span>
        <span class="s2">&quot;n_irrep&quot;</span><span class="p">:</span> <span class="n">n_irrep</span><span class="p">,</span>
        <span class="s2">&quot;n_salc&quot;</span><span class="p">:</span> <span class="n">n_salc</span><span class="p">,</span>
        <span class="s2">&quot;n_atom&quot;</span><span class="p">:</span> <span class="n">n_atom</span><span class="p">,</span>
        <span class="s2">&quot;salc_list&quot;</span><span class="p">:</span> <span class="n">salc_list</span><span class="p">,</span>
        <span class="s2">&quot;salc_indices_pi&quot;</span><span class="p">:</span> <span class="n">salc_indices_pi</span><span class="p">,</span>
        <span class="s2">&quot;disps&quot;</span><span class="p">:</span> <span class="n">disps</span><span class="p">,</span>
        <span class="s2">&quot;project_translations&quot;</span><span class="p">:</span> <span class="n">t_project</span><span class="p">,</span>
        <span class="s2">&quot;project_rotations&quot;</span><span class="p">:</span> <span class="n">r_project</span>
    <span class="p">})</span>

    <span class="k">return</span> <span class="n">data</span>


<span class="k">def</span> <span class="nf">_geom_generator</span><span class="p">(</span><span class="n">mol</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="s2">&quot;qcdb.Molecule&quot;</span><span class="p">,</span> <span class="n">core</span><span class="o">.</span><span class="n">Molecule</span><span class="p">],</span> <span class="n">freq_irrep_only</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">mode</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span> <span class="n">t_project</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span> <span class="n">r_project</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span> <span class="n">stencil_size</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">3</span><span class="p">,</span> <span class="n">step_size</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">0.005</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Dict</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Generate geometries for the specified molecule and derivative levels.</span>
<span class="sd">    You probably want to instead use one of the convenience functions:</span>
<span class="sd">    gradient_from_energies_geometries, hessian_from_energies_geometries,</span>
<span class="sd">    hessian_from_gradients_geometries.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    mol</span>
<span class="sd">        The molecule on which to perform a finite difference calculation.</span>
<span class="sd">    freq_irrep_only</span>
<span class="sd">        The Cotton ordered irrep to get frequencies for. Choose -1 for all</span>
<span class="sd">        irreps. Irrelevant for &quot;1_0&quot;.</span>
<span class="sd">    mode</span>
<span class="sd">        {&quot;1_0&quot;, &quot;2_0&quot;, &quot;2_1&quot;}</span>
<span class="sd">        The first number specifies the targeted derivative level. The</span>
<span class="sd">        second number is the compute derivative level. E.g., &quot;2_0&quot;</span>
<span class="sd">        is hessian from energies.</span>
<span class="sd">    stencil_size</span>
<span class="sd">        {3, 5}</span>
<span class="sd">        Number of points to evaluate for each displacement basis vector inclusive of central reference geometry.</span>
<span class="sd">    step_size</span>
<span class="sd">        Displacement size [a0].</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    findifrec</span>
<span class="sd">        Dictionary of finite difference data, specified below.</span>
<span class="sd">        The dictionary makes findifrec _extensible_. If you need a new field</span>
<span class="sd">        in the record, just add it.</span>
<span class="sd">        All fields should be present at all times, with two exceptions:</span>
<span class="sd">            1. Fields for computed quantities will not be available until</span>
<span class="sd">               after they are computed.</span>
<span class="sd">            2. Displacement specific overrides for globals will not be</span>
<span class="sd">               available unless the user specified the overrides.</span>
<span class="sd">               (Such overrides are not implemented at time of writing. An example</span>
<span class="sd">               is giving a displacement its own step dict.)</span>

<span class="sd">    step : dict</span>
<span class="sd">        A descriptor for the finite difference step.</span>
<span class="sd">        In future, this can be overriden by step fields for individual displacements.</span>

<span class="sd">        units : {&#39;Bohr&#39;}</span>
<span class="sd">            The units for the displacement. The code currently assumes &quot;bohr,&quot; per MolSSI standards.</span>
<span class="sd">        size : float</span>
<span class="sd">            The step size for the displacement.</span>

<span class="sd">    stencil_size : {3, 5}</span>
<span class="sd">        Number of points to evaluate at for each displacement basis vector. Count</span>
<span class="sd">        includes the central reference point.</span>

<span class="sd">    displacement_space : {&#39;CdSalc&#39;}</span>
<span class="sd">        A string specifying the vector space in which displacements are performed.</span>
<span class="sd">        Currently, only CdSalc is supported.</span>

<span class="sd">    project_translations : bool</span>
<span class="sd">        Whether translations are to be projected out of the displacements.</span>

<span class="sd">    project_rotations : bool</span>
<span class="sd">        Whether rotations are to be projected out of the displacements.</span>

<span class="sd">    molecule : dict</span>
<span class="sd">        The reference molecule, in MolSSI schema. See</span>
<span class="sd">        https://molssi-qc-schema.readthedocs.io/en/latest/auto_topology.html</span>

<span class="sd">    displacements : dict</span>
<span class="sd">        A dictionary mapping labels specifying the displacement to data about</span>
<span class="sd">        the geometry. Labels are of the form &quot;A: a, B: b&quot; where A and B index the</span>
<span class="sd">        basis vector in displacement space and A &lt; B, and a and b index the step</span>
<span class="sd">        magnitude. For instance, &quot;0: 1, 1: -1&quot; specifies displacing +1 in</span>
<span class="sd">        displacement vector 0 and -1 in displacement vector 1. &quot;1: -1, 0: 1&quot; is</span>
<span class="sd">        forbidden for breaking ordering. Generalizes to arbitrary numbers of</span>
<span class="sd">        simultaneous displacements in the obvious way.</span>

<span class="sd">        The possible geometry data is as follows:</span>

<span class="sd">        geometry: list of floats</span>
<span class="sd">            (3 * nat) The molecular geometry as a flat list in bohr. All coordinates</span>
<span class="sd">            are given for one atom before proceeding to the next atom.</span>

<span class="sd">        energy: int</span>
<span class="sd">            The last computed electronic energy at the geometry.</span>

<span class="sd">        gradient: list of floats</span>
<span class="sd">            (3 * nat) The last computed gradient of energy with respect to changes in</span>
<span class="sd">            geometry at the geometry, as a flat list. All coordinates are given for</span>
<span class="sd">            displacing one atom before proceeding to the next atom.</span>

<span class="sd">    reference : dict</span>
<span class="sd">         A geometry data dict, as described above, for the reference geometry.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">msg_dict</span> <span class="o">=</span> <span class="p">{</span>
        <span class="s2">&quot;1_0&quot;</span><span class="p">:</span>
        <span class="s2">&quot;energies to determine gradients&quot;</span><span class="p">,</span>
        <span class="s2">&quot;2_1&quot;</span><span class="p">:</span>
        <span class="s2">&quot;gradients to determine vibrational frequencies and </span><span class="se">\n</span><span class="s2">&quot;</span>
        <span class="s2">&quot;  normal modes. Resulting frequencies are only valid at stationary points&quot;</span><span class="p">,</span>
        <span class="s2">&quot;2_0&quot;</span><span class="p">:</span>
        <span class="s2">&quot;gradients to determine vibrational frequencies and </span><span class="se">\n</span><span class="s2">&quot;</span>
        <span class="s2">&quot;  normal modes. Resulting frequencies are only valid at stationary points&quot;</span>
    <span class="p">}</span>

    <span class="k">try</span><span class="p">:</span>
        <span class="n">print_msg</span> <span class="o">=</span> <span class="n">msg_dict</span><span class="p">[</span><span class="n">mode</span><span class="p">]</span>
    <span class="k">except</span> <span class="ne">KeyError</span><span class="p">:</span>
        <span class="k">raise</span> <span class="n">ValidationError</span><span class="p">(</span><span class="s2">&quot;FINDIF: Mode </span><span class="si">{}</span><span class="s2"> not recognized.&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">mode</span><span class="p">))</span>

    <span class="k">def</span> <span class="nf">init_string</span><span class="p">(</span><span class="n">data</span><span class="p">):</span>
        <span class="k">return</span> <span class="sa">f</span><span class="s2">&quot;&quot;&quot;  Using finite-differences of </span><span class="si">{</span><span class="n">print_msg</span><span class="si">}</span><span class="s2">.</span>
<span class="s2">    Generating geometries for use with </span><span class="si">{</span><span class="n">data</span><span class="p">[</span><span class="s2">&quot;stencil_size&quot;</span><span class="p">]</span><span class="si">}</span><span class="s2">-point formula.</span>
<span class="s2">    Displacement size will be </span><span class="si">{</span><span class="n">data</span><span class="p">[</span><span class="s2">&quot;step_size&quot;</span><span class="p">]</span><span class="si">:</span><span class="s2">6.2e</span><span class="si">}</span><span class="s2">.</span><span class="se">\n</span><span class="s2">&quot;&quot;&quot;</span>

    <span class="c1"># Genuine support for qcdb molecules would be nice. But that requires qcdb CdSalc tech.</span>
    <span class="c1"># Until then, silently swap the qcdb molecule out for a psi4.core.Molecule.</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">mol</span><span class="p">,</span> <span class="n">qcdb</span><span class="o">.</span><span class="n">Molecule</span><span class="p">):</span>
        <span class="n">mol</span> <span class="o">=</span> <span class="n">core</span><span class="o">.</span><span class="n">Molecule</span><span class="o">.</span><span class="n">from_dict</span><span class="p">(</span><span class="n">mol</span><span class="o">.</span><span class="n">to_dict</span><span class="p">())</span>

    <span class="n">data</span> <span class="o">=</span> <span class="n">_initialize_findif</span><span class="p">(</span><span class="n">mol</span><span class="p">,</span> <span class="n">freq_irrep_only</span><span class="p">,</span> <span class="n">mode</span><span class="p">,</span> <span class="n">stencil_size</span><span class="p">,</span> <span class="n">step_size</span><span class="p">,</span> <span class="n">init_string</span><span class="p">,</span> <span class="n">t_project</span><span class="p">,</span> <span class="n">r_project</span><span class="p">,</span>
                              <span class="kc">True</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>

    <span class="c1"># We can finally start generating displacements.</span>
    <span class="n">ref_geom</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">mol</span><span class="o">.</span><span class="n">geometry</span><span class="p">())</span>

    <span class="c1"># Now we generate the metadata...</span>
    <span class="n">findifrec</span> <span class="o">=</span> <span class="p">{</span>
        <span class="s2">&quot;step&quot;</span><span class="p">:</span> <span class="p">{</span>
            <span class="s2">&quot;units&quot;</span><span class="p">:</span> <span class="s2">&quot;bohr&quot;</span><span class="p">,</span>
            <span class="s2">&quot;size&quot;</span><span class="p">:</span> <span class="n">data</span><span class="p">[</span><span class="s2">&quot;step_size&quot;</span><span class="p">]</span>
        <span class="p">},</span>
        <span class="s2">&quot;stencil_size&quot;</span><span class="p">:</span> <span class="n">data</span><span class="p">[</span><span class="s2">&quot;stencil_size&quot;</span><span class="p">],</span>
        <span class="s2">&quot;displacement_space&quot;</span><span class="p">:</span> <span class="s2">&quot;CdSALC&quot;</span><span class="p">,</span>
        <span class="s2">&quot;project_translations&quot;</span><span class="p">:</span> <span class="n">data</span><span class="p">[</span><span class="s2">&quot;project_translations&quot;</span><span class="p">],</span>
        <span class="s2">&quot;project_rotations&quot;</span><span class="p">:</span> <span class="n">data</span><span class="p">[</span><span class="s2">&quot;project_rotations&quot;</span><span class="p">],</span>
        <span class="s2">&quot;molecule&quot;</span><span class="p">:</span> <span class="n">mol</span><span class="o">.</span><span class="n">to_schema</span><span class="p">(</span><span class="n">dtype</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">units</span><span class="o">=</span><span class="s1">&#39;Bohr&#39;</span><span class="p">),</span>
        <span class="s2">&quot;displacements&quot;</span><span class="p">:</span> <span class="p">{},</span>
        <span class="s2">&quot;reference&quot;</span><span class="p">:</span> <span class="p">{}</span>
    <span class="p">}</span>

    <span class="k">def</span> <span class="nf">append_geoms</span><span class="p">(</span><span class="n">indices</span><span class="p">,</span> <span class="n">steps</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Given a list of indices and a list of steps to displace each, append the corresponding geometry to the list.&quot;&quot;&quot;</span>

        <span class="c1"># Next, to make this salc/magnitude composite.</span>
        <span class="n">disp_geom</span><span class="p">,</span> <span class="n">label</span> <span class="o">=</span> <span class="n">_displace_cart</span><span class="p">(</span><span class="n">findifrec</span><span class="p">[</span><span class="s1">&#39;molecule&#39;</span><span class="p">][</span><span class="s1">&#39;masses&#39;</span><span class="p">],</span> <span class="n">ref_geom</span><span class="p">,</span> <span class="n">data</span><span class="p">[</span><span class="s2">&quot;salc_list&quot;</span><span class="p">],</span>
                                          <span class="nb">zip</span><span class="p">(</span><span class="n">indices</span><span class="p">,</span> <span class="n">steps</span><span class="p">),</span> <span class="n">data</span><span class="p">[</span><span class="s2">&quot;step_size&quot;</span><span class="p">])</span>
        <span class="k">if</span> <span class="n">data</span><span class="p">[</span><span class="s2">&quot;print_lvl&quot;</span><span class="p">]</span> <span class="o">&gt;</span> <span class="mi">2</span><span class="p">:</span>
            <span class="n">info</span> <span class="o">=</span> <span class="s2">&quot;</span><span class="se">\n</span><span class="s2">Displacement &#39;</span><span class="si">{}</span><span class="s2">&#39;</span><span class="se">\n</span><span class="si">{}</span><span class="se">\n</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">label</span><span class="p">,</span> <span class="n">nppp10</span><span class="p">(</span><span class="n">disp_geom</span><span class="p">))</span>
            <span class="n">core</span><span class="o">.</span><span class="n">print_out</span><span class="p">(</span><span class="n">info</span><span class="p">)</span>
            <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="n">info</span><span class="p">)</span>
        <span class="n">findifrec</span><span class="p">[</span><span class="s2">&quot;displacements&quot;</span><span class="p">][</span><span class="n">label</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;geometry&quot;</span><span class="p">:</span> <span class="n">disp_geom</span><span class="p">}</span>

    <span class="k">for</span> <span class="n">h</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="s2">&quot;n_irrep&quot;</span><span class="p">]):</span>
        <span class="n">active_indices</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="s2">&quot;salc_indices_pi&quot;</span><span class="p">][</span><span class="n">h</span><span class="p">]</span>

        <span class="k">for</span> <span class="n">index</span> <span class="ow">in</span> <span class="n">active_indices</span><span class="p">:</span>
            <span class="c1"># Displace along the diagonal.</span>
            <span class="c1"># Remember that the totally symmetric irrep has special displacements.</span>
            <span class="k">for</span> <span class="n">val</span> <span class="ow">in</span> <span class="n">data</span><span class="p">[</span><span class="s2">&quot;disps&quot;</span><span class="p">][</span><span class="s2">&quot;sym_irr&quot;</span> <span class="k">if</span> <span class="n">h</span> <span class="o">==</span> <span class="mi">0</span> <span class="k">else</span> <span class="s2">&quot;asym_irr&quot;</span><span class="p">]:</span>
                <span class="n">append_geoms</span><span class="p">((</span><span class="n">index</span><span class="p">,</span> <span class="p">),</span> <span class="n">val</span><span class="p">)</span>

        <span class="c1"># Hessian from energies? We have off-diagonal displacements to worry about.</span>
        <span class="k">if</span> <span class="n">mode</span> <span class="o">==</span> <span class="s2">&quot;2_0&quot;</span><span class="p">:</span>
            <span class="c1"># i indexes SALC indices of the current irrep.</span>
            <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">index</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">active_indices</span><span class="p">):</span>
                <span class="k">for</span> <span class="n">index2</span> <span class="ow">in</span> <span class="n">active_indices</span><span class="p">[:</span><span class="n">i</span><span class="p">]:</span>
                    <span class="k">for</span> <span class="n">val</span> <span class="ow">in</span> <span class="n">data</span><span class="p">[</span><span class="s2">&quot;disps&quot;</span><span class="p">][</span><span class="s2">&quot;off&quot;</span><span class="p">]:</span>
                        <span class="n">append_geoms</span><span class="p">((</span><span class="n">index</span><span class="p">,</span> <span class="n">index2</span><span class="p">),</span> <span class="n">val</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">data</span><span class="p">[</span><span class="s2">&quot;print_lvl&quot;</span><span class="p">]</span> <span class="o">&gt;</span> <span class="mi">2</span><span class="p">:</span>
        <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">Reference</span><span class="se">\n</span><span class="si">{}</span><span class="se">\n</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">nppp10</span><span class="p">(</span><span class="n">ref_geom</span><span class="p">)))</span>
    <span class="n">findifrec</span><span class="p">[</span><span class="s2">&quot;reference&quot;</span><span class="p">][</span><span class="s2">&quot;geometry&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">ref_geom</span>

    <span class="k">if</span> <span class="n">data</span><span class="p">[</span><span class="s2">&quot;print_lvl&quot;</span><span class="p">]</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
        <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">-------------------------------------------------------------&quot;</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">findifrec</span>


<span class="n">_der_from_lesser_docstring</span> <span class="o">=</span> <span class="s2">&quot;&quot;&quot;</span>
<span class="s2">    Parameters</span>
<span class="s2">    ----------</span>
<span class="s2">    mol</span>
<span class="s2">        The molecule on which to perform a finite difference calculation.</span>
<span class="s2">    freq_irrep_only</span>
<span class="s2">        The Cotton ordered irrep to get frequencies for. Choose -1 for all</span>
<span class="s2">        irreps. Irrelevant for &quot;1_0&quot;.</span>
<span class="s2">    stencil_size</span>
<span class="s2">        {3, 5}</span>
<span class="s2">        Number of points to evaluate for each displacement basis vector inclusive of central reference geometry.</span>
<span class="s2">    step_size</span>
<span class="s2">        Displacement size [a0].</span>

<span class="s2">    Returns</span>
<span class="s2">    -------</span>
<span class="s2">    findifrec : dict</span>
<span class="s2">        Dictionary of finite difference data, specified in _geom_generator docstring.</span>

<span class="s2">&quot;&quot;&quot;</span>


<span class="n">gradient_from_energies_geometries</span> <span class="o">=</span> <span class="n">partial</span><span class="p">(</span><span class="n">_geom_generator</span><span class="p">,</span> <span class="n">freq_irrep_only</span><span class="o">=-</span><span class="mi">1</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="s2">&quot;1_0&quot;</span><span class="p">)</span>
<span class="n">hessian_from_gradients_geometries</span> <span class="o">=</span> <span class="n">partial</span><span class="p">(</span><span class="n">_geom_generator</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="s2">&quot;2_1&quot;</span><span class="p">)</span>
<span class="n">hessian_from_energies_geometries</span> <span class="o">=</span> <span class="n">partial</span><span class="p">(</span><span class="n">_geom_generator</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="s2">&quot;2_0&quot;</span><span class="p">)</span>

<span class="n">gradient_from_energies_geometries</span><span class="o">.</span><span class="vm">__doc__</span> <span class="o">=</span> <span class="s2">&quot;Generate geometries for a gradient by finite difference of energies.&quot;</span> <span class="o">+</span> <span class="n">_der_from_lesser_docstring</span>
<span class="n">hessian_from_gradients_geometries</span><span class="o">.</span><span class="vm">__doc__</span> <span class="o">=</span> <span class="s2">&quot;Generate geometries for a Hessian by finite difference of gradients.&quot;</span> <span class="o">+</span> <span class="n">_der_from_lesser_docstring</span>
<span class="n">hessian_from_energies_geometries</span><span class="o">.</span><span class="vm">__doc__</span> <span class="o">=</span> <span class="s2">&quot;Generate geometries for a Hessian by finite difference of energies.&quot;</span> <span class="o">+</span> <span class="n">_der_from_lesser_docstring</span>


<span class="k">def</span> <span class="nf">assemble_gradient_from_energies</span><span class="p">(</span><span class="n">findifrec</span><span class="p">:</span> <span class="n">Dict</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Compute the gradient by finite difference of energies.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    findifrec</span>
<span class="sd">        Dictionary of finite difference data, specified in _geom_generator docstring.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    gradient</span>
<span class="sd">        (nat, 3) Cartesian gradient [Eh/a0].</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c1"># This *must* be a Psi molecule at present - CdSalcList generation panics otherwise</span>
    <span class="n">mol</span> <span class="o">=</span> <span class="n">core</span><span class="o">.</span><span class="n">Molecule</span><span class="o">.</span><span class="n">from_schema</span><span class="p">(</span><span class="n">findifrec</span><span class="p">[</span><span class="s2">&quot;molecule&quot;</span><span class="p">],</span> <span class="n">nonphysical</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">init_string</span><span class="p">(</span><span class="n">data</span><span class="p">):</span>
        <span class="k">return</span> <span class="sa">f</span><span class="s2">&quot;&quot;&quot;  Computing gradient from energies.</span>
<span class="s2">    Using </span><span class="si">{</span><span class="n">findifrec</span><span class="p">[</span><span class="s2">&quot;stencil_size&quot;</span><span class="p">]</span><span class="si">}</span><span class="s2">-point formula.</span>
<span class="s2">    Energy without displacement: </span><span class="si">{</span><span class="n">findifrec</span><span class="p">[</span><span class="s2">&quot;reference&quot;</span><span class="p">][</span><span class="s2">&quot;energy&quot;</span><span class="p">]</span><span class="si">:</span><span class="s2">15.10f</span><span class="si">}</span>
<span class="s2">    Check energies below for precision!</span>
<span class="s2">    Forces are for mass-weighted, symmetry-adapted cartesians [a0].</span><span class="se">\n</span><span class="s2">&quot;&quot;&quot;</span>

    <span class="n">data</span> <span class="o">=</span> <span class="n">_initialize_findif</span><span class="p">(</span><span class="n">mol</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="s2">&quot;1_0&quot;</span><span class="p">,</span> <span class="n">findifrec</span><span class="p">[</span><span class="s1">&#39;stencil_size&#39;</span><span class="p">],</span> <span class="n">findifrec</span><span class="p">[</span><span class="s1">&#39;step&#39;</span><span class="p">][</span><span class="s1">&#39;size&#39;</span><span class="p">],</span> <span class="n">init_string</span><span class="p">,</span>
                              <span class="n">findifrec</span><span class="p">[</span><span class="s1">&#39;project_translations&#39;</span><span class="p">],</span> <span class="n">findifrec</span><span class="p">[</span><span class="s1">&#39;project_rotations&#39;</span><span class="p">],</span> <span class="kc">False</span><span class="p">)</span>
    <span class="n">salc_indices</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="s2">&quot;salc_indices_pi&quot;</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>

    <span class="c1"># Extract the energies, and turn then into an ndarray for easy manipulating</span>
    <span class="c1"># E(i, j) := Energy on displacing the ith SALC we care about in the jth step</span>
    <span class="c1"># Steps are ordered, for example, -2, -1, 1, 2</span>
    <span class="n">max_disp</span> <span class="o">=</span> <span class="p">(</span><span class="n">findifrec</span><span class="p">[</span><span class="s2">&quot;stencil_size&quot;</span><span class="p">]</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">//</span> <span class="mi">2</span>  <span class="c1"># The numerator had better be divisible by two.</span>
    <span class="n">e_per_salc</span> <span class="o">=</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">max_disp</span>
    <span class="n">E</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="nb">len</span><span class="p">(</span><span class="n">salc_indices</span><span class="p">),</span> <span class="n">e_per_salc</span><span class="p">))</span>

    <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">salc_index</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">salc_indices</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">max_disp</span> <span class="o">+</span> <span class="mi">1</span><span class="p">):</span>
            <span class="n">E</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">max_disp</span> <span class="o">-</span> <span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">findifrec</span><span class="p">[</span><span class="s2">&quot;displacements&quot;</span><span class="p">][</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">salc_index</span><span class="si">}</span><span class="s2">: </span><span class="si">{</span><span class="o">-</span><span class="n">j</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">][</span><span class="s2">&quot;energy&quot;</span><span class="p">]</span>
            <span class="n">E</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">max_disp</span> <span class="o">+</span> <span class="n">j</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">findifrec</span><span class="p">[</span><span class="s2">&quot;displacements&quot;</span><span class="p">][</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">salc_index</span><span class="si">}</span><span class="s2">: </span><span class="si">{</span><span class="n">j</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">][</span><span class="s2">&quot;energy&quot;</span><span class="p">]</span>

    <span class="c1"># Perform the finite difference.</span>
    <span class="k">if</span> <span class="n">findifrec</span><span class="p">[</span><span class="s2">&quot;stencil_size&quot;</span><span class="p">]</span> <span class="o">==</span> <span class="mi">3</span><span class="p">:</span>
        <span class="n">g_q</span> <span class="o">=</span> <span class="p">(</span><span class="n">E</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">E</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">])</span> <span class="o">/</span> <span class="p">(</span><span class="mf">2.0</span> <span class="o">*</span> <span class="n">findifrec</span><span class="p">[</span><span class="s2">&quot;step&quot;</span><span class="p">][</span><span class="s2">&quot;size&quot;</span><span class="p">])</span>
    <span class="k">elif</span> <span class="n">findifrec</span><span class="p">[</span><span class="s2">&quot;stencil_size&quot;</span><span class="p">]</span> <span class="o">==</span> <span class="mi">5</span><span class="p">:</span>
        <span class="n">g_q</span> <span class="o">=</span> <span class="p">(</span><span class="n">E</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="mf">8.0</span> <span class="o">*</span> <span class="n">E</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="mf">8.0</span> <span class="o">*</span> <span class="n">E</span><span class="p">[:,</span> <span class="mi">2</span><span class="p">]</span> <span class="o">-</span> <span class="n">E</span><span class="p">[:,</span> <span class="mi">3</span><span class="p">])</span> <span class="o">/</span> <span class="p">(</span><span class="mf">12.0</span> <span class="o">*</span> <span class="n">findifrec</span><span class="p">[</span><span class="s2">&quot;step&quot;</span><span class="p">][</span><span class="s2">&quot;size&quot;</span><span class="p">])</span>
    <span class="k">else</span><span class="p">:</span>  <span class="c1"># This error SHOULD have already been caught, but just in case...</span>
        <span class="k">raise</span> <span class="n">ValidationError</span><span class="p">(</span><span class="s2">&quot;FINDIF: </span><span class="si">{}</span><span class="s2"> is an invalid number of points.&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">findifrec</span><span class="p">[</span><span class="s2">&quot;stencil_size&quot;</span><span class="p">]))</span>
    <span class="n">g_q</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">g_q</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">data</span><span class="p">[</span><span class="s2">&quot;print_lvl&quot;</span><span class="p">]:</span>
        <span class="n">energy_string</span> <span class="o">=</span> <span class="s2">&quot;&quot;</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">max_disp</span> <span class="o">+</span> <span class="mi">1</span><span class="p">):</span>
            <span class="n">energy_string</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;Energy(-</span><span class="si">{</span><span class="n">i</span><span class="si">}</span><span class="s2">)        &quot;</span> <span class="o">+</span> <span class="n">energy_string</span> <span class="o">+</span> <span class="sa">f</span><span class="s2">&quot;Energy(+</span><span class="si">{</span><span class="n">i</span><span class="si">}</span><span class="s2">)        &quot;</span>
        <span class="n">info</span> <span class="o">=</span> <span class="s2">&quot;</span><span class="se">\n</span><span class="s2">     Coord      &quot;</span> <span class="o">+</span> <span class="n">energy_string</span> <span class="o">+</span> <span class="s2">&quot;    Force&quot;</span>
        <span class="k">for</span> <span class="n">salc</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="s2">&quot;n_salc&quot;</span><span class="p">]):</span>
            <span class="n">print_str</span> <span class="o">=</span> <span class="s2">&quot;</span><span class="se">\n</span><span class="s2">    </span><span class="si">{:5d}</span><span class="s2">&quot;</span> <span class="o">+</span> <span class="s2">&quot; </span><span class="si">{:17.10f}</span><span class="s2">&quot;</span> <span class="o">*</span> <span class="p">(</span><span class="n">e_per_salc</span><span class="p">)</span> <span class="o">+</span> <span class="s2">&quot; </span><span class="si">{force:17.10f}</span><span class="s2">&quot;</span>
            <span class="n">energies</span> <span class="o">=</span> <span class="n">E</span><span class="p">[</span><span class="n">salc</span><span class="p">]</span>
            <span class="n">info</span> <span class="o">+=</span> <span class="n">print_str</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">salc</span><span class="p">,</span> <span class="n">force</span><span class="o">=</span><span class="n">g_q</span><span class="p">[</span><span class="n">salc</span><span class="p">],</span> <span class="o">*</span><span class="n">energies</span><span class="p">)</span>
        <span class="n">core</span><span class="o">.</span><span class="n">print_out</span><span class="p">(</span><span class="n">info</span><span class="p">)</span>
        <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="n">info</span><span class="p">)</span>

    <span class="c1"># Transform the gradient from mass-weighted SALCs to non-mass-weighted Cartesians</span>
    <span class="n">B</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="s2">&quot;salc_list&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">matrix</span><span class="p">()</span>
    <span class="n">g_cart</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">g_q</span><span class="p">,</span> <span class="n">B</span><span class="p">)</span>
    <span class="n">g_cart</span> <span class="o">=</span> <span class="n">g_cart</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="s2">&quot;n_atom&quot;</span><span class="p">],</span> <span class="mi">3</span><span class="p">)</span>
    <span class="n">massweighter</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">mol</span><span class="o">.</span><span class="n">mass</span><span class="p">(</span><span class="n">a</span><span class="p">)</span> <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="s2">&quot;n_atom&quot;</span><span class="p">])])</span><span class="o">**</span><span class="p">(</span><span class="mf">0.5</span><span class="p">)</span>
    <span class="n">g_cart</span> <span class="o">=</span> <span class="p">(</span><span class="n">g_cart</span><span class="o">.</span><span class="n">T</span> <span class="o">*</span> <span class="n">massweighter</span><span class="p">)</span><span class="o">.</span><span class="n">T</span>

    <span class="k">if</span> <span class="n">data</span><span class="p">[</span><span class="s2">&quot;print_lvl&quot;</span><span class="p">]:</span>
        <span class="n">info</span> <span class="o">=</span> <span class="s2">&quot;</span><span class="se">\n</span><span class="s2">         -------------------------------------------------------------</span><span class="se">\n</span><span class="s2">&quot;</span>
        <span class="n">core</span><span class="o">.</span><span class="n">print_out</span><span class="p">(</span><span class="n">info</span><span class="p">)</span>
        <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="n">info</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">g_cart</span>


<span class="k">def</span> <span class="nf">_process_hessian_symmetry_block</span><span class="p">(</span><span class="n">H_block</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">B_block</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">massweighter</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">irrep</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">print_lvl</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Perform post-construction processing for a symmetry block of the Hessian.</span>
<span class="sd">       Statements need to be printed, and the Hessian must be made orthogonal.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    H_block</span>
<span class="sd">        A block of the Hessian for an irrep, in mass-weighted salcs.</span>
<span class="sd">        (nsalc, nsalc)</span>
<span class="sd">    B_block</span>
<span class="sd">        A block of the B matrix for an irrep, which transforms CdSalcs to Cartesians.</span>
<span class="sd">        (nsalc, 3 * nat)</span>
<span class="sd">    massweighter</span>
<span class="sd">        The mass associated with each atomic coordinate.</span>
<span class="sd">        (3 * nat, ) Due to x, y, z, values appear in groups of three.</span>
<span class="sd">    irrep</span>
<span class="sd">        A string identifying the irrep H_block and B_block are of.</span>
<span class="sd">    print_lvl</span>
<span class="sd">        The level of printing information requested by the user.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    H_block</span>
<span class="sd">        H_block, but made into an orthogonal array.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c1"># Symmetrize our Hessian block.</span>
    <span class="c1"># The symmetric structure is lost due to errors in the computation</span>
    <span class="n">H_block</span> <span class="o">=</span> <span class="p">(</span><span class="n">H_block</span> <span class="o">+</span> <span class="n">H_block</span><span class="o">.</span><span class="n">T</span><span class="p">)</span> <span class="o">/</span> <span class="mf">2.0</span>

    <span class="k">if</span> <span class="n">print_lvl</span> <span class="o">&gt;=</span> <span class="mi">3</span><span class="p">:</span>
        <span class="n">core</span><span class="o">.</span><span class="n">print_out</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Force Constants for irrep </span><span class="si">{</span><span class="n">irrep</span><span class="si">}</span><span class="s2"> in mass-weighted, symmetry-adapted Cartesian coordinates.&quot;</span><span class="p">)</span>
        <span class="n">core</span><span class="o">.</span><span class="n">print_out</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\n</span><span class="si">{}</span><span class="se">\n</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">nppp10</span><span class="p">(</span><span class="n">H_block</span><span class="p">)))</span>

    <span class="n">evals</span><span class="p">,</span> <span class="n">evects</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">eigh</span><span class="p">(</span><span class="n">H_block</span><span class="p">)</span>
    <span class="c1"># Get our eigenvalues and eigenvectors in descending order.</span>
    <span class="n">idx</span> <span class="o">=</span> <span class="n">evals</span><span class="o">.</span><span class="n">argsort</span><span class="p">()[::</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
    <span class="n">evals</span> <span class="o">=</span> <span class="n">evals</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span>
    <span class="n">evects</span> <span class="o">=</span> <span class="n">evects</span><span class="p">[:,</span> <span class="n">idx</span><span class="p">]</span>

    <span class="n">normal_irr</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">((</span><span class="n">B_block</span> <span class="o">*</span> <span class="n">massweighter</span><span class="p">)</span><span class="o">.</span><span class="n">T</span><span class="p">,</span> <span class="n">evects</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">print_lvl</span> <span class="o">&gt;=</span> <span class="mi">2</span><span class="p">:</span>
        <span class="n">core</span><span class="o">.</span><span class="n">print_out</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">    Normal coordinates (non-mass-weighted) for irrep </span><span class="si">{}</span><span class="s2">:</span><span class="se">\n</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">irrep</span><span class="p">))</span>
        <span class="n">core</span><span class="o">.</span><span class="n">print_out</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\n</span><span class="si">{}</span><span class="se">\n</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">nppp10</span><span class="p">(</span><span class="n">normal_irr</span><span class="p">)))</span>

    <span class="k">return</span> <span class="n">H_block</span>


<span class="k">def</span> <span class="nf">_process_hessian</span><span class="p">(</span><span class="n">H_blocks</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">],</span> <span class="n">B_blocks</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">],</span> <span class="n">massweighter</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">print_lvl</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Perform post-construction processing for the Hessian.</span>
<span class="sd">       Statements need to be printed, and the Hessian must be transformed.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    H_blocks</span>
<span class="sd">        A list of blocks of the Hessian per irrep, in mass-weighted salcs.</span>
<span class="sd">        Each is (nsalc_in_irrep, nsalc_in_irrep)</span>
<span class="sd">    B_blocks</span>
<span class="sd">        A block of the B matrix per irrep, which transforms CdSalcs to Cartesians.</span>
<span class="sd">        Each is (nsalc_in_irrep, 3 * nat)</span>
<span class="sd">    massweighter</span>
<span class="sd">        The mass associated with each atomic coordinate.</span>
<span class="sd">        (3 * nat, ) Due to x, y, z, values appear in groups of three.</span>
<span class="sd">    print_lvl</span>
<span class="sd">        The level of printing information requested by the user.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    Hx</span>
<span class="sd">        The Hessian in non-mass weighted cartesians.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c1"># Handle empty case (atom)</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">H_blocks</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">B_blocks</span><span class="p">:</span>
        <span class="n">nat3</span> <span class="o">=</span> <span class="n">massweighter</span><span class="o">.</span><span class="n">size</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">nat3</span><span class="p">,</span> <span class="n">nat3</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span>

    <span class="c1"># We have the Hessian in each irrep! The final task is to perform coordinate transforms.</span>
    <span class="n">H</span> <span class="o">=</span> <span class="n">p4util</span><span class="o">.</span><span class="n">block_diagonal_array</span><span class="p">(</span><span class="o">*</span><span class="n">H_blocks</span><span class="p">)</span>
    <span class="n">B</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">(</span><span class="n">B_blocks</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">print_lvl</span> <span class="o">&gt;=</span> <span class="mi">3</span><span class="p">:</span>
        <span class="n">core</span><span class="o">.</span><span class="n">print_out</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">    Force constant matrix for all computed irreps in mass-weighted SALCS.</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="n">core</span><span class="o">.</span><span class="n">print_out</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\n</span><span class="si">{}</span><span class="se">\n</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">nppp10</span><span class="p">(</span><span class="n">H</span><span class="p">)))</span>

    <span class="c1"># Transform the massweighted Hessian from the CdSalc basis to Cartesians.</span>
    <span class="c1"># The Hessian is the matrix not of a linear transformation, but of a (symmetric) bilinear form</span>
    <span class="c1"># As such, the change of basis is formula A&#39; = Xt A X, no inverses!</span>
    <span class="c1"># More conceptually, it&#39;s A&#39;_kl = A_ij X_ik X_jl; Each index transforms linearly.</span>
    <span class="n">Hx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">B</span><span class="o">.</span><span class="n">T</span><span class="p">,</span> <span class="n">H</span><span class="p">),</span> <span class="n">B</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">print_lvl</span> <span class="o">&gt;=</span> <span class="mi">3</span><span class="p">:</span>
        <span class="n">core</span><span class="o">.</span><span class="n">print_out</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">    Force constants in mass-weighted Cartesian coordinates.</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="n">core</span><span class="o">.</span><span class="n">print_out</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\n</span><span class="si">{}</span><span class="se">\n</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">nppp10</span><span class="p">(</span><span class="n">Hx</span><span class="p">)))</span>

    <span class="c1"># Un-massweight the Hessian.</span>
    <span class="n">Hx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="n">Hx</span> <span class="o">/</span> <span class="n">massweighter</span><span class="p">)</span> <span class="o">/</span> <span class="n">massweighter</span>

    <span class="k">if</span> <span class="n">print_lvl</span> <span class="o">&gt;=</span> <span class="mi">3</span><span class="p">:</span>
        <span class="n">core</span><span class="o">.</span><span class="n">print_out</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">    Force constants in Cartesian coordinates.</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="n">core</span><span class="o">.</span><span class="n">print_out</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\n</span><span class="si">{}</span><span class="se">\n</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">nppp10</span><span class="p">(</span><span class="n">Hx</span><span class="p">)))</span>

    <span class="k">if</span> <span class="n">print_lvl</span><span class="p">:</span>
        <span class="n">core</span><span class="o">.</span><span class="n">print_out</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">-------------------------------------------------------------</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">Hx</span>


<span class="k">def</span> <span class="nf">assemble_dipder_from_dipoles</span><span class="p">(</span><span class="n">findifrec</span><span class="p">:</span> <span class="n">Dict</span><span class="p">,</span> <span class="n">freq_irrep_only</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Compute the dipole derivatives by finite difference of dipoles.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    findifrec</span>
<span class="sd">        Dictionary of finite difference data, specified in _geom_generator docstring.</span>
<span class="sd">    freq_irrep_only</span>
<span class="sd">        The Cotton ordered irrep to get frequencies for. Choose -1 for all</span>
<span class="sd">        irreps.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    dipder</span>
<span class="sd">        (3 * nat, 3) Cartesian Dipole Derivatives [Eh/a0^2]</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c1"># This *must* be a Psi molecule at present - CdSalcList generation panics otherwise</span>
    <span class="n">mol</span> <span class="o">=</span> <span class="n">core</span><span class="o">.</span><span class="n">Molecule</span><span class="o">.</span><span class="n">from_schema</span><span class="p">(</span><span class="n">findifrec</span><span class="p">[</span><span class="s2">&quot;molecule&quot;</span><span class="p">],</span> <span class="n">nonphysical</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>

    <span class="n">pg</span> <span class="o">=</span> <span class="n">mol</span><span class="o">.</span><span class="n">point_group</span><span class="p">()</span>
    <span class="n">ct</span> <span class="o">=</span> <span class="n">pg</span><span class="o">.</span><span class="n">char_table</span><span class="p">()</span>
    <span class="n">order</span> <span class="o">=</span> <span class="n">pg</span><span class="o">.</span><span class="n">order</span><span class="p">()</span>

    <span class="n">displacements</span> <span class="o">=</span> <span class="n">findifrec</span><span class="p">[</span><span class="s2">&quot;displacements&quot;</span><span class="p">]</span>

    <span class="k">def</span> <span class="nf">init_string</span><span class="p">(</span><span class="n">data</span><span class="p">):</span>
        <span class="k">return</span> <span class="p">(</span><span class="s2">&quot;&quot;</span><span class="p">)</span>

    <span class="n">data</span> <span class="o">=</span> <span class="n">_initialize_findif</span><span class="p">(</span><span class="n">mol</span><span class="p">,</span> <span class="n">freq_irrep_only</span><span class="p">,</span> <span class="s2">&quot;2_1&quot;</span><span class="p">,</span> <span class="n">findifrec</span><span class="p">[</span><span class="s1">&#39;stencil_size&#39;</span><span class="p">],</span> <span class="n">findifrec</span><span class="p">[</span><span class="s1">&#39;step&#39;</span><span class="p">][</span><span class="s1">&#39;size&#39;</span><span class="p">],</span>
                              <span class="n">init_string</span><span class="p">,</span> <span class="n">findifrec</span><span class="p">[</span><span class="s1">&#39;project_translations&#39;</span><span class="p">],</span> <span class="n">findifrec</span><span class="p">[</span><span class="s1">&#39;project_rotations&#39;</span><span class="p">],</span> <span class="kc">False</span><span class="p">)</span>
    <span class="n">salc_indices</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="s2">&quot;salc_indices_pi&quot;</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">max_disp</span> <span class="o">=</span> <span class="p">(</span><span class="n">findifrec</span><span class="p">[</span><span class="s2">&quot;stencil_size&quot;</span><span class="p">]</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">//</span> <span class="mi">2</span>  <span class="c1"># The numerator had better be divisible by two.</span>
    <span class="n">d_per_salc</span> <span class="o">=</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">max_disp</span>

    <span class="c1"># Populating with positive and negative displacements for the identity point group</span>
    <span class="n">dipole</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">shape</span><span class="o">=</span><span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="s1">&#39;n_salc&#39;</span><span class="p">],</span> <span class="n">d_per_salc</span><span class="p">,</span> <span class="mi">3</span><span class="p">))</span>
    <span class="k">for</span> <span class="n">salc_index</span> <span class="ow">in</span> <span class="n">salc_indices</span><span class="p">:</span>
        <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">max_disp</span> <span class="o">+</span> <span class="mi">1</span><span class="p">):</span>
            <span class="n">dipole</span><span class="p">[</span><span class="n">salc_index</span><span class="p">,</span> <span class="n">max_disp</span> <span class="o">-</span> <span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">displacements</span><span class="p">[</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">salc_index</span><span class="si">}</span><span class="s2">: </span><span class="si">{</span><span class="o">-</span><span class="n">j</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">][</span><span class="s2">&quot;dipole&quot;</span><span class="p">]</span>
            <span class="n">dipole</span><span class="p">[</span><span class="n">salc_index</span><span class="p">,</span> <span class="n">max_disp</span> <span class="o">+</span> <span class="n">j</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">displacements</span><span class="p">[</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">salc_index</span><span class="si">}</span><span class="s2">: </span><span class="si">{</span><span class="n">j</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">][</span><span class="s2">&quot;dipole&quot;</span><span class="p">]</span>

    <span class="k">for</span> <span class="n">h</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">data</span><span class="p">[</span><span class="s2">&quot;n_irrep&quot;</span><span class="p">]):</span>
        <span class="c1"># Find the group operation that converts + to - displacements.</span>
        <span class="n">gamma</span> <span class="o">=</span> <span class="n">ct</span><span class="o">.</span><span class="n">gamma</span><span class="p">(</span><span class="n">h</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">group_op</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">order</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">gamma</span><span class="o">.</span><span class="n">character</span><span class="p">(</span><span class="n">group_op</span><span class="p">)</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">:</span>
                <span class="k">break</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">ValidationError</span><span class="p">(</span><span class="s2">&quot;A symmetric dipole passed for a non-symmetric one.&quot;</span><span class="p">)</span>

        <span class="n">sym_op</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">ct</span><span class="o">.</span><span class="n">symm_operation</span><span class="p">(</span><span class="n">group_op</span><span class="p">)</span><span class="o">.</span><span class="n">matrix</span><span class="p">())</span>
        <span class="n">salc_indices</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="s2">&quot;salc_indices_pi&quot;</span><span class="p">][</span><span class="n">h</span><span class="p">]</span>

        <span class="c1"># Creating positive displacements and populating for the other point groups</span>
        <span class="k">for</span> <span class="n">salc_index</span> <span class="ow">in</span> <span class="n">salc_indices</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">max_disp</span> <span class="o">+</span> <span class="mi">1</span><span class="p">):</span>
                <span class="n">pos_disp_dipole</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">sym_op</span><span class="p">,</span> <span class="n">displacements</span><span class="p">[</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">salc_index</span><span class="si">}</span><span class="s2">: </span><span class="si">{</span><span class="o">-</span><span class="n">j</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">][</span><span class="s2">&quot;dipole&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">T</span><span class="p">)</span>
                <span class="n">dipole</span><span class="p">[</span><span class="n">salc_index</span><span class="p">,</span> <span class="n">max_disp</span> <span class="o">-</span> <span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">displacements</span><span class="p">[</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">salc_index</span><span class="si">}</span><span class="s2">: </span><span class="si">{</span><span class="o">-</span><span class="n">j</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">][</span><span class="s2">&quot;dipole&quot;</span><span class="p">]</span>
                <span class="n">dipole</span><span class="p">[</span><span class="n">salc_index</span><span class="p">,</span> <span class="n">max_disp</span> <span class="o">+</span> <span class="n">j</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">pos_disp_dipole</span>

    <span class="c1"># Computing the dipole derivative by finite differnce</span>
    <span class="k">if</span> <span class="n">findifrec</span><span class="p">[</span><span class="s2">&quot;stencil_size&quot;</span><span class="p">]</span> <span class="o">==</span> <span class="mi">3</span><span class="p">:</span>
        <span class="n">dipder_q</span> <span class="o">=</span> <span class="p">(</span><span class="n">dipole</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">dipole</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">])</span> <span class="o">/</span> <span class="p">(</span><span class="mf">2.0</span> <span class="o">*</span> <span class="n">findifrec</span><span class="p">[</span><span class="s2">&quot;step&quot;</span><span class="p">][</span><span class="s2">&quot;size&quot;</span><span class="p">])</span>
    <span class="k">elif</span> <span class="n">findifrec</span><span class="p">[</span><span class="s2">&quot;stencil_size&quot;</span><span class="p">]</span> <span class="o">==</span> <span class="mi">5</span><span class="p">:</span>
        <span class="n">dipder_q</span> <span class="o">=</span> <span class="p">(</span><span class="n">dipole</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="mf">8.0</span> <span class="o">*</span> <span class="n">dipole</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="mf">8.0</span> <span class="o">*</span> <span class="n">dipole</span><span class="p">[:,</span> <span class="mi">2</span><span class="p">]</span> <span class="o">-</span>
                    <span class="n">dipole</span><span class="p">[:,</span> <span class="mi">3</span><span class="p">])</span> <span class="o">/</span> <span class="p">(</span><span class="mf">12.0</span> <span class="o">*</span> <span class="n">findifrec</span><span class="p">[</span><span class="s2">&quot;step&quot;</span><span class="p">][</span><span class="s2">&quot;size&quot;</span><span class="p">])</span>

    <span class="c1"># Transform the dipole derivates from mass-weighted SALCs to non-mass-weighted Cartesians</span>
    <span class="n">B</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="s2">&quot;salc_list&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">matrix</span><span class="p">())</span>
    <span class="n">dipder_cart</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">dipder_q</span><span class="o">.</span><span class="n">T</span><span class="p">,</span> <span class="n">B</span><span class="p">)</span>
    <span class="n">dipder_cart</span> <span class="o">=</span> <span class="n">dipder_cart</span><span class="o">.</span><span class="n">T</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="s2">&quot;n_atom&quot;</span><span class="p">],</span> <span class="mi">9</span><span class="p">)</span>

    <span class="n">massweighter</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">mol</span><span class="o">.</span><span class="n">mass</span><span class="p">(</span><span class="n">a</span><span class="p">)</span> <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="s2">&quot;n_atom&quot;</span><span class="p">])])</span><span class="o">**</span><span class="p">(</span><span class="mf">0.5</span><span class="p">)</span>
    <span class="n">dipder_cart</span> <span class="o">=</span> <span class="p">(</span><span class="n">dipder_cart</span><span class="o">.</span><span class="n">T</span> <span class="o">*</span> <span class="n">massweighter</span><span class="p">)</span><span class="o">.</span><span class="n">T</span>

    <span class="n">dipder_cart</span> <span class="o">=</span> <span class="n">dipder_cart</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="mi">3</span> <span class="o">*</span> <span class="n">data</span><span class="p">[</span><span class="s2">&quot;n_atom&quot;</span><span class="p">],</span> <span class="mi">3</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">dipder_cart</span>


<span class="k">def</span> <span class="nf">assemble_hessian_from_gradients</span><span class="p">(</span><span class="n">findifrec</span><span class="p">:</span> <span class="n">Dict</span><span class="p">,</span> <span class="n">freq_irrep_only</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Compute the Hessian by finite difference of gradients.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    findifrec</span>
<span class="sd">        Dictionary of finite difference data, specified in _geom_generator docstring.</span>
<span class="sd">    freq_irrep_only</span>
<span class="sd">        The Cotton ordered irrep to get frequencies for. Choose -1 for all</span>
<span class="sd">        irreps.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    hessian</span>
<span class="sd">        (3 * nat, 3 * nat) Cartesian Hessian [Eh/a0^2]</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c1"># This *must* be a Psi molecule at present - CdSalcList generation panics otherwise</span>
    <span class="n">mol</span> <span class="o">=</span> <span class="n">core</span><span class="o">.</span><span class="n">Molecule</span><span class="o">.</span><span class="n">from_schema</span><span class="p">(</span><span class="n">findifrec</span><span class="p">[</span><span class="s2">&quot;molecule&quot;</span><span class="p">],</span> <span class="n">nonphysical</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>

    <span class="n">displacements</span> <span class="o">=</span> <span class="n">findifrec</span><span class="p">[</span><span class="s2">&quot;displacements&quot;</span><span class="p">]</span>

    <span class="k">def</span> <span class="nf">init_string</span><span class="p">(</span><span class="n">data</span><span class="p">):</span>
        <span class="k">return</span> <span class="p">(</span><span class="s2">&quot;  Computing second-derivative from gradients using projected, </span><span class="se">\n</span><span class="s2">&quot;</span>
                <span class="s2">&quot;  symmetry-adapted, cartesian coordinates.</span><span class="se">\n\n</span><span class="s2">&quot;</span>
                <span class="s2">&quot;  </span><span class="si">{:d}</span><span class="s2"> gradients passed in, including the reference geometry.</span><span class="se">\n</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">displacements</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">))</span>

    <span class="n">data</span> <span class="o">=</span> <span class="n">_initialize_findif</span><span class="p">(</span><span class="n">mol</span><span class="p">,</span> <span class="n">freq_irrep_only</span><span class="p">,</span> <span class="s2">&quot;2_1&quot;</span><span class="p">,</span> <span class="n">findifrec</span><span class="p">[</span><span class="s1">&#39;stencil_size&#39;</span><span class="p">],</span> <span class="n">findifrec</span><span class="p">[</span><span class="s1">&#39;step&#39;</span><span class="p">][</span><span class="s1">&#39;size&#39;</span><span class="p">],</span>
                              <span class="n">init_string</span><span class="p">,</span> <span class="n">findifrec</span><span class="p">[</span><span class="s1">&#39;project_translations&#39;</span><span class="p">],</span> <span class="n">findifrec</span><span class="p">[</span><span class="s1">&#39;project_rotations&#39;</span><span class="p">],</span> <span class="kc">False</span><span class="p">)</span>

    <span class="c1"># For non-totally symmetric CdSALCs, a symmetry operation can convert + and - displacements.</span>
    <span class="c1"># Good News: By taking advantage of that, we (potentially) ran less computations.</span>
    <span class="c1"># Bad News: We need to find the - displacements from the + computations now.</span>
    <span class="c1"># The next ~80 lines of code are dedicated to that task.</span>
    <span class="k">if</span> <span class="n">data</span><span class="p">[</span><span class="s2">&quot;print_lvl&quot;</span><span class="p">]:</span>
        <span class="n">core</span><span class="o">.</span><span class="n">print_out</span><span class="p">(</span><span class="s2">&quot;  Generating complete list of displacements from unique ones.</span><span class="se">\n\n</span><span class="s2">&quot;</span><span class="p">)</span>

    <span class="n">pg</span> <span class="o">=</span> <span class="n">mol</span><span class="o">.</span><span class="n">point_group</span><span class="p">()</span>
    <span class="n">ct</span> <span class="o">=</span> <span class="n">pg</span><span class="o">.</span><span class="n">char_table</span><span class="p">()</span>
    <span class="n">order</span> <span class="o">=</span> <span class="n">pg</span><span class="o">.</span><span class="n">order</span><span class="p">()</span>

    <span class="c1"># Determine what atoms map to what other atoms under the point group operations.</span>
    <span class="c1"># The py-side compute_atom_map will work whether mol is a Py-side or C-side object.</span>
    <span class="n">atom_map</span> <span class="o">=</span> <span class="n">qcdb</span><span class="o">.</span><span class="n">compute_atom_map</span><span class="p">(</span><span class="n">mol</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">data</span><span class="p">[</span><span class="s2">&quot;print_lvl&quot;</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="mi">3</span><span class="p">:</span>
        <span class="n">core</span><span class="o">.</span><span class="n">print_out</span><span class="p">(</span><span class="s2">&quot;    The atom map:</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">atom</span><span class="p">,</span> <span class="n">sym_image_list</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">atom_map</span><span class="p">):</span>
            <span class="n">core</span><span class="o">.</span><span class="n">print_out</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;     </span><span class="si">{</span><span class="n">atom</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="si">:</span><span class="s2">d</span><span class="si">}</span><span class="s2"> : &quot;</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">image_atom</span> <span class="ow">in</span> <span class="n">sym_image_list</span><span class="p">:</span>
                <span class="n">core</span><span class="o">.</span><span class="n">print_out</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">image_atom</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="si">:</span><span class="s2">4d</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
            <span class="n">core</span><span class="o">.</span><span class="n">print_out</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="n">core</span><span class="o">.</span><span class="n">print_out</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">)</span>

    <span class="c1"># A list of lists of gradients, per irrep</span>
    <span class="n">gradients_pi</span> <span class="o">=</span> <span class="p">[[]]</span>
    <span class="c1"># Extract and print the symmetric gradients. These need no additional processing.</span>
    <span class="n">max_disp</span> <span class="o">=</span> <span class="p">(</span><span class="n">findifrec</span><span class="p">[</span><span class="s2">&quot;stencil_size&quot;</span><span class="p">]</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">//</span> <span class="mi">2</span>  <span class="c1"># The numerator had better be divisible by two.</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">data</span><span class="p">[</span><span class="s2">&quot;salc_indices_pi&quot;</span><span class="p">][</span><span class="mi">0</span><span class="p">]:</span>
        <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="o">-</span><span class="n">max_disp</span><span class="p">,</span> <span class="mi">0</span><span class="p">):</span>
            <span class="n">grad_raw</span> <span class="o">=</span> <span class="n">displacements</span><span class="p">[</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">i</span><span class="si">}</span><span class="s2">: </span><span class="si">{</span><span class="n">n</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">][</span><span class="s2">&quot;gradient&quot;</span><span class="p">]</span>
            <span class="n">gradients_pi</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">grad_raw</span><span class="p">,</span> <span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">)))</span>
        <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">max_disp</span> <span class="o">+</span> <span class="mi">1</span><span class="p">):</span>
            <span class="n">grad_raw</span> <span class="o">=</span> <span class="n">displacements</span><span class="p">[</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">i</span><span class="si">}</span><span class="s2">: </span><span class="si">{</span><span class="n">n</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">][</span><span class="s2">&quot;gradient&quot;</span><span class="p">]</span>
            <span class="n">gradients_pi</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">grad_raw</span><span class="p">,</span> <span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">)))</span>

    <span class="k">if</span> <span class="n">data</span><span class="p">[</span><span class="s2">&quot;print_lvl&quot;</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="mi">3</span><span class="p">:</span>
        <span class="n">core</span><span class="o">.</span><span class="n">print_out</span><span class="p">(</span><span class="s2">&quot;    Symmetric gradients</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">gradient</span> <span class="ow">in</span> <span class="n">gradients_pi</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span>
            <span class="n">core</span><span class="o">.</span><span class="n">print_out</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\n</span><span class="si">{}</span><span class="se">\n</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">nppp10</span><span class="p">(</span><span class="n">gradient</span><span class="p">)))</span>

    <span class="c1"># Asymmetric gradient. There&#39;s always SOME operation that transforms a positive</span>
    <span class="c1"># into a negative displacement.By doing extra things here, we can find the</span>
    <span class="c1"># gradients at the positive displacements.</span>
    <span class="k">for</span> <span class="n">h</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">data</span><span class="p">[</span><span class="s2">&quot;n_irrep&quot;</span><span class="p">]):</span>

        <span class="c1"># If there are no CdSALCs in this irrep, let&#39;s skip it.</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">data</span><span class="p">[</span><span class="s2">&quot;n_disp_pi&quot;</span><span class="p">][</span><span class="n">h</span><span class="p">]:</span>
            <span class="n">gradients_pi</span><span class="o">.</span><span class="n">append</span><span class="p">([])</span>
            <span class="k">continue</span>

        <span class="n">gamma</span> <span class="o">=</span> <span class="n">ct</span><span class="o">.</span><span class="n">gamma</span><span class="p">(</span><span class="n">h</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">data</span><span class="p">[</span><span class="s2">&quot;print_lvl&quot;</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="mi">3</span><span class="p">:</span>
            <span class="n">core</span><span class="o">.</span><span class="n">print_out</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Characters for irrep </span><span class="si">{</span><span class="n">h</span><span class="si">}</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">group_op</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">order</span><span class="p">):</span>
                <span class="n">core</span><span class="o">.</span><span class="n">print_out</span><span class="p">(</span><span class="s2">&quot; </span><span class="si">{:5.1f}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">gamma</span><span class="o">.</span><span class="n">character</span><span class="p">(</span><span class="n">group_op</span><span class="p">)))</span>
            <span class="n">core</span><span class="o">.</span><span class="n">print_out</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">)</span>

        <span class="c1"># Find the group operation that converts + to - displacements.</span>
        <span class="k">for</span> <span class="n">group_op</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">order</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">gamma</span><span class="o">.</span><span class="n">character</span><span class="p">(</span><span class="n">group_op</span><span class="p">)</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">:</span>
                <span class="k">break</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">ValidationError</span><span class="p">(</span><span class="s2">&quot;A symmetric gradient passed for a non-symmetric one.&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">data</span><span class="p">[</span><span class="s2">&quot;print_lvl&quot;</span><span class="p">]:</span>
            <span class="n">core</span><span class="o">.</span><span class="n">print_out</span><span class="p">(</span><span class="s2">&quot;    Operation </span><span class="si">{}</span><span class="s2"> takes plus displacements of irrep </span><span class="si">{}</span><span class="s2"> to minus ones.</span><span class="se">\n</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                <span class="n">group_op</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">gamma</span><span class="o">.</span><span class="n">symbol</span><span class="p">()))</span>

        <span class="n">sym_op</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">ct</span><span class="o">.</span><span class="n">symm_operation</span><span class="p">(</span><span class="n">group_op</span><span class="p">)</span><span class="o">.</span><span class="n">matrix</span><span class="p">())</span>
        <span class="n">gradients</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="k">def</span> <span class="nf">recursive_gradients</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">n</span><span class="p">):</span>
<span class="w">            </span><span class="sd">&quot;&quot;&quot;Populate gradients, with step -n, -n+1, ... -1, 1, ... n. Positive displacements are computed.&quot;&quot;&quot;</span>

            <span class="n">grad_raw</span> <span class="o">=</span> <span class="n">displacements</span><span class="p">[</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">i</span><span class="si">}</span><span class="s2">: </span><span class="si">{</span><span class="o">-</span><span class="n">n</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">][</span><span class="s2">&quot;gradient&quot;</span><span class="p">]</span>
            <span class="n">gradients</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">grad_raw</span><span class="p">,</span> <span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">)))</span>
            <span class="n">new_grad</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">data</span><span class="p">[</span><span class="s2">&quot;n_atom&quot;</span><span class="p">],</span> <span class="mi">3</span><span class="p">))</span>
            <span class="k">for</span> <span class="n">atom</span><span class="p">,</span> <span class="n">image</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">atom_map</span><span class="p">):</span>
                <span class="n">atom2</span> <span class="o">=</span> <span class="n">image</span><span class="p">[</span><span class="n">group_op</span><span class="p">]</span>
                <span class="n">new_grad</span><span class="p">[</span><span class="n">atom2</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">einsum</span><span class="p">(</span><span class="s2">&quot;xy,y-&gt;x&quot;</span><span class="p">,</span> <span class="n">sym_op</span><span class="p">,</span> <span class="n">gradients</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">][</span><span class="n">atom</span><span class="p">])</span>
            <span class="k">if</span> <span class="n">n</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
                <span class="n">recursive_gradients</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
            <span class="n">gradients</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">new_grad</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">data</span><span class="p">[</span><span class="s2">&quot;salc_indices_pi&quot;</span><span class="p">][</span><span class="n">h</span><span class="p">]:</span>
            <span class="n">recursive_gradients</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">max_disp</span><span class="p">)</span>
        <span class="n">gradients_pi</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">gradients</span><span class="p">)</span>

    <span class="c1"># Massweight all gradients.</span>
    <span class="c1"># Remember, the atom currently corresponds to our 0 axis, hence these transpose tricks.</span>
    <span class="n">massweighter</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">([</span><span class="n">mol</span><span class="o">.</span><span class="n">mass</span><span class="p">(</span><span class="n">a</span><span class="p">)</span> <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="s2">&quot;n_atom&quot;</span><span class="p">])])</span><span class="o">**</span><span class="p">(</span><span class="o">-</span><span class="mf">0.5</span><span class="p">)</span>
    <span class="n">gradients_pi</span> <span class="o">=</span> <span class="p">[[(</span><span class="n">grad</span><span class="o">.</span><span class="n">T</span> <span class="o">*</span> <span class="n">massweighter</span><span class="p">)</span><span class="o">.</span><span class="n">T</span> <span class="k">for</span> <span class="n">grad</span> <span class="ow">in</span> <span class="n">gradients</span><span class="p">]</span> <span class="k">for</span> <span class="n">gradients</span> <span class="ow">in</span> <span class="n">gradients_pi</span><span class="p">]</span>

    <span class="k">if</span> <span class="n">data</span><span class="p">[</span><span class="s2">&quot;print_lvl&quot;</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="mi">3</span><span class="p">:</span>
        <span class="n">core</span><span class="o">.</span><span class="n">print_out</span><span class="p">(</span><span class="s2">&quot;    All mass-weighted gradients</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">gradients</span> <span class="ow">in</span> <span class="n">gradients_pi</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">grad</span> <span class="ow">in</span> <span class="n">gradients</span><span class="p">:</span>
                <span class="n">core</span><span class="o">.</span><span class="n">print_out</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\n</span><span class="si">{}</span><span class="se">\n</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">nppp10</span><span class="p">(</span><span class="n">grad</span><span class="p">)))</span>

    <span class="c1"># We have all our gradients generated now!</span>
    <span class="c1"># Next, time to get our Hessian.</span>

    <span class="n">H_pi</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">B_pi</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">irrep_lbls</span> <span class="o">=</span> <span class="n">mol</span><span class="o">.</span><span class="n">irrep_labels</span><span class="p">()</span>
    <span class="n">massweighter</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">repeat</span><span class="p">(</span><span class="n">massweighter</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>

    <span class="k">for</span> <span class="n">h</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="s2">&quot;n_irrep&quot;</span><span class="p">]):</span>
        <span class="n">n_disp</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="s2">&quot;n_disp_pi&quot;</span><span class="p">][</span><span class="n">h</span><span class="p">]</span>
        <span class="n">Nindices</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="s2">&quot;salc_indices_pi&quot;</span><span class="p">][</span><span class="n">h</span><span class="p">])</span>
        <span class="n">gradients</span> <span class="o">=</span> <span class="n">gradients_pi</span><span class="p">[</span><span class="n">h</span><span class="p">]</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">Nindices</span><span class="p">:</span>
            <span class="k">continue</span>

        <span class="c1"># Flatten each gradient, and turn it into a COLUMN of the matrix.</span>
        <span class="n">gradient_matrix</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">grad</span><span class="o">.</span><span class="n">flatten</span><span class="p">()</span> <span class="k">for</span> <span class="n">grad</span> <span class="ow">in</span> <span class="n">gradients</span><span class="p">])</span><span class="o">.</span><span class="n">T</span>
        <span class="c1"># Transform disps from Cartesian to CdSalc coordinates.</span>
        <span class="c1"># For future convenience, we transpose.</span>
        <span class="c1"># Rows are gradients and columns are coordinates with respect to a particular CdSALC.</span>
        <span class="n">B_pi</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="s2">&quot;salc_list&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">matrix_irrep</span><span class="p">(</span><span class="n">h</span><span class="p">))</span>
        <span class="n">grads_adapted</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">B_pi</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="n">gradient_matrix</span><span class="p">)</span><span class="o">.</span><span class="n">T</span>

        <span class="k">if</span> <span class="n">data</span><span class="p">[</span><span class="s2">&quot;print_lvl&quot;</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="mi">3</span><span class="p">:</span>
            <span class="n">core</span><span class="o">.</span><span class="n">print_out</span><span class="p">(</span><span class="s2">&quot;Gradients in B-matrix coordinates</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">disp</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_disp</span><span class="p">):</span>
                <span class="n">core</span><span class="o">.</span><span class="n">print_out</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot; disp </span><span class="si">{</span><span class="n">disp</span><span class="si">}</span><span class="s2">: &quot;</span><span class="p">)</span>
                <span class="k">for</span> <span class="n">salc</span> <span class="ow">in</span> <span class="n">grads_adapted</span><span class="p">[</span><span class="n">disp</span><span class="p">]:</span>
                    <span class="n">core</span><span class="o">.</span><span class="n">print_out</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">salc</span><span class="si">:</span><span class="s2">15.10f</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
                <span class="n">core</span><span class="o">.</span><span class="n">print_out</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">)</span>

        <span class="n">H_pi</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">([</span><span class="n">Nindices</span><span class="p">,</span> <span class="n">Nindices</span><span class="p">]))</span>

        <span class="k">if</span> <span class="n">findifrec</span><span class="p">[</span><span class="s2">&quot;stencil_size&quot;</span><span class="p">]</span> <span class="o">==</span> <span class="mi">3</span><span class="p">:</span>
            <span class="n">H_pi</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">grads_adapted</span><span class="p">[</span><span class="mi">1</span><span class="p">::</span><span class="mi">2</span><span class="p">]</span> <span class="o">-</span> <span class="n">grads_adapted</span><span class="p">[::</span><span class="mi">2</span><span class="p">])</span> <span class="o">/</span> <span class="p">(</span><span class="mf">2.0</span> <span class="o">*</span> <span class="n">findifrec</span><span class="p">[</span><span class="s2">&quot;step&quot;</span><span class="p">][</span><span class="s2">&quot;size&quot;</span><span class="p">])</span>
        <span class="k">elif</span> <span class="n">findifrec</span><span class="p">[</span><span class="s2">&quot;stencil_size&quot;</span><span class="p">]</span> <span class="o">==</span> <span class="mi">5</span><span class="p">:</span>
            <span class="n">H_pi</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">grads_adapted</span><span class="p">[::</span><span class="mi">4</span><span class="p">]</span> <span class="o">-</span> <span class="mi">8</span> <span class="o">*</span> <span class="n">grads_adapted</span><span class="p">[</span><span class="mi">1</span><span class="p">::</span><span class="mi">4</span><span class="p">]</span> <span class="o">+</span> <span class="mi">8</span> <span class="o">*</span> <span class="n">grads_adapted</span><span class="p">[</span><span class="mi">2</span><span class="p">::</span><span class="mi">4</span><span class="p">]</span> <span class="o">-</span>
                        <span class="n">grads_adapted</span><span class="p">[</span><span class="mi">3</span><span class="p">::</span><span class="mi">4</span><span class="p">])</span> <span class="o">/</span> <span class="p">(</span><span class="mf">12.0</span> <span class="o">*</span> <span class="n">findifrec</span><span class="p">[</span><span class="s2">&quot;step&quot;</span><span class="p">][</span><span class="s2">&quot;size&quot;</span><span class="p">])</span>

        <span class="n">H_pi</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">_process_hessian_symmetry_block</span><span class="p">(</span><span class="n">H_pi</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="n">B_pi</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="n">massweighter</span><span class="p">,</span> <span class="n">irrep_lbls</span><span class="p">[</span><span class="n">h</span><span class="p">],</span> <span class="n">data</span><span class="p">[</span><span class="s2">&quot;print_lvl&quot;</span><span class="p">])</span>

    <span class="c1"># All blocks of the Hessian are now constructed!</span>
    <span class="k">return</span> <span class="n">_process_hessian</span><span class="p">(</span><span class="n">H_pi</span><span class="p">,</span> <span class="n">B_pi</span><span class="p">,</span> <span class="n">massweighter</span><span class="p">,</span> <span class="n">data</span><span class="p">[</span><span class="s2">&quot;print_lvl&quot;</span><span class="p">])</span>


<span class="k">def</span> <span class="nf">assemble_hessian_from_energies</span><span class="p">(</span><span class="n">findifrec</span><span class="p">:</span> <span class="n">Dict</span><span class="p">,</span> <span class="n">freq_irrep_only</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Compute the Hessian by finite difference of energies.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    findifrec</span>
<span class="sd">        Dictionary of finite difference data, specified in _geom_generator docstring.</span>
<span class="sd">    freq_irrep_only</span>
<span class="sd">        The 0-indexed Cotton ordered irrep to get frequencies for. Choose -1 for all irreps.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    hessian</span>
<span class="sd">        (3 * nat, 3 * nat) Cartesian Hessian [Eh/a0^2].</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c1"># This *must* be a Psi molecule at present - CdSalcList generation panics otherwise</span>
    <span class="n">mol</span> <span class="o">=</span> <span class="n">core</span><span class="o">.</span><span class="n">Molecule</span><span class="o">.</span><span class="n">from_schema</span><span class="p">(</span><span class="n">findifrec</span><span class="p">[</span><span class="s2">&quot;molecule&quot;</span><span class="p">],</span> <span class="n">nonphysical</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>

    <span class="n">displacements</span> <span class="o">=</span> <span class="n">findifrec</span><span class="p">[</span><span class="s2">&quot;displacements&quot;</span><span class="p">]</span>
    <span class="n">ref_energy</span> <span class="o">=</span> <span class="n">findifrec</span><span class="p">[</span><span class="s2">&quot;reference&quot;</span><span class="p">][</span><span class="s2">&quot;energy&quot;</span><span class="p">]</span>

    <span class="k">def</span> <span class="nf">init_string</span><span class="p">(</span><span class="n">data</span><span class="p">):</span>
        <span class="n">max_label_len</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="nb">max</span><span class="p">([</span><span class="nb">len</span><span class="p">(</span><span class="n">label</span><span class="p">)</span> <span class="k">for</span> <span class="n">label</span> <span class="ow">in</span> <span class="n">displacements</span><span class="p">],</span> <span class="n">default</span><span class="o">=</span><span class="mi">3</span><span class="p">))</span>
        <span class="n">out_str</span> <span class="o">=</span> <span class="s2">&quot;&quot;</span>
        <span class="k">for</span> <span class="n">label</span><span class="p">,</span> <span class="n">disp_data</span> <span class="ow">in</span> <span class="n">displacements</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="n">out_str</span> <span class="o">+=</span> <span class="p">(</span><span class="s2">&quot;    {:&quot;</span> <span class="o">+</span> <span class="n">max_label_len</span> <span class="o">+</span> <span class="s2">&quot;s} : </span><span class="si">{:20.10f}</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">label</span><span class="p">,</span> <span class="n">disp_data</span><span class="p">[</span><span class="s2">&quot;energy&quot;</span><span class="p">])</span>
        <span class="k">return</span> <span class="p">(</span><span class="s2">&quot;  Computing second-derivative from energies using projected, </span><span class="se">\n</span><span class="s2">&quot;</span>
                <span class="s2">&quot;  symmetry-adapted, cartesian coordinates.</span><span class="se">\n\n</span><span class="s2">&quot;</span>
                <span class="s2">&quot;  </span><span class="si">{:d}</span><span class="s2"> energies passed in, including the reference geometry.</span><span class="se">\n</span><span class="s2">&quot;</span>
                <span class="s2">&quot;    Using </span><span class="si">{:d}</span><span class="s2">-point formula.</span><span class="se">\n</span><span class="s2">&quot;</span>
                <span class="s2">&quot;    Energy without displacement: </span><span class="si">{:15.10f}</span><span class="se">\n</span><span class="s2">&quot;</span>
                <span class="s2">&quot;    Check energies below for precision!</span><span class="se">\n</span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                    <span class="nb">len</span><span class="p">(</span><span class="n">displacements</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">findifrec</span><span class="p">[</span><span class="s2">&quot;stencil_size&quot;</span><span class="p">],</span> <span class="n">ref_energy</span><span class="p">,</span> <span class="n">out_str</span><span class="p">))</span>

    <span class="n">data</span> <span class="o">=</span> <span class="n">_initialize_findif</span><span class="p">(</span><span class="n">mol</span><span class="p">,</span> <span class="n">freq_irrep_only</span><span class="p">,</span> <span class="s2">&quot;2_0&quot;</span><span class="p">,</span> <span class="n">findifrec</span><span class="p">[</span><span class="s1">&#39;stencil_size&#39;</span><span class="p">],</span> <span class="n">findifrec</span><span class="p">[</span><span class="s1">&#39;step&#39;</span><span class="p">][</span><span class="s1">&#39;size&#39;</span><span class="p">],</span>
                              <span class="n">init_string</span><span class="p">,</span> <span class="n">findifrec</span><span class="p">[</span><span class="s1">&#39;project_translations&#39;</span><span class="p">],</span> <span class="n">findifrec</span><span class="p">[</span><span class="s1">&#39;project_rotations&#39;</span><span class="p">],</span> <span class="kc">False</span><span class="p">)</span>

    <span class="n">massweighter</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">repeat</span><span class="p">([</span><span class="n">mol</span><span class="o">.</span><span class="n">mass</span><span class="p">(</span><span class="n">a</span><span class="p">)</span> <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="s2">&quot;n_atom&quot;</span><span class="p">])],</span> <span class="mi">3</span><span class="p">)</span><span class="o">**</span><span class="p">(</span><span class="o">-</span><span class="mf">0.5</span><span class="p">)</span>
    <span class="n">B_pi</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">H_pi</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">irrep_lbls</span> <span class="o">=</span> <span class="n">mol</span><span class="o">.</span><span class="n">irrep_labels</span><span class="p">()</span>
    <span class="n">max_disp</span> <span class="o">=</span> <span class="p">(</span><span class="n">findifrec</span><span class="p">[</span><span class="s2">&quot;stencil_size&quot;</span><span class="p">]</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">//</span> <span class="mi">2</span>
    <span class="n">e_per_diag</span> <span class="o">=</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">max_disp</span>

    <span class="c1"># Unlike in the gradient case, we have no symmetry transformations to worry about.</span>
    <span class="c1"># We get to the task directly: assembling the force constants in each irrep block.</span>
    <span class="k">for</span> <span class="n">h</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="s2">&quot;n_irrep&quot;</span><span class="p">]):</span>
        <span class="n">salc_indices</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="s2">&quot;salc_indices_pi&quot;</span><span class="p">][</span><span class="n">h</span><span class="p">]</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">salc_indices</span><span class="p">:</span> <span class="k">continue</span>

        <span class="n">n_salcs</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">salc_indices</span><span class="p">)</span>
        <span class="n">E</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="nb">len</span><span class="p">(</span><span class="n">salc_indices</span><span class="p">),</span> <span class="n">e_per_diag</span><span class="p">))</span>

        <span class="c1"># Step One: Diagonals</span>
        <span class="c1"># For asymmetric irreps, the energy at a + disp is the same as at a - disp</span>
        <span class="c1"># Just reuse the - disp energy for the + disp energy</span>

        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">salc_index</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">salc_indices</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">max_disp</span> <span class="o">+</span> <span class="mi">1</span><span class="p">):</span>
                <span class="n">E</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">max_disp</span> <span class="o">-</span> <span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">displacements</span><span class="p">[</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">salc_index</span><span class="si">}</span><span class="s2">: </span><span class="si">{</span><span class="o">-</span><span class="n">j</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">][</span><span class="s2">&quot;energy&quot;</span><span class="p">]</span>
                <span class="n">k</span> <span class="o">=</span> <span class="o">-</span><span class="n">j</span> <span class="k">if</span> <span class="n">h</span> <span class="k">else</span> <span class="n">j</span>  <span class="c1"># Because of the +- displacement trick</span>
                <span class="n">E</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">max_disp</span> <span class="o">+</span> <span class="n">j</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">displacements</span><span class="p">[</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">salc_index</span><span class="si">}</span><span class="s2">: </span><span class="si">{</span><span class="n">k</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">][</span><span class="s2">&quot;energy&quot;</span><span class="p">]</span>
        <span class="c1"># Now determine all diagonal force constants for this irrep.</span>
        <span class="k">if</span> <span class="n">findifrec</span><span class="p">[</span><span class="s2">&quot;stencil_size&quot;</span><span class="p">]</span> <span class="o">==</span> <span class="mi">3</span><span class="p">:</span>
            <span class="n">diag_fcs</span> <span class="o">=</span> <span class="n">E</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="n">E</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">]</span>
            <span class="n">diag_fcs</span> <span class="o">-=</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">ref_energy</span>
            <span class="n">diag_fcs</span> <span class="o">/=</span> <span class="p">(</span><span class="n">findifrec</span><span class="p">[</span><span class="s2">&quot;step&quot;</span><span class="p">][</span><span class="s2">&quot;size&quot;</span><span class="p">]</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">findifrec</span><span class="p">[</span><span class="s2">&quot;stencil_size&quot;</span><span class="p">]</span> <span class="o">==</span> <span class="mi">5</span><span class="p">:</span>
            <span class="n">diag_fcs</span> <span class="o">=</span> <span class="o">-</span><span class="n">E</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="mi">16</span> <span class="o">*</span> <span class="n">E</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="mi">16</span> <span class="o">*</span> <span class="n">E</span><span class="p">[:,</span> <span class="mi">2</span><span class="p">]</span> <span class="o">-</span> <span class="n">E</span><span class="p">[:,</span> <span class="mi">3</span><span class="p">]</span>
            <span class="n">diag_fcs</span> <span class="o">-=</span> <span class="mi">30</span> <span class="o">*</span> <span class="n">ref_energy</span>
            <span class="n">diag_fcs</span> <span class="o">/=</span> <span class="p">(</span><span class="mi">12</span> <span class="o">*</span> <span class="n">findifrec</span><span class="p">[</span><span class="s2">&quot;step&quot;</span><span class="p">][</span><span class="s2">&quot;size&quot;</span><span class="p">]</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>
        <span class="n">H_irr</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">diag</span><span class="p">(</span><span class="n">diag_fcs</span><span class="p">)</span>

        <span class="c1"># TODO: It&#39;s a bit ugly to use the salc indices to grab the off-diagonals but the indices</span>
        <span class="c1"># within the irrep to grab the diagonals. Is there a better way to do this?</span>

        <span class="c1"># Step Two: Off-diagonals</span>
        <span class="c1"># We need off-diagonal energies, diagonal energies, AND the reference energy</span>
        <span class="c1"># Grabbing off-diagonal energies is a pain, so once we know our SALCs...</span>
        <span class="c1"># ...define offdiag_en to do that for us.</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">salc</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">salc_indices</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">j</span><span class="p">,</span> <span class="n">salc2</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">salc_indices</span><span class="p">[:</span><span class="n">i</span><span class="p">]):</span>
                <span class="n">offdiag_en</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">index</span><span class="p">:</span> <span class="n">displacements</span><span class="p">[</span><span class="s2">&quot;</span><span class="si">{l}</span><span class="s2">: </span><span class="si">{}</span><span class="s2">, </span><span class="si">{k}</span><span class="s2">: </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                    <span class="n">k</span><span class="o">=</span><span class="n">salc</span><span class="p">,</span> <span class="n">l</span><span class="o">=</span><span class="n">salc2</span><span class="p">,</span> <span class="o">*</span><span class="n">data</span><span class="p">[</span><span class="s2">&quot;disps&quot;</span><span class="p">][</span><span class="s2">&quot;off&quot;</span><span class="p">][</span><span class="n">index</span><span class="p">])][</span><span class="s2">&quot;energy&quot;</span><span class="p">]</span>
                <span class="k">if</span> <span class="n">findifrec</span><span class="p">[</span><span class="s2">&quot;stencil_size&quot;</span><span class="p">]</span> <span class="o">==</span> <span class="mi">3</span><span class="p">:</span>
                    <span class="n">fc</span> <span class="o">=</span> <span class="p">(</span><span class="o">+</span><span class="n">offdiag_en</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span> <span class="o">+</span> <span class="n">offdiag_en</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="o">+</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">ref_energy</span> <span class="o">-</span> <span class="n">E</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="n">E</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">E</span><span class="p">[</span><span class="n">j</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span>
                          <span class="n">E</span><span class="p">[</span><span class="n">j</span><span class="p">][</span><span class="mi">1</span><span class="p">])</span> <span class="o">/</span> <span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">findifrec</span><span class="p">[</span><span class="s2">&quot;step&quot;</span><span class="p">][</span><span class="s2">&quot;size&quot;</span><span class="p">]</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>
                <span class="k">elif</span> <span class="n">findifrec</span><span class="p">[</span><span class="s2">&quot;stencil_size&quot;</span><span class="p">]</span> <span class="o">==</span> <span class="mi">5</span><span class="p">:</span>
                    <span class="n">fc</span> <span class="o">=</span> <span class="p">(</span><span class="o">-</span><span class="n">offdiag_en</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span> <span class="o">-</span> <span class="n">offdiag_en</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="o">+</span> <span class="mi">9</span> <span class="o">*</span> <span class="n">offdiag_en</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span> <span class="o">-</span> <span class="n">offdiag_en</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span> <span class="o">-</span> <span class="n">offdiag_en</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span> <span class="o">+</span>
                          <span class="mi">9</span> <span class="o">*</span> <span class="n">offdiag_en</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span> <span class="o">-</span> <span class="n">offdiag_en</span><span class="p">(</span><span class="mi">6</span><span class="p">)</span> <span class="o">-</span> <span class="n">offdiag_en</span><span class="p">(</span><span class="mi">7</span><span class="p">)</span> <span class="o">+</span> <span class="n">E</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="mi">7</span> <span class="o">*</span> <span class="n">E</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="mi">7</span> <span class="o">*</span> <span class="n">E</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">2</span><span class="p">]</span> <span class="o">+</span>
                          <span class="n">E</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">3</span><span class="p">]</span> <span class="o">+</span> <span class="n">E</span><span class="p">[</span><span class="n">j</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="mi">7</span> <span class="o">*</span> <span class="n">E</span><span class="p">[</span><span class="n">j</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="mi">7</span> <span class="o">*</span> <span class="n">E</span><span class="p">[</span><span class="n">j</span><span class="p">][</span><span class="mi">2</span><span class="p">]</span> <span class="o">+</span> <span class="n">E</span><span class="p">[</span><span class="n">j</span><span class="p">][</span><span class="mi">3</span><span class="p">]</span> <span class="o">+</span>
                          <span class="mi">12</span> <span class="o">*</span> <span class="n">ref_energy</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="mi">12</span> <span class="o">*</span> <span class="n">findifrec</span><span class="p">[</span><span class="s2">&quot;step&quot;</span><span class="p">][</span><span class="s2">&quot;size&quot;</span><span class="p">]</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>
                <span class="n">H_irr</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">fc</span>
                <span class="n">H_irr</span><span class="p">[</span><span class="n">j</span><span class="p">,</span> <span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">fc</span>

        <span class="n">B_pi</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="s2">&quot;salc_list&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">matrix_irrep</span><span class="p">(</span><span class="n">h</span><span class="p">))</span>
        <span class="n">H_pi</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">_process_hessian_symmetry_block</span><span class="p">(</span><span class="n">H_irr</span><span class="p">,</span> <span class="n">B_pi</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="n">massweighter</span><span class="p">,</span> <span class="n">irrep_lbls</span><span class="p">[</span><span class="n">h</span><span class="p">],</span> <span class="n">data</span><span class="p">[</span><span class="s2">&quot;print_lvl&quot;</span><span class="p">]))</span>

    <span class="c1"># All blocks of the Hessian are now constructed!</span>
    <span class="k">return</span> <span class="n">_process_hessian</span><span class="p">(</span><span class="n">H_pi</span><span class="p">,</span> <span class="n">B_pi</span><span class="p">,</span> <span class="n">massweighter</span><span class="p">,</span> <span class="n">data</span><span class="p">[</span><span class="s2">&quot;print_lvl&quot;</span><span class="p">])</span>


<div class="viewcode-block" id="FiniteDifferenceComputer"><a class="viewcode-back" href="../../../freq.html#psi4.driver.driver_findif.FiniteDifferenceComputer">[docs]</a><span class="k">class</span> <span class="nc">FiniteDifferenceComputer</span><span class="p">(</span><span class="n">BaseComputer</span><span class="p">):</span>

    <span class="n">molecule</span><span class="p">:</span> <span class="n">Any</span>
    <span class="n">driver</span><span class="p">:</span> <span class="n">DriverEnum</span>
    <span class="n">metameta</span><span class="p">:</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Any</span><span class="p">]</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="n">task_list</span><span class="p">:</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">BaseComputer</span><span class="p">]</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="n">findifrec</span><span class="p">:</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Any</span><span class="p">]</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="n">computer</span><span class="p">:</span> <span class="n">BaseComputer</span> <span class="o">=</span> <span class="n">AtomicComputer</span>
    <span class="n">method</span><span class="p">:</span> <span class="nb">str</span>

<div class="viewcode-block" id="FiniteDifferenceComputer.set_driver"><a class="viewcode-back" href="../../../freq.html#psi4.driver.driver_findif.FiniteDifferenceComputer.set_driver">[docs]</a>    <span class="nd">@validator</span><span class="p">(</span><span class="s1">&#39;driver&#39;</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">set_driver</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">driver</span><span class="p">):</span>
        <span class="n">egh</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;energy&#39;</span><span class="p">,</span> <span class="s1">&#39;gradient&#39;</span><span class="p">,</span> <span class="s1">&#39;hessian&#39;</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">driver</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">egh</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">ValidationError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;&quot;&quot;Wrapper is unhappy to be calling function (</span><span class="si">{</span><span class="n">driver</span><span class="si">}</span><span class="s2">) not among </span><span class="si">{</span><span class="n">egh</span><span class="si">}</span><span class="s2">.&quot;&quot;&quot;</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">driver</span></div>

<div class="viewcode-block" id="FiniteDifferenceComputer.set_molecule"><a class="viewcode-back" href="../../../freq.html#psi4.driver.driver_findif.FiniteDifferenceComputer.set_molecule">[docs]</a>    <span class="nd">@validator</span><span class="p">(</span><span class="s1">&#39;molecule&#39;</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">set_molecule</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">mol</span><span class="p">):</span>
        <span class="n">mol</span><span class="o">.</span><span class="n">update_geometry</span><span class="p">()</span>
        <span class="n">mol</span><span class="o">.</span><span class="n">fix_com</span><span class="p">(</span><span class="kc">True</span><span class="p">)</span>
        <span class="n">mol</span><span class="o">.</span><span class="n">fix_orientation</span><span class="p">(</span><span class="kc">True</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">mol</span></div>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">**</span><span class="n">data</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Initialize FiniteDifference class.</span>

<span class="sd">        data keywords include</span>
<span class="sd">        * general AtomicInput keys like molecule, driver, method, basis, and keywords.</span>
<span class="sd">        * specialized findif keys like findif_mode, findif_irrep, and those converted from keywords to kwargs:</span>
<span class="sd">          findif_stencil_size, findif_step_size, and findif_verbose.</span>
<span class="sd">        * TODO hangers-on keys present at class initiation get automatically attached to class since `extra = &quot;allow&quot;` but should be pruned</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">findif_stencil_size</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s1">&#39;findif_stencil_size&#39;</span><span class="p">)</span>
        <span class="n">findif_step_size</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s1">&#39;findif_step_size&#39;</span><span class="p">)</span>

        <span class="n">BaseComputer</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">**</span><span class="n">data</span><span class="p">)</span>

        <span class="n">translations_projection_sound</span> <span class="o">=</span> <span class="p">(</span><span class="ow">not</span> <span class="s2">&quot;external_potentials&quot;</span> <span class="ow">in</span> <span class="n">data</span><span class="p">[</span><span class="s1">&#39;keywords&#39;</span><span class="p">][</span><span class="s1">&#39;function_kwargs&#39;</span><span class="p">]</span>
                                         <span class="ow">and</span> <span class="ow">not</span> <span class="n">core</span><span class="o">.</span><span class="n">get_option</span><span class="p">(</span><span class="s1">&#39;SCF&#39;</span><span class="p">,</span> <span class="s1">&#39;PERTURB_H&#39;</span><span class="p">)</span>
                                         <span class="ow">and</span> <span class="ow">not</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">molecule</span><span class="p">,</span> <span class="s1">&#39;EFP&#39;</span><span class="p">))</span>
        <span class="k">if</span> <span class="s1">&#39;ref_gradient&#39;</span> <span class="ow">in</span> <span class="n">data</span><span class="p">:</span>
            <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;&quot;&quot;hessian() using ref_gradient to assess stationary point.&quot;&quot;&quot;</span><span class="p">)</span>
            <span class="n">stationary_criterion</span> <span class="o">=</span> <span class="mf">1.e-2</span>  <span class="c1"># pulled out of a hat</span>
            <span class="n">stationary_point</span> <span class="o">=</span> <span class="n">_rms</span><span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="s1">&#39;ref_gradient&#39;</span><span class="p">])</span> <span class="o">&lt;</span> <span class="n">stationary_criterion</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">stationary_point</span> <span class="o">=</span> <span class="kc">False</span>  <span class="c1"># unknown, so F to be safe</span>
        <span class="n">rotations_projection_sound_grad</span> <span class="o">=</span> <span class="n">translations_projection_sound</span>
        <span class="n">rotations_projection_sound_hess</span> <span class="o">=</span> <span class="n">translations_projection_sound</span> <span class="ow">and</span> <span class="n">stationary_point</span>
        <span class="k">if</span> <span class="n">core</span><span class="o">.</span><span class="n">has_option_changed</span><span class="p">(</span><span class="s1">&#39;FINDIF&#39;</span><span class="p">,</span> <span class="s1">&#39;FD_PROJECT&#39;</span><span class="p">):</span>
            <span class="n">r_project_grad</span> <span class="o">=</span> <span class="n">core</span><span class="o">.</span><span class="n">get_option</span><span class="p">(</span><span class="s1">&#39;FINDIF&#39;</span><span class="p">,</span> <span class="s1">&#39;FD_PROJECT&#39;</span><span class="p">)</span>
            <span class="n">r_project_hess</span> <span class="o">=</span> <span class="n">core</span><span class="o">.</span><span class="n">get_option</span><span class="p">(</span><span class="s1">&#39;FINDIF&#39;</span><span class="p">,</span> <span class="s1">&#39;FD_PROJECT&#39;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">r_project_grad</span> <span class="o">=</span> <span class="n">rotations_projection_sound_grad</span>
            <span class="n">r_project_hess</span> <span class="o">=</span> <span class="n">rotations_projection_sound_hess</span>

        <span class="k">for</span> <span class="n">kwg</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;dft_functional&#39;</span><span class="p">]:</span>
            <span class="k">if</span> <span class="n">kwg</span> <span class="ow">in</span> <span class="n">data</span><span class="p">:</span>
                <span class="n">data</span><span class="p">[</span><span class="s1">&#39;keywords&#39;</span><span class="p">][</span><span class="s1">&#39;function_kwargs&#39;</span><span class="p">][</span><span class="n">kwg</span><span class="p">]</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="n">kwg</span><span class="p">)</span>
        <span class="c1"># I have the feeling the keywords.function_kwargs should be all left over in data</span>
        <span class="c1">#   after the findif control ones are removed, not this by-name procedure</span>
        <span class="n">data</span><span class="p">[</span><span class="s1">&#39;keywords&#39;</span><span class="p">][</span><span class="s1">&#39;PARENT_SYMMETRY&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">molecule</span><span class="o">.</span><span class="n">point_group</span><span class="p">()</span><span class="o">.</span><span class="n">full_name</span><span class="p">()</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">method</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="s1">&#39;method&#39;</span><span class="p">]</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">metameta</span><span class="p">[</span><span class="s1">&#39;mode&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="s1">&#39;findif_mode&#39;</span><span class="p">][</span><span class="mi">0</span><span class="p">])</span> <span class="o">+</span> <span class="s1">&#39;_&#39;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="s1">&#39;findif_mode&#39;</span><span class="p">][</span><span class="mi">1</span><span class="p">])</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">metameta</span><span class="p">[</span><span class="s1">&#39;irrep&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s1">&#39;findif_irrep&#39;</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">metameta</span><span class="p">[</span><span class="s1">&#39;mode&#39;</span><span class="p">]</span> <span class="o">==</span> <span class="s1">&#39;1_0&#39;</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">metameta</span><span class="p">[</span><span class="s1">&#39;proxy_driver&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="s1">&#39;energy&#39;</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">findifrec</span> <span class="o">=</span> <span class="n">gradient_from_energies_geometries</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">molecule</span><span class="p">,</span>
                                                               <span class="n">stencil_size</span><span class="o">=</span><span class="n">findif_stencil_size</span><span class="p">,</span>
                                                               <span class="n">step_size</span><span class="o">=</span><span class="n">findif_step_size</span><span class="p">,</span>
                                                               <span class="n">t_project</span><span class="o">=</span><span class="n">translations_projection_sound</span><span class="p">,</span>
                                                               <span class="n">r_project</span><span class="o">=</span><span class="n">r_project_grad</span><span class="p">)</span>

        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">metameta</span><span class="p">[</span><span class="s1">&#39;mode&#39;</span><span class="p">]</span> <span class="o">==</span> <span class="s1">&#39;2_1&#39;</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">metameta</span><span class="p">[</span><span class="s1">&#39;proxy_driver&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="s1">&#39;gradient&#39;</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">findifrec</span> <span class="o">=</span> <span class="n">hessian_from_gradients_geometries</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">molecule</span><span class="p">,</span>
                                                               <span class="n">freq_irrep_only</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">metameta</span><span class="p">[</span><span class="s1">&#39;irrep&#39;</span><span class="p">],</span>
                                                               <span class="n">stencil_size</span><span class="o">=</span><span class="n">findif_stencil_size</span><span class="p">,</span>
                                                               <span class="n">step_size</span><span class="o">=</span><span class="n">findif_step_size</span><span class="p">,</span>
                                                               <span class="n">t_project</span><span class="o">=</span><span class="n">translations_projection_sound</span><span class="p">,</span>
                                                               <span class="n">r_project</span><span class="o">=</span><span class="n">r_project_hess</span><span class="p">)</span>

        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">metameta</span><span class="p">[</span><span class="s1">&#39;mode&#39;</span><span class="p">]</span> <span class="o">==</span> <span class="s1">&#39;2_0&#39;</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">metameta</span><span class="p">[</span><span class="s1">&#39;proxy_driver&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="s1">&#39;energy&#39;</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">findifrec</span> <span class="o">=</span> <span class="n">hessian_from_energies_geometries</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">molecule</span><span class="p">,</span>
                                                              <span class="n">freq_irrep_only</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">metameta</span><span class="p">[</span><span class="s1">&#39;irrep&#39;</span><span class="p">],</span>
                                                              <span class="n">stencil_size</span><span class="o">=</span><span class="n">findif_stencil_size</span><span class="p">,</span>
                                                              <span class="n">step_size</span><span class="o">=</span><span class="n">findif_step_size</span><span class="p">,</span>
                                                              <span class="n">t_project</span><span class="o">=</span><span class="n">translations_projection_sound</span><span class="p">,</span>
                                                              <span class="n">r_project</span><span class="o">=</span><span class="n">r_project_hess</span><span class="p">)</span>

        <span class="n">ndisp</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">findifrec</span><span class="p">[</span><span class="s2">&quot;displacements&quot;</span><span class="p">])</span> <span class="o">+</span> <span class="mi">1</span>
        <span class="n">info</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;&quot;&quot; </span><span class="si">{</span><span class="n">ndisp</span><span class="si">}</span><span class="s2"> displacements needed ...</span><span class="se">\n</span><span class="s2">&quot;&quot;&quot;</span>
        <span class="n">core</span><span class="o">.</span><span class="n">print_out</span><span class="p">(</span><span class="n">info</span><span class="p">)</span>
        <span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="n">info</span><span class="p">)</span>

        <span class="c1"># var_dict = core.variables()</span>
        <span class="n">packet</span> <span class="o">=</span> <span class="p">{</span>
            <span class="s2">&quot;molecule&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">molecule</span><span class="p">,</span>
            <span class="s2">&quot;driver&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">metameta</span><span class="p">[</span><span class="s1">&#39;proxy_driver&#39;</span><span class="p">],</span>
            <span class="s2">&quot;method&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">method</span><span class="p">,</span>
            <span class="s2">&quot;basis&quot;</span><span class="p">:</span> <span class="n">data</span><span class="p">[</span><span class="s2">&quot;basis&quot;</span><span class="p">],</span>
            <span class="s2">&quot;keywords&quot;</span><span class="p">:</span> <span class="n">data</span><span class="p">[</span><span class="s2">&quot;keywords&quot;</span><span class="p">]</span> <span class="ow">or</span> <span class="p">{},</span>
        <span class="p">}</span>
        <span class="k">if</span> <span class="s1">&#39;cbs_metadata&#39;</span> <span class="ow">in</span> <span class="n">data</span><span class="p">:</span>
            <span class="n">packet</span><span class="p">[</span><span class="s1">&#39;cbs_metadata&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="s1">&#39;cbs_metadata&#39;</span><span class="p">]</span>
        <span class="n">passalong</span> <span class="o">=</span> <span class="p">{</span><span class="n">k</span><span class="p">:</span> <span class="n">v</span> <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">data</span><span class="o">.</span><span class="n">items</span><span class="p">()</span> <span class="k">if</span> <span class="n">k</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">packet</span><span class="p">}</span>
        <span class="n">passalong</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s1">&#39;ptype&#39;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">task_list</span><span class="p">[</span><span class="s2">&quot;reference&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">computer</span><span class="p">(</span><span class="o">**</span><span class="n">packet</span><span class="p">,</span> <span class="o">**</span><span class="n">passalong</span><span class="p">)</span>

        <span class="n">parent_group</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">molecule</span><span class="o">.</span><span class="n">point_group</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">label</span><span class="p">,</span> <span class="n">displacement</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">findifrec</span><span class="p">[</span><span class="s2">&quot;displacements&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="n">clone</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">molecule</span><span class="o">.</span><span class="n">clone</span><span class="p">()</span>
            <span class="n">clone</span><span class="o">.</span><span class="n">reinterpret_coordentry</span><span class="p">(</span><span class="kc">False</span><span class="p">)</span>
            <span class="c1">#clone.fix_orientation(True)</span>

            <span class="c1"># Load in displacement into the active molecule</span>
            <span class="n">clone</span><span class="o">.</span><span class="n">set_geometry</span><span class="p">(</span><span class="n">core</span><span class="o">.</span><span class="n">Matrix</span><span class="o">.</span><span class="n">from_array</span><span class="p">(</span><span class="n">displacement</span><span class="p">[</span><span class="s2">&quot;geometry&quot;</span><span class="p">]))</span>

            <span class="c1"># If the user insists on symmetry, weaken it if some is lost when displacing.</span>
            <span class="c1"># or &#39;fix_symmetry&#39; in self.findifrec.molecule</span>
            <span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;SYMM </span><span class="si">{</span><span class="n">clone</span><span class="o">.</span><span class="n">schoenflies_symbol</span><span class="p">()</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">molecule</span><span class="o">.</span><span class="n">symmetry_from_input</span><span class="p">():</span>
                <span class="n">disp_group</span> <span class="o">=</span> <span class="n">clone</span><span class="o">.</span><span class="n">find_highest_point_group</span><span class="p">()</span>
                <span class="n">new_bits</span> <span class="o">=</span> <span class="n">parent_group</span><span class="o">.</span><span class="n">bits</span><span class="p">()</span> <span class="o">&amp;</span> <span class="n">disp_group</span><span class="o">.</span><span class="n">bits</span><span class="p">()</span>
                <span class="n">new_symm_string</span> <span class="o">=</span> <span class="n">qcdb</span><span class="o">.</span><span class="n">PointGroup</span><span class="o">.</span><span class="n">bits_to_full_name</span><span class="p">(</span><span class="n">new_bits</span><span class="p">)</span>
                <span class="n">clone</span><span class="o">.</span><span class="n">reset_point_group</span><span class="p">(</span><span class="n">new_symm_string</span><span class="p">)</span>

            <span class="n">packet</span> <span class="o">=</span> <span class="p">{</span>
                <span class="s2">&quot;molecule&quot;</span><span class="p">:</span> <span class="n">clone</span><span class="p">,</span>
                <span class="s2">&quot;driver&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">metameta</span><span class="p">[</span><span class="s1">&#39;proxy_driver&#39;</span><span class="p">],</span>
                <span class="s2">&quot;method&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">method</span><span class="p">,</span>
                <span class="s2">&quot;basis&quot;</span><span class="p">:</span> <span class="n">data</span><span class="p">[</span><span class="s2">&quot;basis&quot;</span><span class="p">],</span>
                <span class="s2">&quot;keywords&quot;</span><span class="p">:</span> <span class="n">data</span><span class="p">[</span><span class="s2">&quot;keywords&quot;</span><span class="p">]</span> <span class="ow">or</span> <span class="p">{},</span>
            <span class="p">}</span>
            <span class="c1"># Displacements can run in lower symmetry. Don&#39;t overwrite orbitals from reference geom</span>
            <span class="n">packet</span><span class="p">[</span><span class="s1">&#39;keywords&#39;</span><span class="p">][</span><span class="s1">&#39;function_kwargs&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">update</span><span class="p">({</span><span class="s2">&quot;write_orbitals&quot;</span><span class="p">:</span> <span class="kc">False</span><span class="p">})</span>
            <span class="k">if</span> <span class="s1">&#39;cbs_metadata&#39;</span> <span class="ow">in</span> <span class="n">data</span><span class="p">:</span>
                <span class="n">packet</span><span class="p">[</span><span class="s1">&#39;cbs_metadata&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="s1">&#39;cbs_metadata&#39;</span><span class="p">]</span>

            <span class="bp">self</span><span class="o">.</span><span class="n">task_list</span><span class="p">[</span><span class="n">label</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">computer</span><span class="p">(</span><span class="o">**</span><span class="n">packet</span><span class="p">,</span> <span class="o">**</span><span class="n">passalong</span><span class="p">)</span>


<span class="c1">#        for n, displacement in enumerate(findif_meta_dict[&quot;displacements&quot;].values(), start=2):</span>
<span class="c1">#            _process_displacement(energy, lowername, molecule, displacement, n, ndisp, write_orbitals=False, **kwargs)</span>

<div class="viewcode-block" id="FiniteDifferenceComputer.build_tasks"><a class="viewcode-back" href="../../../freq.html#psi4.driver.driver_findif.FiniteDifferenceComputer.build_tasks">[docs]</a>    <span class="k">def</span> <span class="nf">build_tasks</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">obj</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="c1"># permanently a dummy function</span>
        <span class="k">pass</span></div>

<div class="viewcode-block" id="FiniteDifferenceComputer.plan"><a class="viewcode-back" href="../../../freq.html#psi4.driver.driver_findif.FiniteDifferenceComputer.plan">[docs]</a>    <span class="k">def</span> <span class="nf">plan</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="c1"># uncalled function</span>
        <span class="k">return</span> <span class="p">[</span><span class="n">t</span><span class="o">.</span><span class="n">plan</span><span class="p">()</span> <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">task_list</span><span class="o">.</span><span class="n">values</span><span class="p">()]</span></div>

<div class="viewcode-block" id="FiniteDifferenceComputer.compute"><a class="viewcode-back" href="../../../freq.html#psi4.driver.driver_findif.FiniteDifferenceComputer.compute">[docs]</a>    <span class="k">def</span> <span class="nf">compute</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">client</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="s2">&quot;qcportal.FractalClient&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Run each job in task list.&quot;&quot;&quot;</span>
        <span class="n">instructions</span> <span class="o">=</span> <span class="s2">&quot;</span><span class="se">\n</span><span class="s2">&quot;</span> <span class="o">+</span> <span class="n">p4util</span><span class="o">.</span><span class="n">banner</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot; FiniteDifference Computations&quot;</span><span class="p">,</span> <span class="n">strNotOutfile</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span> <span class="o">+</span> <span class="s2">&quot;</span><span class="se">\n</span><span class="s2">&quot;</span>
        <span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="n">instructions</span><span class="p">)</span>
        <span class="n">core</span><span class="o">.</span><span class="n">print_out</span><span class="p">(</span><span class="n">instructions</span><span class="p">)</span>

        <span class="k">with</span> <span class="n">p4util</span><span class="o">.</span><span class="n">hold_options_state</span><span class="p">():</span>
            <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">task_list</span><span class="o">.</span><span class="n">values</span><span class="p">():</span>
                <span class="n">t</span><span class="o">.</span><span class="n">compute</span><span class="p">(</span><span class="n">client</span><span class="o">=</span><span class="n">client</span><span class="p">)</span></div>

    <span class="k">def</span> <span class="nf">_prepare_results</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">client</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="s2">&quot;qcportal.FractalClient&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">):</span>
        <span class="n">results_list</span> <span class="o">=</span> <span class="p">{</span><span class="n">k</span><span class="p">:</span> <span class="n">v</span><span class="o">.</span><span class="n">get_results</span><span class="p">(</span><span class="n">client</span><span class="o">=</span><span class="n">client</span><span class="p">)</span> <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">task_list</span><span class="o">.</span><span class="n">items</span><span class="p">()}</span>

        <span class="c1"># load AtomicComputer results into findifrec[reference]</span>
        <span class="n">reference</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">findifrec</span><span class="p">[</span><span class="s2">&quot;reference&quot;</span><span class="p">]</span>
        <span class="n">task</span> <span class="o">=</span> <span class="n">results_list</span><span class="p">[</span><span class="s2">&quot;reference&quot;</span><span class="p">]</span>
        <span class="n">response</span> <span class="o">=</span> <span class="n">task</span><span class="o">.</span><span class="n">return_result</span>
        <span class="n">reference</span><span class="p">[</span><span class="s2">&quot;module&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">task</span><span class="o">.</span><span class="n">provenance</span><span class="p">,</span> <span class="s2">&quot;module&quot;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">task</span><span class="o">.</span><span class="n">driver</span> <span class="o">==</span> <span class="s1">&#39;energy&#39;</span><span class="p">:</span>
            <span class="n">reference</span><span class="p">[</span><span class="s1">&#39;energy&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">response</span>

        <span class="k">elif</span> <span class="n">task</span><span class="o">.</span><span class="n">driver</span> <span class="o">==</span> <span class="s1">&#39;gradient&#39;</span><span class="p">:</span>
            <span class="n">reference</span><span class="p">[</span><span class="s1">&#39;gradient&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">response</span>
            <span class="n">reference</span><span class="p">[</span><span class="s1">&#39;energy&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">task</span><span class="o">.</span><span class="n">extras</span><span class="p">[</span><span class="s1">&#39;qcvars&#39;</span><span class="p">][</span><span class="s1">&#39;CURRENT ENERGY&#39;</span><span class="p">]</span>

        <span class="k">elif</span> <span class="n">task</span><span class="o">.</span><span class="n">driver</span> <span class="o">==</span> <span class="s1">&#39;hessian&#39;</span><span class="p">:</span>
            <span class="n">reference</span><span class="p">[</span><span class="s1">&#39;hessian&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">response</span>
            <span class="n">reference</span><span class="p">[</span><span class="s1">&#39;energy&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">task</span><span class="o">.</span><span class="n">extras</span><span class="p">[</span><span class="s1">&#39;qcvars&#39;</span><span class="p">][</span><span class="s1">&#39;CURRENT ENERGY&#39;</span><span class="p">]</span>
            <span class="k">if</span> <span class="s1">&#39;CURRENT GRADIENT&#39;</span> <span class="ow">in</span> <span class="n">task</span><span class="o">.</span><span class="n">extras</span><span class="p">[</span><span class="s1">&#39;qcvars&#39;</span><span class="p">]:</span>
                <span class="n">reference</span><span class="p">[</span><span class="s1">&#39;gradient&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">task</span><span class="o">.</span><span class="n">extras</span><span class="p">[</span><span class="s1">&#39;qcvars&#39;</span><span class="p">][</span><span class="s1">&#39;CURRENT GRADIENT&#39;</span><span class="p">]</span>

        <span class="n">dipole_available</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="k">if</span> <span class="s1">&#39;CURRENT DIPOLE&#39;</span> <span class="ow">in</span> <span class="n">task</span><span class="o">.</span><span class="n">extras</span><span class="p">[</span><span class="s1">&#39;qcvars&#39;</span><span class="p">]:</span>
            <span class="n">reference</span><span class="p">[</span><span class="s1">&#39;dipole&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">task</span><span class="o">.</span><span class="n">extras</span><span class="p">[</span><span class="s1">&#39;qcvars&#39;</span><span class="p">][</span><span class="s1">&#39;CURRENT DIPOLE&#39;</span><span class="p">]</span>
            <span class="n">dipole_available</span> <span class="o">=</span> <span class="kc">True</span>

        <span class="c1"># load AtomicComputer results into findifrec[displacements]</span>
        <span class="k">for</span> <span class="n">label</span><span class="p">,</span> <span class="n">displacement</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">findifrec</span><span class="p">[</span><span class="s2">&quot;displacements&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="n">task</span> <span class="o">=</span> <span class="n">results_list</span><span class="p">[</span><span class="n">label</span><span class="p">]</span>
            <span class="n">response</span> <span class="o">=</span> <span class="n">task</span><span class="o">.</span><span class="n">return_result</span>

            <span class="k">if</span> <span class="n">task</span><span class="o">.</span><span class="n">driver</span> <span class="o">==</span> <span class="s1">&#39;energy&#39;</span><span class="p">:</span>
                <span class="n">displacement</span><span class="p">[</span><span class="s1">&#39;energy&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">response</span>

            <span class="k">elif</span> <span class="n">task</span><span class="o">.</span><span class="n">driver</span> <span class="o">==</span> <span class="s1">&#39;gradient&#39;</span><span class="p">:</span>
                <span class="n">displacement</span><span class="p">[</span><span class="s1">&#39;gradient&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">response</span>
                <span class="n">displacement</span><span class="p">[</span><span class="s1">&#39;energy&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">task</span><span class="o">.</span><span class="n">extras</span><span class="p">[</span><span class="s1">&#39;qcvars&#39;</span><span class="p">][</span><span class="s1">&#39;CURRENT ENERGY&#39;</span><span class="p">]</span>

            <span class="k">elif</span> <span class="n">task</span><span class="o">.</span><span class="n">driver</span> <span class="o">==</span> <span class="s1">&#39;hessian&#39;</span><span class="p">:</span>
                <span class="n">displacement</span><span class="p">[</span><span class="s1">&#39;hessian&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">response</span>
                <span class="n">displacement</span><span class="p">[</span><span class="s1">&#39;energy&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">task</span><span class="o">.</span><span class="n">extras</span><span class="p">[</span><span class="s1">&#39;qcvars&#39;</span><span class="p">][</span><span class="s1">&#39;CURRENT ENERGY&#39;</span><span class="p">]</span>
                <span class="k">if</span> <span class="s1">&#39;CURRENT GRADIENT&#39;</span> <span class="ow">in</span> <span class="n">task</span><span class="o">.</span><span class="n">extras</span><span class="p">[</span><span class="s1">&#39;qcvars&#39;</span><span class="p">]:</span>
                    <span class="n">displacement</span><span class="p">[</span><span class="s1">&#39;gradient&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">task</span><span class="o">.</span><span class="n">extras</span><span class="p">[</span><span class="s1">&#39;qcvars&#39;</span><span class="p">][</span><span class="s1">&#39;CURRENT GRADIENT&#39;</span><span class="p">]</span>

            <span class="k">if</span> <span class="s1">&#39;CURRENT DIPOLE&#39;</span> <span class="ow">in</span> <span class="n">task</span><span class="o">.</span><span class="n">extras</span><span class="p">[</span><span class="s1">&#39;qcvars&#39;</span><span class="p">]:</span>
                <span class="n">displacement</span><span class="p">[</span><span class="s1">&#39;dipole&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">task</span><span class="o">.</span><span class="n">extras</span><span class="p">[</span><span class="s1">&#39;qcvars&#39;</span><span class="p">][</span><span class="s1">&#39;CURRENT DIPOLE&#39;</span><span class="p">]</span>

        <span class="c1"># apply finite difference formulas and load derivatives into findifrec[reference]</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">metameta</span><span class="p">[</span><span class="s1">&#39;mode&#39;</span><span class="p">]</span> <span class="o">==</span> <span class="s1">&#39;1_0&#39;</span><span class="p">:</span>
            <span class="n">G0</span> <span class="o">=</span> <span class="n">assemble_gradient_from_energies</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">findifrec</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">findifrec</span><span class="p">[</span><span class="s2">&quot;reference&quot;</span><span class="p">][</span><span class="bp">self</span><span class="o">.</span><span class="n">driver</span><span class="o">.</span><span class="n">name</span><span class="p">]</span> <span class="o">=</span> <span class="n">G0</span>

        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">metameta</span><span class="p">[</span><span class="s1">&#39;mode&#39;</span><span class="p">]</span> <span class="o">==</span> <span class="s1">&#39;2_1&#39;</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">dipole_available</span><span class="p">:</span>
                <span class="n">DD0</span> <span class="o">=</span> <span class="n">assemble_dipder_from_dipoles</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">findifrec</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">metameta</span><span class="p">[</span><span class="s1">&#39;irrep&#39;</span><span class="p">])</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">findifrec</span><span class="p">[</span><span class="s2">&quot;reference&quot;</span><span class="p">][</span><span class="s2">&quot;dipole derivative&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">DD0</span>

            <span class="n">H0</span> <span class="o">=</span> <span class="n">assemble_hessian_from_gradients</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">findifrec</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">metameta</span><span class="p">[</span><span class="s1">&#39;irrep&#39;</span><span class="p">])</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">findifrec</span><span class="p">[</span><span class="s2">&quot;reference&quot;</span><span class="p">][</span><span class="bp">self</span><span class="o">.</span><span class="n">driver</span><span class="o">.</span><span class="n">name</span><span class="p">]</span> <span class="o">=</span> <span class="n">H0</span>

        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">metameta</span><span class="p">[</span><span class="s1">&#39;mode&#39;</span><span class="p">]</span> <span class="o">==</span> <span class="s1">&#39;2_0&#39;</span><span class="p">:</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">G0</span> <span class="o">=</span> <span class="n">assemble_gradient_from_energies</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">findifrec</span><span class="p">)</span>
            <span class="k">except</span> <span class="ne">KeyError</span><span class="p">:</span>
                <span class="n">core</span><span class="o">.</span><span class="n">print_out</span><span class="p">(</span><span class="s2">&quot;Unable to construct reference gradient from Hessian displacements.&quot;</span><span class="p">)</span>
                <span class="c1"># TODO: this happens properly when the requested symmetry block</span>
                <span class="c1">#  of displacements don&#39;t have the totally symmetric displacements</span>
                <span class="c1">#  needed for gradient. For both this case</span>
                <span class="c1">#  and distributed computing are-we-there-yet? queries,</span>
                <span class="c1">#  should have a probe as to whether all the</span>
                <span class="c1">#  findif[displacement] labels are present and whether</span>
                <span class="c1">#  all the findif[displacement][energy-or-gradient] values</span>
                <span class="c1">#  are ready. Not sure what type of error/query is best,</span>
                <span class="c1">#  so deferring for now. Also, possibly need to check if</span>
                <span class="c1">#  step size matches before using values from one findifrec</span>
                <span class="c1">#  to construct another quantity.</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">findifrec</span><span class="p">[</span><span class="s2">&quot;reference&quot;</span><span class="p">][</span><span class="s2">&quot;gradient&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">G0</span>

            <span class="k">if</span> <span class="n">dipole_available</span><span class="p">:</span>
                <span class="n">DD0</span> <span class="o">=</span> <span class="n">assemble_dipder_from_dipoles</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">findifrec</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">metameta</span><span class="p">[</span><span class="s1">&#39;irrep&#39;</span><span class="p">])</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">findifrec</span><span class="p">[</span><span class="s2">&quot;reference&quot;</span><span class="p">][</span><span class="s2">&quot;dipole derivative&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">DD0</span>

            <span class="n">H0</span> <span class="o">=</span> <span class="n">assemble_hessian_from_energies</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">findifrec</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">metameta</span><span class="p">[</span><span class="s1">&#39;irrep&#39;</span><span class="p">])</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">findifrec</span><span class="p">[</span><span class="s2">&quot;reference&quot;</span><span class="p">][</span><span class="bp">self</span><span class="o">.</span><span class="n">driver</span><span class="o">.</span><span class="n">name</span><span class="p">]</span> <span class="o">=</span> <span class="n">H0</span>

<div class="viewcode-block" id="FiniteDifferenceComputer.get_results"><a class="viewcode-back" href="../../../freq.html#psi4.driver.driver_findif.FiniteDifferenceComputer.get_results">[docs]</a>    <span class="k">def</span> <span class="nf">get_results</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">client</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="s2">&quot;qcportal.FractalClient&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">AtomicResult</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Return results as FiniteDifference-flavored QCSchema.&quot;&quot;&quot;</span>

        <span class="n">instructions</span> <span class="o">=</span> <span class="s2">&quot;</span><span class="se">\n</span><span class="s2">&quot;</span> <span class="o">+</span> <span class="n">p4util</span><span class="o">.</span><span class="n">banner</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot; FiniteDifference Results&quot;</span><span class="p">,</span> <span class="n">strNotOutfile</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span> <span class="o">+</span> <span class="s2">&quot;</span><span class="se">\n</span><span class="s2">&quot;</span>
        <span class="n">core</span><span class="o">.</span><span class="n">print_out</span><span class="p">(</span><span class="n">instructions</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_prepare_results</span><span class="p">(</span><span class="n">client</span><span class="o">=</span><span class="n">client</span><span class="p">)</span>  <span class="c1"># assembled_results</span>

        <span class="c1"># load QCVariables &amp; properties</span>
        <span class="n">qcvars</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">task_list</span><span class="p">[</span><span class="s1">&#39;reference&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">get_results</span><span class="p">()</span><span class="o">.</span><span class="n">extras</span><span class="p">[</span><span class="s1">&#39;qcvars&#39;</span><span class="p">]</span>
        <span class="n">E0</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">findifrec</span><span class="p">[</span><span class="s1">&#39;reference&#39;</span><span class="p">][</span><span class="s1">&#39;energy&#39;</span><span class="p">]</span>

        <span class="n">properties</span> <span class="o">=</span> <span class="p">{</span>
            <span class="s2">&quot;calcinfo_natom&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">molecule</span><span class="o">.</span><span class="n">natom</span><span class="p">(),</span>
            <span class="s2">&quot;nuclear_repulsion_energy&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">molecule</span><span class="o">.</span><span class="n">nuclear_repulsion_energy</span><span class="p">(),</span>
            <span class="s2">&quot;return_energy&quot;</span><span class="p">:</span> <span class="n">E0</span><span class="p">,</span>
        <span class="p">}</span>

        <span class="n">qcvars</span><span class="p">[</span><span class="s1">&#39;FINDIF NUMBER&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">task_list</span><span class="p">)</span>
        <span class="n">qcvars</span><span class="p">[</span><span class="s1">&#39;NUCLEAR REPULSION ENERGY&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">molecule</span><span class="o">.</span><span class="n">nuclear_repulsion_energy</span><span class="p">()</span>
        <span class="n">qcvars</span><span class="p">[</span><span class="s1">&#39;CURRENT ENERGY&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">E0</span>

        <span class="n">DD0</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">findifrec</span><span class="p">[</span><span class="s1">&#39;reference&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;dipole derivative&#39;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">DD0</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">qcvars</span><span class="p">[</span><span class="s1">&#39;CURRENT DIPOLE GRADIENT&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">DD0</span>
            <span class="n">qcvars</span><span class="p">[</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">method</span><span class="o">.</span><span class="n">upper</span><span class="p">()</span><span class="si">}</span><span class="s2"> DIPOLE GRADIENT&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">DD0</span>

        <span class="n">G0</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">findifrec</span><span class="p">[</span><span class="s1">&#39;reference&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;gradient&#39;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">G0</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">qcvars</span><span class="p">[</span><span class="s1">&#39;CURRENT GRADIENT&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">G0</span>
            <span class="n">qcvars</span><span class="p">[</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">method</span><span class="o">.</span><span class="n">upper</span><span class="p">()</span><span class="si">}</span><span class="s2"> TOTAL GRADIENT&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">G0</span>
            <span class="n">properties</span><span class="p">[</span><span class="s2">&quot;return_gradient&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">G0</span>

        <span class="n">H0</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">findifrec</span><span class="p">[</span><span class="s1">&#39;reference&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;hessian&#39;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">H0</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">qcvars</span><span class="p">[</span><span class="s1">&#39;CURRENT HESSIAN&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">H0</span>
            <span class="n">qcvars</span><span class="p">[</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">method</span><span class="o">.</span><span class="n">upper</span><span class="p">()</span><span class="si">}</span><span class="s2"> TOTAL HESSIAN&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">H0</span>
            <span class="n">properties</span><span class="p">[</span><span class="s2">&quot;return_hessian&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">H0</span>

<span class="c1">#        if isinstance(lowername, str) and lowername in procedures[&#39;energy&#39;]:</span>
<span class="c1">#            # this correctly filters out cbs fn and &quot;hf/cc-pvtz&quot;</span>
<span class="c1">#            # it probably incorrectly filters out mp5, but reconsider in DDD</span>

        <span class="n">findif_model</span> <span class="o">=</span> <span class="n">AtomicResult</span><span class="p">(</span>
            <span class="o">**</span><span class="p">{</span>
                <span class="s1">&#39;driver&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">driver</span><span class="p">,</span>
                <span class="s1">&#39;model&#39;</span><span class="p">:</span> <span class="p">{</span>
                    <span class="s2">&quot;basis&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">basis</span><span class="p">,</span>
                    <span class="s1">&#39;method&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">method</span><span class="p">,</span>
                <span class="p">},</span>
                <span class="s1">&#39;molecule&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">molecule</span><span class="o">.</span><span class="n">to_schema</span><span class="p">(</span><span class="n">dtype</span><span class="o">=</span><span class="mi">2</span><span class="p">),</span>
                <span class="s1">&#39;properties&#39;</span><span class="p">:</span> <span class="n">properties</span><span class="p">,</span>
                <span class="s1">&#39;provenance&#39;</span><span class="p">:</span> <span class="n">p4util</span><span class="o">.</span><span class="n">provenance_stamp</span><span class="p">(</span><span class="vm">__name__</span><span class="p">,</span> <span class="n">module</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">findifrec</span><span class="p">[</span><span class="s2">&quot;reference&quot;</span><span class="p">][</span><span class="s2">&quot;module&quot;</span><span class="p">]),</span>
                <span class="s1">&#39;extras&#39;</span><span class="p">:</span> <span class="p">{</span>
                    <span class="s1">&#39;qcvars&#39;</span><span class="p">:</span> <span class="n">qcvars</span><span class="p">,</span>
                    <span class="s1">&#39;findif_record&#39;</span><span class="p">:</span> <span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">findifrec</span><span class="p">),</span>
                <span class="p">},</span>
                <span class="s1">&#39;return_result&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">findifrec</span><span class="p">[</span><span class="s1">&#39;reference&#39;</span><span class="p">][</span><span class="bp">self</span><span class="o">.</span><span class="n">driver</span><span class="o">.</span><span class="n">name</span><span class="p">],</span>
                <span class="s1">&#39;success&#39;</span><span class="p">:</span> <span class="kc">True</span><span class="p">,</span>
            <span class="p">})</span>

        <span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s1">&#39;</span><span class="se">\n</span><span class="s1">FINDIF QCSchema:</span><span class="se">\n</span><span class="s1">&#39;</span> <span class="o">+</span> <span class="n">pp</span><span class="o">.</span><span class="n">pformat</span><span class="p">(</span><span class="n">findif_model</span><span class="o">.</span><span class="n">dict</span><span class="p">()))</span>

        <span class="k">return</span> <span class="n">findif_model</span></div>

<div class="viewcode-block" id="FiniteDifferenceComputer.get_psi_results"><a class="viewcode-back" href="../../../freq.html#psi4.driver.driver_findif.FiniteDifferenceComputer.get_psi_results">[docs]</a>    <span class="k">def</span> <span class="nf">get_psi_results</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">client</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="s2">&quot;qcportal.FractalClient&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="o">*</span><span class="p">,</span>
        <span class="n">return_wfn</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">EnergyGradientHessianWfnReturn</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Called by driver to assemble results into FiniteDifference-flavored QCSchema,</span>
<span class="sd">        then reshape and return them in the customary Psi4 driver interface: ``(e/g/h, wfn)``.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        return_wfn</span>
<span class="sd">            Whether to additionally return the dummy :py:class:`~psi4.core.Wavefunction`</span>
<span class="sd">            calculation result as the second element of a tuple. Contents are:</span>

<span class="sd">            - undisplaced molecule</span>
<span class="sd">            - compute basis if simple, else dummy basis def2-svp</span>
<span class="sd">            - e/g/h member data</span>
<span class="sd">            - QCVariables</span>
<span class="sd">            - module</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        ret</span>
<span class="sd">            Gradient or Hessian according to self.driver.</span>
<span class="sd">        wfn</span>
<span class="sd">            Wavefunction described above when *return_wfn* specified.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">findif_model</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_results</span><span class="p">(</span><span class="n">client</span><span class="o">=</span><span class="n">client</span><span class="p">)</span>

        <span class="n">ret_ptype</span> <span class="o">=</span> <span class="n">core</span><span class="o">.</span><span class="n">Matrix</span><span class="o">.</span><span class="n">from_array</span><span class="p">(</span><span class="n">findif_model</span><span class="o">.</span><span class="n">return_result</span><span class="p">)</span>
        <span class="n">wfn</span> <span class="o">=</span> <span class="n">_findif_schema_to_wfn</span><span class="p">(</span><span class="n">findif_model</span><span class="p">)</span>

        <span class="n">gradient_write</span><span class="p">(</span><span class="n">wfn</span><span class="p">)</span>
        <span class="n">hessian_write</span><span class="p">(</span><span class="n">wfn</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">return_wfn</span><span class="p">:</span>
            <span class="k">return</span> <span class="p">(</span><span class="n">ret_ptype</span><span class="p">,</span> <span class="n">wfn</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">ret_ptype</span></div></div>


<span class="k">def</span> <span class="nf">_findif_schema_to_wfn</span><span class="p">(</span><span class="n">findif_model</span><span class="p">:</span> <span class="n">AtomicResult</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">core</span><span class="o">.</span><span class="n">Wavefunction</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Helper function to produce Wavefunction and Psi4 files from a FiniteDifference-flavored AtomicResult.&quot;&quot;&quot;</span>

    <span class="c1"># new skeleton wavefunction w/mol, highest-SCF basis (just to choose one), &amp; not energy</span>
    <span class="n">mol</span> <span class="o">=</span> <span class="n">core</span><span class="o">.</span><span class="n">Molecule</span><span class="o">.</span><span class="n">from_schema</span><span class="p">(</span><span class="n">findif_model</span><span class="o">.</span><span class="n">molecule</span><span class="o">.</span><span class="n">dict</span><span class="p">(),</span> <span class="n">nonphysical</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="n">sbasis</span> <span class="o">=</span> <span class="s2">&quot;def2-svp&quot;</span> <span class="k">if</span> <span class="p">(</span><span class="n">findif_model</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">basis</span> <span class="o">==</span> <span class="s2">&quot;(auto)&quot;</span><span class="p">)</span> <span class="k">else</span> <span class="n">findif_model</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">basis</span>
    <span class="n">basis</span> <span class="o">=</span> <span class="n">core</span><span class="o">.</span><span class="n">BasisSet</span><span class="o">.</span><span class="n">build</span><span class="p">(</span><span class="n">mol</span><span class="p">,</span> <span class="s2">&quot;ORBITAL&quot;</span><span class="p">,</span> <span class="n">sbasis</span><span class="p">,</span> <span class="n">quiet</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="n">wfn</span> <span class="o">=</span> <span class="n">core</span><span class="o">.</span><span class="n">Wavefunction</span><span class="p">(</span><span class="n">mol</span><span class="p">,</span> <span class="n">basis</span><span class="p">)</span>
    <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">findif_model</span><span class="o">.</span><span class="n">provenance</span><span class="p">,</span> <span class="s2">&quot;module&quot;</span><span class="p">):</span>
        <span class="n">wfn</span><span class="o">.</span><span class="n">set_module</span><span class="p">(</span><span class="n">findif_model</span><span class="o">.</span><span class="n">provenance</span><span class="o">.</span><span class="n">module</span><span class="p">)</span>

    <span class="c1"># setting CURRENT E/G/H on wfn below catches Wfn.energy_, gradient_, hessian_</span>
    <span class="c1"># setting CURRENT E/G/H on core below is authoritative P::e record</span>
    <span class="k">for</span> <span class="n">qcv</span><span class="p">,</span> <span class="n">val</span> <span class="ow">in</span> <span class="n">findif_model</span><span class="o">.</span><span class="n">extras</span><span class="p">[</span><span class="s2">&quot;qcvars&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
        <span class="k">for</span> <span class="n">obj</span> <span class="ow">in</span> <span class="p">[</span><span class="n">core</span><span class="p">,</span> <span class="n">wfn</span><span class="p">]:</span>
            <span class="n">obj</span><span class="o">.</span><span class="n">set_variable</span><span class="p">(</span><span class="n">qcv</span><span class="p">,</span> <span class="n">val</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">wfn</span>


<span class="k">def</span> <span class="nf">hessian_write</span><span class="p">(</span><span class="n">wfn</span><span class="p">:</span> <span class="n">core</span><span class="o">.</span><span class="n">Wavefunction</span><span class="p">):</span>
    <span class="k">if</span> <span class="n">core</span><span class="o">.</span><span class="n">get_option</span><span class="p">(</span><span class="s1">&#39;FINDIF&#39;</span><span class="p">,</span> <span class="s1">&#39;HESSIAN_WRITE&#39;</span><span class="p">):</span>
        <span class="n">filename</span> <span class="o">=</span> <span class="n">core</span><span class="o">.</span><span class="n">get_writer_file_prefix</span><span class="p">(</span><span class="n">wfn</span><span class="o">.</span><span class="n">molecule</span><span class="p">()</span><span class="o">.</span><span class="n">name</span><span class="p">())</span> <span class="o">+</span> <span class="s2">&quot;.hess&quot;</span>
        <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">filename</span><span class="p">,</span> <span class="s1">&#39;wb&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">handle</span><span class="p">:</span>
            <span class="n">qcdb</span><span class="o">.</span><span class="n">hessparse</span><span class="o">.</span><span class="n">to_string</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">wfn</span><span class="o">.</span><span class="n">hessian</span><span class="p">()),</span> <span class="n">handle</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="s1">&#39;psi4&#39;</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">gradient_write</span><span class="p">(</span><span class="n">wfn</span><span class="p">:</span> <span class="n">core</span><span class="o">.</span><span class="n">Wavefunction</span><span class="p">):</span>
    <span class="k">if</span> <span class="n">core</span><span class="o">.</span><span class="n">get_option</span><span class="p">(</span><span class="s1">&#39;FINDIF&#39;</span><span class="p">,</span> <span class="s1">&#39;GRADIENT_WRITE&#39;</span><span class="p">):</span>
        <span class="n">filename</span> <span class="o">=</span> <span class="n">core</span><span class="o">.</span><span class="n">get_writer_file_prefix</span><span class="p">(</span><span class="n">wfn</span><span class="o">.</span><span class="n">molecule</span><span class="p">()</span><span class="o">.</span><span class="n">name</span><span class="p">())</span> <span class="o">+</span> <span class="s2">&quot;.grad&quot;</span>
        <span class="n">qcdb</span><span class="o">.</span><span class="n">gradparse</span><span class="o">.</span><span class="n">to_string</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">wfn</span><span class="o">.</span><span class="n">gradient</span><span class="p">()),</span>
                                 <span class="n">filename</span><span class="p">,</span>
                                 <span class="n">dtype</span><span class="o">=</span><span class="s1">&#39;GRD&#39;</span><span class="p">,</span>
                                 <span class="n">mol</span><span class="o">=</span><span class="n">wfn</span><span class="o">.</span><span class="n">molecule</span><span class="p">(),</span>
                                 <span class="n">energy</span><span class="o">=</span><span class="n">wfn</span><span class="o">.</span><span class="n">energy</span><span class="p">())</span>


<span class="k">def</span> <span class="nf">_rms</span><span class="p">(</span><span class="n">arr</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">core</span><span class="o">.</span><span class="n">Matrix</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="nb">float</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Compute root-mean-square of array, be it Psi4 or NumPy array.&quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">arr</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">square</span><span class="p">(</span><span class="n">arr</span><span class="p">)))</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">arr</span><span class="o">.</span><span class="n">rms</span><span class="p">()</span>
</pre></div>

            <div class="clearer"></div>
          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper"><!-- 
#
# @BEGIN LICENSE
#
# Psi4: an open-source quantum chemistry software package
#
# Copyright (c) 2007-2017 The Psi4 Developers.
#
# The copyrights for code used from other parties are included in
# the corresponding files.
#
# This file is part of Psi4.
#
# Psi4 is free software; you can redistribute it and/or modify
# it under the terms of the GNU Lesser General Public License as published by
# the Free Software Foundation, version 3.
#
# Psi4 is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU Lesser General Public License for more details.
#
# You should have received a copy of the GNU Lesser General Public License along
# with Psi4; if not, write to the Free Software Foundation, Inc.,
# 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
#
# @END LICENSE
# -->


<div id="searchbox" style="display: none" role="search">
  <!--<h3>Quick search</h3>-->
    <form class="search" action="../../../search.html" method="get">
      <!--<div><input type="text" name="q" placeholder="search docs" /></div>-->
      <div><input type="text" name="q" placeholder="&#xF002;" style="font-family:FontAwesome, Ariel" /></div>
      <!--<div><input type="submit" value="Go" /></div>-->
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
    
    
        <div class="sidebar-toggle-group no-js">
            
            <button class="sidebar-toggle" id="sidebar-hide" title="Hide the sidebar menu">
                 «
                <span class="show-for-small">hide menu</span>
                
            </button>
            <button class="sidebar-toggle" id="sidebar-show" title="Show the sidebar menu">
                
                <span class="show-for-small">menu</span>
                <span class="hide-for-small">sidebar</span>
                 »
            </button>
        </div>
    
      <div class="clearer"></div>
    </div>
    <div class="relbar-bottom">
        
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../../genindex.html" title="General Index"
             >Index</a></li>
        <li class="right" >
          <a href="../../../py-modindex.html" title="Python Module Index"
             >modules</a> &nbsp; &nbsp;</li>
        <li class="right" >
          <a href="../../../index.html" title="Table Of Contents"
             ><i class="fa fa-book fa-lg"></i></a> &nbsp; &nbsp;</li>
    <li><a href="http://psicode.org/"><i class="fa fa-home fa-lg"></i></a></li>
    <li><a href="http://github.com/psi4/psi4"><i class="fa fa-github fa-lg"></i></a></li>
    <li><a href="http://forum.psicode.org"><i class="fa fa-comments-o fa-lg"></i></a></li>
    <li><a href="http://github.com/psi4/psi4/edit/master/doc/sphinxman/source/_modules/psi4/driver/driver_findif.rst"><i class="fa fa-pencil fa-lg"></i></a></li>
    <li style="color: #1a4162">&nbsp;&middot;&nbsp;</li>
    <li><a href="http://github.com/psi4/psi4/tree/a0155c3">1.9a1.dev38</a></li>
    <li style="color: #1a4162">&nbsp;&middot;&nbsp;</li>
    <li class="nav-item nav-item-0"><a href="../../../index.html">
        <span style="font-family: Optima, sans-serif;">P<span style="font-size: 82%;">SI</span>4</span>
        </a><i class="fa fa-angle-double-right" style="color: #a2a7b3; text-shadow: none;"></i></li>

          <li class="nav-item nav-item-1"><a href="../../index.html" >Module code</a><i class="fa fa-angle-double-right" style="color: #a2a7b3; text-shadow: none;"></i></li>
        <li class="nav-item nav-item-this"><a href="">psi4.driver.driver_findif</a></li> 
      </ul>
    </div>
    </div>

    <div class="footer" role="contentinfo">
        &#169; Copyright 2007-2023, The Psi4 Project.
      Last updated on Tuesday, 15 August 2023 06:38PM.
      Created using <a href="https://www.sphinx-doc.org/">Sphinx</a> 6.2.1.
    </div>
    <!-- cloud_sptheme 1.4 -->
  </body>
</html>