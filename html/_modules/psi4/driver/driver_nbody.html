<!-- 
#
# @BEGIN LICENSE
#
# Psi4: an open-source quantum chemistry software package
#
# Copyright (c) 2007-2017 The Psi4 Developers.
#
# The copyrights for code used from other parties are included in
# the corresponding files.
#
# This file is part of Psi4.
#
# Psi4 is free software; you can redistribute it and/or modify
# it under the terms of the GNU Lesser General Public License as published by
# the Free Software Foundation, version 3.
#
# Psi4 is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU Lesser General Public License for more details.
#
# You should have received a copy of the GNU Lesser General Public License along
# with Psi4; if not, write to the Free Software Foundation, Inc.,
# 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
#
# @END LICENSE
# -->





<!DOCTYPE html>

<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>psi4.driver.driver_nbody</title>
    <link rel="stylesheet" type="text/css" href="../../../_static/pygments.css" />
    <link rel="stylesheet" type="text/css" href="../../../_static/psi4.css" />
    <link rel="stylesheet" type="text/css" href="../../../_static/graphviz.css" />
    <link rel="stylesheet" type="text/css" href="../../../_static/autodoc_pydantic.css" />
    <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/font-awesome/4.4.0/css/font-awesome.min.css" type="text/css" />
    <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Noticia+Text:400,i,b,bi|Open+Sans:400,i,b,bi|Roboto+Mono:400,i,b,bi&amp;display=swap" type="text/css" />
    
    <script data-url_root="../../../" id="documentation_options" src="../../../_static/documentation_options.js"></script>
    <script src="../../../_static/doctools.js"></script>
    <script src="../../../_static/sphinx_highlight.js"></script>
    <script crossorigin="anonymous" integrity="sha256-Ae2Vz/4ePdIu6ZyI/5ZGsYnb+m0JlOmKPjt6XZ9JJkA=" src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.4/require.min.js"></script>

    
    
     
        <script src="../../../_static/jquery.cookie.js"></script>
    

    
     
        <script src="../../../_static/cloud.base.js"></script>
    

    
     
        <script src="../../../_static/cloud.js"></script>
    

    <link rel="icon" href="../../../_static/favicon-psi4.ico"/>
    <link rel="index" title="Index" href="../../../genindex.html" />
    <link rel="search" title="Search" href="../../../search.html" /> 
        <meta name="viewport" content="width=device-width, initial-scale=1">
  </head><body>
    <div class="relbar-top">
        
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../../genindex.html" title="General Index"
             accesskey="I">Index</a></li>
        <li class="right" >
          <a href="../../../py-modindex.html" title="Python Module Index"
             >modules</a> &nbsp; &nbsp;</li>
        <li class="right" >
          <a href="../../../index.html" title="Table Of Contents"
             accesskey="C"><i class="fa fa-book fa-lg"></i></a> &nbsp; &nbsp;</li>
    <li><a href="http://psicode.org/"><i class="fa fa-home fa-lg"></i></a></li>
    <li><a href="http://github.com/psi4/psi4"><i class="fa fa-github fa-lg"></i></a></li>
    <li><a href="http://forum.psicode.org"><i class="fa fa-comments-o fa-lg"></i></a></li>
    <li><a href="http://github.com/psi4/psi4/edit/master/doc/sphinxman/source/_modules/psi4/driver/driver_nbody.rst"><i class="fa fa-pencil fa-lg"></i></a></li>
    <li style="color: #1a4162">&nbsp;&middot;&nbsp;</li>
    <li><a href="http://github.com/psi4/psi4/tree/eed5177">1.9a1.dev27</a></li>
    <li style="color: #1a4162">&nbsp;&middot;&nbsp;</li>
    <li class="nav-item nav-item-0"><a href="../../../index.html">
        <span style="font-family: Optima, sans-serif;">P<span style="font-size: 82%;">SI</span>4</span>
        </a><i class="fa fa-angle-double-right" style="color: #a2a7b3; text-shadow: none;"></i></li>

          <li class="nav-item nav-item-1"><a href="../../index.html" accesskey="U">Module code</a><i class="fa fa-angle-double-right" style="color: #a2a7b3; text-shadow: none;"></i></li>
        <li class="nav-item nav-item-this"><a href="">psi4.driver.driver_nbody</a></li> 
      </ul>
    </div>
    </div>
  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <h1>Source code for psi4.driver.driver_nbody</h1><div class="highlight"><pre>
<span></span><span class="c1">#</span>
<span class="c1"># @BEGIN LICENSE</span>
<span class="c1">#</span>
<span class="c1"># Psi4: an open-source quantum chemistry software package</span>
<span class="c1">#</span>
<span class="c1"># Copyright (c) 2007-2023 The Psi4 Developers.</span>
<span class="c1">#</span>
<span class="c1"># The copyrights for code used from other parties are included in</span>
<span class="c1"># the corresponding files.</span>
<span class="c1">#</span>
<span class="c1"># This file is part of Psi4.</span>
<span class="c1">#</span>
<span class="c1"># Psi4 is free software; you can redistribute it and/or modify</span>
<span class="c1"># it under the terms of the GNU Lesser General Public License as published by</span>
<span class="c1"># the Free Software Foundation, version 3.</span>
<span class="c1">#</span>
<span class="c1"># Psi4 is distributed in the hope that it will be useful,</span>
<span class="c1"># but WITHOUT ANY WARRANTY; without even the implied warranty of</span>
<span class="c1"># MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the</span>
<span class="c1"># GNU Lesser General Public License for more details.</span>
<span class="c1">#</span>
<span class="c1"># You should have received a copy of the GNU Lesser General Public License along</span>
<span class="c1"># with Psi4; if not, write to the Free Software Foundation, Inc.,</span>
<span class="c1"># 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.</span>
<span class="c1">#</span>
<span class="c1"># @END LICENSE</span>
<span class="c1">#</span>
<span class="sd">&quot;&quot;&quot;Plan, run, and assemble QC tasks to obtain many-body expansion and basis-set superposition error treatments.</span>

<span class="sd">=============</span>
<span class="sd">ManyBody Flow</span>
<span class="sd">=============</span>
<span class="sd">Bullet points are major actions</span>
<span class="sd">Lines of dashes denote function calls</span>
<span class="sd">e/d/dd=dg/g/h := energy, dipole, dipole derivative = dipole gradient, gradient, Hessian</span>
<span class="sd">`mc_(frag, bas)` := a modelchem index, mc; indices of real fragments, frag; set(bas - frag) are indices of ghost fragments. see &quot;intermediates_energy&quot; in big table below for example.</span>
<span class="sd">note that there&#39;s a lot of natural 1-indexing (1, 2, 3) rather than 0-indexing (0, 1, 2) in manybody. e.g., 2-body energy, Molecule.extract_subsets(1, (1, 2))</span>
<span class="sd">note that a &quot;level&quot; can be n-body level (how many real molecular fragments) or a modelchem level (`mc_`; e.g., CC on 1-bodies, MP2 on 2-bodies; &quot;multilevel&quot;)</span>

<span class="sd">---------------------------</span>
<span class="sd">ManyBodyComputer.__init__()</span>
<span class="sd">---------------------------</span>
<span class="sd">* not an explicit function but pydantic handles some defaults and validation</span>
<span class="sd">* fields molecule, nfragments, bsse_type, return_total_data, and initial max_nbody set</span>
<span class="sd">* BaseComputer.__init__()</span>

<span class="sd">task_planner.py::task_planner()</span>
<span class="sd">-------------------------------</span>
<span class="sd">* computer gets modified from task_planner outside this file!</span>
<span class="sd">* modelchem (method and basis) treatment levels for each n-body level determined from user levels kwarg. fields nbodies_per_mc_level set and max_nbody reset</span>
<span class="sd">* for each modelchem treatment level, call build_tasks() below via one of four routes, depending on simple MB or layered MB(FD), MB(CBS), or MB(FD(CBS))</span>

<span class="sd">    ------------------------------</span>
<span class="sd">    ManyBodyComputer.build_tasks()</span>
<span class="sd">    ------------------------------</span>
<span class="sd">    * if supersystem requested as a modelchem level, request (frag, bas) indices for full nbody range of nocp treatment from build_nbody_compute_list()</span>
<span class="sd">    * otherwise, request (frag, bas) indices for specified nbody range covering specified bsse treatments from build_nbody_compute_list()</span>

<span class="sd">        build_nbody_compute_list()</span>
<span class="sd">        --------------------------</span>
<span class="sd">        * initializes dicts for each of nocp, cp, vmfc (2 for this one) with keys requested n-body levels and values empty sets</span>
<span class="sd">        * use combinatorics formulas to fill each key with (frag, bas) indices (what fragments are active and what fragments have basis functions)</span>
<span class="sd">          needed to compute the requested bsse treatments at the requested n-body levels.</span>
<span class="sd">        * merge by n-body level the sets of indices for each bsse treatment into an &quot;all&quot; dict. return this and all the per-bsse dicts.</span>

<span class="sd">    * merge (from different bsse_types) all the requested indices, prepend a modelchem treatment index to form `mc_(frag, bas)`</span>
<span class="sd">    * construct a molecule appropriately real/ghosted from active-fragment info in (frag, bas)</span>
<span class="sd">    * if embedding_charges active, prepare external_potentials array for atoms not in bas fragments</span>
<span class="sd">    * for any new `mc_(frag, bas)` index, append a new computer to self.task_list</span>

<span class="sd">--------------------------</span>
<span class="sd">ManyBodyComputer.compute()</span>
<span class="sd">--------------------------</span>
<span class="sd">* compute() for each job in self.task_list</span>

<span class="sd">----------------------------------</span>
<span class="sd">ManyBodyComputer.get_psi_results()</span>
<span class="sd">----------------------------------</span>

<span class="sd">    Computer.get_results()</span>
<span class="sd">    ----------------------</span>

<span class="sd">        Computer._prepare_results()</span>
<span class="sd">        ---------------------------</span>
<span class="sd">        * if multiple modelchems (multilevel):</span>

<span class="sd">            multilevel.prepare_results()</span>
<span class="sd">            ----------------------------</span>
<span class="sd">            * from the pool of calcs, partition them by modelchem treatment and call _prepare_results on each subpool</span>
<span class="sd">            * sums modelchem levels and returns small dict back to get_results()</span>

<span class="sd">        * call get_results() for each job in task list</span>
<span class="sd">        * assemble all the computed energies, all the computed gradients, and all the computed hessians</span>
<span class="sd">        * for each available derivative, call:</span>

<span class="sd">            assemble_nbody_components()</span>
<span class="sd">            ---------------------------</span>
<span class="sd">            * re-call build_nbody_compute_list to get the cp/nocp/vmfc lists again</span>

<span class="sd">                build_nbody_compute_list()</span>
<span class="sd">                --------------------------</span>

<span class="sd">            * slice up the supersystem mol into fragment atom ranges to help g/h arrays build piecemeal</span>
<span class="sd">            * prepare empty {bsse_type}_by_level and {bsse_type}_body_dict structs. the former have different contents for vmfc</span>
<span class="sd">            * for cp and nocp, resort the build_nbody_compute_list returns into per-body lists suitable for summing</span>
<span class="sd">            * note that nb loops often run over more than active nbodies_per_mc_level item due to 1-body for subtraction and multilevel complications</span>
<span class="sd">            * for each possibly active n-body level and each active bsse_type, call _sum_cluster_ptype_data to build by_level structs</span>

<span class="sd">                _sum_cluster_ptype_data()</span>
<span class="sd">                -------------------------</span>
<span class="sd">                * sum up ene, grad, or Hess in per-fragment pieces based on list of (frag, bas) subjobs active for that bsse treatment</span>

<span class="sd">            * compute special case of monomers in monomer basis</span>
<span class="sd">            * for each of cp/nocp/vmfc, apply appropriate formula to build each n-body level of cumulative total energy into body_dict</span>
<span class="sd">            * for driver=energy, set several qcvars and call:</span>

<span class="sd">                _print_nbody_energy()</span>
<span class="sd">                ---------------------</span>
<span class="sd">                * prints and logs formatted energy output. called separately for cp, nocp, vmfc</span>

<span class="sd">            * collect qcvars and summed levels into a return dictionary with some extra aliases for target bsse_type and target driver</span>

<span class="sd">        * merge all the assemble_nbody_components return dictionaries</span>
<span class="sd">        * in struct[&quot;intermediates&quot;], store dict of `&quot;N-BODY (?)@(?) TOTAL ENERGY&quot; = return_energy` for all in task_list or results kwarg</span>
<span class="sd">        * in struct[&quot;intermediates_{ptype}&quot;], store dict of `task_list key = return_{ptype}` for all in task_list or results kwarg. ptype=e/g/h</span>
<span class="sd">          always for ptype=energy, as available for higher derivatives when driver=g/h</span>

<span class="sd">    * form nbody qcvars and properties, inc&#39;l number, current e/g/h as available</span>
<span class="sd">    * pull results (incl dicts!) into qcvars</span>
<span class="sd">    * form model, including copy of class with mols converted to qcsk at atomicresult.extras[&quot;component_results&quot;]</span>

<span class="sd">* collect ManyBody-flavored AtomicResult from self.get_results()</span>
<span class="sd">* build wfn from nbody mol and basis (always def2-svp)</span>
<span class="sd">* push qcvars to P::e and wfn. push various internal dicts to qcvars, too</span>
<span class="sd">* convert result to psi4.core.Matrix (non-energy) and set g/h on wfn</span>
<span class="sd">* return e/g/h and wfn</span>

<span class="sd">&quot;&quot;&quot;</span>

<span class="n">__all__</span> <span class="o">=</span> <span class="p">[</span>
    <span class="s2">&quot;BsseEnum&quot;</span><span class="p">,</span>
    <span class="s2">&quot;ManyBodyComputer&quot;</span><span class="p">,</span>
    <span class="s2">&quot;nbody&quot;</span><span class="p">,</span>
<span class="p">]</span>

<span class="kn">import</span> <span class="nn">copy</span>
<span class="kn">import</span> <span class="nn">itertools</span>
<span class="kn">import</span> <span class="nn">math</span>
<span class="kn">from</span> <span class="nn">typing</span> <span class="kn">import</span> <span class="n">Any</span><span class="p">,</span> <span class="n">Callable</span><span class="p">,</span> <span class="n">Dict</span><span class="p">,</span> <span class="n">List</span><span class="p">,</span> <span class="n">Literal</span><span class="p">,</span> <span class="n">Optional</span><span class="p">,</span> <span class="n">Sequence</span><span class="p">,</span> <span class="n">Set</span><span class="p">,</span> <span class="n">Tuple</span><span class="p">,</span> <span class="n">Union</span><span class="p">,</span> <span class="n">TYPE_CHECKING</span>
<span class="kn">from</span> <span class="nn">ast</span> <span class="kn">import</span> <span class="n">literal_eval</span>
<span class="kn">from</span> <span class="nn">enum</span> <span class="kn">import</span> <span class="n">Enum</span>

<span class="kn">from</span> <span class="nn">pydantic</span> <span class="kn">import</span> <span class="n">Field</span><span class="p">,</span> <span class="n">validator</span>

<span class="kn">import</span> <span class="nn">pprint</span>
<span class="n">pp</span> <span class="o">=</span> <span class="n">pprint</span><span class="o">.</span><span class="n">PrettyPrinter</span><span class="p">(</span><span class="n">width</span><span class="o">=</span><span class="mi">120</span><span class="p">,</span> <span class="n">compact</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">indent</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
<span class="kn">import</span> <span class="nn">logging</span>

<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">from</span> <span class="nn">qcelemental.models</span> <span class="kn">import</span> <span class="n">DriverEnum</span><span class="p">,</span> <span class="n">AtomicResult</span>

<span class="kn">from</span> <span class="nn">psi4</span> <span class="kn">import</span> <span class="n">core</span>
<span class="kn">from</span> <span class="nn">psi4.driver</span> <span class="kn">import</span> <span class="n">constants</span><span class="p">,</span> <span class="n">driver_nbody_multilevel</span><span class="p">,</span> <span class="n">p4util</span>
<span class="kn">from</span> <span class="nn">psi4.driver.p4util.exceptions</span> <span class="kn">import</span> <span class="o">*</span>
<span class="kn">from</span> <span class="nn">psi4.driver.task_base</span> <span class="kn">import</span> <span class="n">BaseComputer</span><span class="p">,</span> <span class="n">AtomicComputer</span><span class="p">,</span> <span class="n">EnergyGradientHessianWfnReturn</span>
<span class="kn">from</span> <span class="nn">psi4.driver.driver_cbs</span> <span class="kn">import</span> <span class="n">CompositeComputer</span>
<span class="kn">from</span> <span class="nn">psi4.driver.driver_findif</span> <span class="kn">import</span> <span class="n">FiniteDifferenceComputer</span>

<span class="k">if</span> <span class="n">TYPE_CHECKING</span><span class="p">:</span>
    <span class="kn">import</span> <span class="nn">qcportal</span>

<span class="n">logger</span> <span class="o">=</span> <span class="n">logging</span><span class="o">.</span><span class="n">getLogger</span><span class="p">(</span><span class="vm">__name__</span><span class="p">)</span>

<span class="n">FragBasIndex</span> <span class="o">=</span> <span class="n">Tuple</span><span class="p">[</span><span class="n">Tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">],</span> <span class="n">Tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">]]</span>

<span class="n">SubTaskComputers</span> <span class="o">=</span> <span class="n">Union</span><span class="p">[</span><span class="n">AtomicComputer</span><span class="p">,</span> <span class="n">CompositeComputer</span><span class="p">,</span> <span class="n">FiniteDifferenceComputer</span><span class="p">]</span>

<div class="viewcode-block" id="nbody"><a class="viewcode-back" href="../../../nbody.html#psi4.driver.driver_nbody.nbody">[docs]</a><span class="k">def</span> <span class="nf">nbody</span><span class="p">():</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Computes the nbody interaction energy, gradient, or Hessian depending on input.</span>
<span class="sd">    This is a generalized universal function for computing interaction and total quantities.</span>

<span class="sd">    :returns: *return type of func* |w--w| The data.</span>

<span class="sd">    :returns: (*float*, :py:class:`~psi4.core.Wavefunction`) |w--w| data and wavefunction with energy/gradient/hessian set appropriately when **return_wfn** specified.</span>

<span class="sd">    :type molecule: :ref:`molecule &lt;op_py_molecule&gt;`</span>
<span class="sd">    :param molecule: ``h2o`` || etc.</span>

<span class="sd">        The target molecule, if not the last molecule defined.</span>

<span class="sd">    :type return_wfn: :ref:`boolean &lt;op_py_boolean&gt;`</span>
<span class="sd">    :param return_wfn: ``&#39;on&#39;`` || |dl| ``&#39;off&#39;`` |dr|</span>

<span class="sd">        Indicate to additionally return the :py:class:`~psi4.core.Wavefunction`</span>
<span class="sd">        calculation result as the second element of a tuple.</span>

<span class="sd">    :type bsse_type: str or list</span>
<span class="sd">    :param bsse_type: ``&#39;cp&#39;`` || ``[&#39;nocp&#39;, &#39;vmfc&#39;]`` || |dl| ``None`` |dr| || etc.</span>

<span class="sd">        Type of BSSE correction to compute: CP for counterpoise correction, NoCP</span>
<span class="sd">        for plain supramolecular interaction energy, or VMFC for Valiron-Mayer</span>
<span class="sd">        Function Counterpoise correction. If a list is provided, the first string in</span>
<span class="sd">        the list determines which interaction or total energies/gradients/Hessians are</span>
<span class="sd">        returned by this function. By default, many-body treatments are inactive.</span>

<span class="sd">    :type max_nbody: int</span>
<span class="sd">    :param max_nbody: ``3`` || etc.</span>

<span class="sd">        Maximum n-body to compute, cannot exceed the number of fragments in the molecule.</span>

<span class="sd">    :type return_total_data: :ref:`boolean &lt;op_py_boolean&gt;`</span>
<span class="sd">    :param return_total_data: ``&#39;on&#39;`` || |dl| ``&#39;off&#39;`` |dr|</span>

<span class="sd">        If True returns the total data (energy/gradient/Hessian) of the system,</span>
<span class="sd">        otherwise returns interaction data. Default is ``&#39;off&#39;`` for energies,</span>
<span class="sd">        ``&#39;on&#39;`` for gradients and Hessians. Note that the calculation of total</span>
<span class="sd">        counterpoise corrected energies implies the calculation of the energies of</span>
<span class="sd">        monomers in the monomer basis, hence specifying ``return_total_data = True``</span>
<span class="sd">        may carry out more computations than ``return_total_data = False``.</span>
<span class="sd">        For gradients and Hessians, ``return_total_data = False`` is rarely useful.</span>

<span class="sd">    :type levels: dict</span>
<span class="sd">    :param levels: ``{1: &#39;ccsd(t)&#39;, 2: &#39;mp2&#39;, &#39;supersystem&#39;: &#39;scf&#39;}`` || ``{1: 2, 2: &#39;ccsd(t)&#39;, 3: &#39;mp2&#39;}`` || etc</span>

<span class="sd">        Dictionary of different levels of theory for different levels of expansion</span>
<span class="sd">        Note that method_string is not used in this case. ``supersystem`` computes</span>
<span class="sd">        all higher order n-body effects up to the number of fragments.</span>

<span class="sd">    :type embedding_charges: dict</span>
<span class="sd">    :param embedding_charges: ``{1: [-0.834, 0.417, 0.417], ..}``</span>

<span class="sd">        Dictionary of atom-centered point charges. keys: 1-based index of fragment, values: list of charges for each fragment.</span>
<span class="sd">        Add atom-centered point charges for fragments whose basis sets are not included in the computation.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">pass</span></div>


<div class="viewcode-block" id="BsseEnum"><a class="viewcode-back" href="../../../nbody.html#psi4.driver.driver_nbody.BsseEnum">[docs]</a><span class="k">class</span> <span class="nc">BsseEnum</span><span class="p">(</span><span class="nb">str</span><span class="p">,</span> <span class="n">Enum</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Available basis-set superposition error (BSSE) treatments.&quot;&quot;&quot;</span>

    <span class="n">nocp</span> <span class="o">=</span> <span class="s2">&quot;nocp&quot;</span>  <span class="c1"># plain supramolecular interaction energy</span>
    <span class="n">cp</span> <span class="o">=</span> <span class="s2">&quot;cp&quot;</span>      <span class="c1"># counterpoise correction</span>
    <span class="n">vmfc</span> <span class="o">=</span> <span class="s2">&quot;vmfc&quot;</span>  <span class="c1"># Valiron-Mayer function counterpoise</span></div>


<span class="k">def</span> <span class="nf">_sum_cluster_ptype_data</span><span class="p">(</span>
    <span class="n">ptype</span><span class="p">:</span> <span class="n">DriverEnum</span><span class="p">,</span>
    <span class="n">ptype_dict</span><span class="p">:</span> <span class="n">Dict</span><span class="p">,</span>
    <span class="n">compute_list</span><span class="p">:</span> <span class="n">Set</span><span class="p">[</span><span class="n">FragBasIndex</span><span class="p">],</span>
    <span class="n">fragment_slice_dict</span><span class="p">:</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="n">Sequence</span><span class="p">],</span>
    <span class="n">fragment_size_dict</span><span class="p">:</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">int</span><span class="p">],</span>
    <span class="n">mc_level_lbl</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span>
    <span class="n">vmfc</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">nb</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Union</span><span class="p">[</span><span class="nb">float</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Sum arrays from n-body computations to obtain the BSSE corrected or uncorrected scalar or array.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    ptype</span>
<span class="sd">        Hint to shape of array data to sum.</span>
<span class="sd">    ptype_dict</span>
<span class="sd">        Dictionary containing computed energy, gradient, or Hessian obtained from each subsystem computation</span>
<span class="sd">    compute_list</span>
<span class="sd">        A list of (frag, bas) tuples notating all the required computations.</span>
<span class="sd">    fragment_slice_dict</span>
<span class="sd">        Dictionary containing slices that index the gradient or Hessian matrix for each of the 1-indexed fragments.</span>
<span class="sd">        For He--HOOH--Me cluster, `{1: slice(0, 1, None), 2: slice(1, 5, None), 3: slice(5, 10, None)}`.</span>
<span class="sd">    fragment_size_dict</span>
<span class="sd">        Dictionary containing the number of atoms of each 1-indexed fragment.</span>
<span class="sd">        For He--HOOH--Me cluster, `{1: 1, 2: 4, 3: 5}`.</span>
<span class="sd">    vmfc</span>
<span class="sd">        Is it a VMFC calculation?</span>
<span class="sd">    nb</span>
<span class="sd">        n-body level; required for VMFC calculations.</span>
<span class="sd">    mc_level_lbl</span>
<span class="sd">        User label for what modelchem level results should be pulled out of *ptype_dict*.</span>
<span class="sd">        This is the 1-indexed counterpart to 0-indexed mc_level_idx.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ret</span>
<span class="sd">        Scalar or array containing the summed energy, gradient, or Hessian result.</span>
<span class="sd">        Formerly, passed in and modified in place and only called for g/h.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">sign</span> <span class="o">=</span> <span class="mi">1</span>
    <span class="n">nat</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">(</span><span class="n">fragment_size_dict</span><span class="o">.</span><span class="n">values</span><span class="p">())</span>

    <span class="k">def</span> <span class="nf">labeler</span><span class="p">(</span><span class="n">frag</span><span class="p">:</span> <span class="n">Tuple</span><span class="p">,</span> <span class="n">bas</span><span class="p">:</span><span class="n">Tuple</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
        <span class="k">return</span> <span class="nb">str</span><span class="p">(</span><span class="n">mc_level_lbl</span><span class="p">)</span> <span class="o">+</span> <span class="s2">&quot;_&quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">((</span><span class="n">frag</span><span class="p">,</span> <span class="n">bas</span><span class="p">))</span>

    <span class="k">if</span> <span class="n">ptype</span> <span class="o">==</span> <span class="s2">&quot;energy&quot;</span><span class="p">:</span>
        <span class="n">ret</span> <span class="o">=</span> <span class="mf">0.0</span>

        <span class="k">for</span> <span class="n">frag</span><span class="p">,</span> <span class="n">bas</span> <span class="ow">in</span> <span class="n">compute_list</span><span class="p">:</span>
            <span class="n">ene</span> <span class="o">=</span> <span class="n">ptype_dict</span><span class="p">[</span><span class="n">labeler</span><span class="p">(</span><span class="n">frag</span><span class="p">,</span> <span class="n">bas</span><span class="p">)]</span>

            <span class="k">if</span> <span class="n">vmfc</span><span class="p">:</span>
                <span class="n">sign</span> <span class="o">=</span> <span class="p">((</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="o">**</span><span class="p">(</span><span class="n">nb</span> <span class="o">-</span> <span class="nb">len</span><span class="p">(</span><span class="n">frag</span><span class="p">)))</span>

            <span class="n">ret</span> <span class="o">+=</span> <span class="n">sign</span> <span class="o">*</span> <span class="n">ene</span>

        <span class="k">return</span> <span class="n">ret</span>

    <span class="k">elif</span> <span class="n">ptype</span> <span class="o">==</span> <span class="s1">&#39;gradient&#39;</span><span class="p">:</span>
        <span class="n">ret</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">nat</span><span class="p">,</span> <span class="mi">3</span><span class="p">))</span>

        <span class="k">for</span> <span class="n">frag</span><span class="p">,</span> <span class="n">bas</span> <span class="ow">in</span> <span class="n">compute_list</span><span class="p">:</span>
            <span class="n">grad</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">ptype_dict</span><span class="p">[</span><span class="n">labeler</span><span class="p">(</span><span class="n">frag</span><span class="p">,</span> <span class="n">bas</span><span class="p">)])</span>

            <span class="k">if</span> <span class="n">vmfc</span><span class="p">:</span>
                <span class="n">sign</span> <span class="o">=</span> <span class="p">((</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="o">**</span><span class="p">(</span><span class="n">nb</span> <span class="o">-</span> <span class="nb">len</span><span class="p">(</span><span class="n">frag</span><span class="p">)))</span>

            <span class="n">start</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="k">for</span> <span class="n">ifr</span> <span class="ow">in</span> <span class="n">bas</span><span class="p">:</span>
                <span class="n">end</span> <span class="o">=</span> <span class="n">start</span> <span class="o">+</span> <span class="n">fragment_size_dict</span><span class="p">[</span><span class="n">ifr</span><span class="p">]</span>
                <span class="n">ret</span><span class="p">[</span><span class="n">fragment_slice_dict</span><span class="p">[</span><span class="n">ifr</span><span class="p">]]</span> <span class="o">+=</span> <span class="n">sign</span> <span class="o">*</span> <span class="n">grad</span><span class="p">[</span><span class="n">start</span><span class="p">:</span><span class="n">end</span><span class="p">]</span>
                <span class="n">start</span> <span class="o">+=</span> <span class="n">fragment_size_dict</span><span class="p">[</span><span class="n">ifr</span><span class="p">]</span>

        <span class="k">return</span> <span class="n">ret</span>

    <span class="k">elif</span> <span class="n">ptype</span> <span class="o">==</span> <span class="s1">&#39;hessian&#39;</span><span class="p">:</span>
        <span class="n">ret</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">nat</span> <span class="o">*</span> <span class="mi">3</span><span class="p">,</span> <span class="n">nat</span> <span class="o">*</span> <span class="mi">3</span><span class="p">))</span>

        <span class="k">for</span> <span class="n">frag</span><span class="p">,</span> <span class="n">bas</span> <span class="ow">in</span> <span class="n">compute_list</span><span class="p">:</span>
            <span class="n">hess</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">ptype_dict</span><span class="p">[</span><span class="n">labeler</span><span class="p">(</span><span class="n">frag</span><span class="p">,</span> <span class="n">bas</span><span class="p">)])</span>

            <span class="k">if</span> <span class="n">vmfc</span><span class="p">:</span>
                <span class="n">sign</span> <span class="o">=</span> <span class="p">((</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="o">**</span><span class="p">(</span><span class="n">nb</span> <span class="o">-</span> <span class="nb">len</span><span class="p">(</span><span class="n">frag</span><span class="p">)))</span>

            <span class="c1"># Build up start and end slices</span>
            <span class="n">abs_start</span><span class="p">,</span> <span class="n">rel_start</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span>
            <span class="n">abs_slices</span><span class="p">,</span> <span class="n">rel_slices</span> <span class="o">=</span> <span class="p">[],</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">ifr</span> <span class="ow">in</span> <span class="n">bas</span><span class="p">:</span>
                <span class="n">rel_end</span> <span class="o">=</span> <span class="n">rel_start</span> <span class="o">+</span> <span class="mi">3</span> <span class="o">*</span> <span class="n">fragment_size_dict</span><span class="p">[</span><span class="n">ifr</span><span class="p">]</span>
                <span class="n">rel_slices</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="nb">slice</span><span class="p">(</span><span class="n">rel_start</span><span class="p">,</span> <span class="n">rel_end</span><span class="p">))</span>
                <span class="n">rel_start</span> <span class="o">+=</span> <span class="mi">3</span> <span class="o">*</span> <span class="n">fragment_size_dict</span><span class="p">[</span><span class="n">ifr</span><span class="p">]</span>

                <span class="n">tmp_slice</span> <span class="o">=</span> <span class="n">fragment_slice_dict</span><span class="p">[</span><span class="n">ifr</span><span class="p">]</span>
                <span class="n">abs_slices</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="nb">slice</span><span class="p">(</span><span class="n">tmp_slice</span><span class="o">.</span><span class="n">start</span> <span class="o">*</span> <span class="mi">3</span><span class="p">,</span> <span class="n">tmp_slice</span><span class="o">.</span><span class="n">stop</span> <span class="o">*</span> <span class="mi">3</span><span class="p">))</span>

            <span class="k">for</span> <span class="n">abs_sl1</span><span class="p">,</span> <span class="n">rel_sl1</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">abs_slices</span><span class="p">,</span> <span class="n">rel_slices</span><span class="p">):</span>
                <span class="k">for</span> <span class="n">abs_sl2</span><span class="p">,</span> <span class="n">rel_sl2</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">abs_slices</span><span class="p">,</span> <span class="n">rel_slices</span><span class="p">):</span>
                    <span class="n">ret</span><span class="p">[</span><span class="n">abs_sl1</span><span class="p">,</span> <span class="n">abs_sl2</span><span class="p">]</span> <span class="o">+=</span> <span class="n">sign</span> <span class="o">*</span> <span class="n">hess</span><span class="p">[</span><span class="n">rel_sl1</span><span class="p">,</span> <span class="n">rel_sl2</span><span class="p">]</span>

        <span class="k">return</span> <span class="n">ret</span>

    <span class="k">else</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">KeyError</span><span class="p">(</span><span class="s2">&quot;ptype can only be energy, gradient, or hessian. How did you end up here?&quot;</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">_print_nbody_energy</span><span class="p">(</span><span class="n">energy_body_dict</span><span class="p">:</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">float</span><span class="p">],</span> <span class="n">header</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">nfragments</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">embedding</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Format output string for user for a single bsse_type. Prints to output and logger.</span>
<span class="sd">    Called repeatedly by assemble_nbody_component.&quot;&quot;&quot;</span>

    <span class="n">info</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;&quot;&quot;</span><span class="se">\n</span><span class="s2">   ==&gt; N-Body: </span><span class="si">{</span><span class="n">header</span><span class="si">}</span><span class="s2"> energies &lt;==</span><span class="se">\n\n</span><span class="s2">&quot;&quot;&quot;</span>
    <span class="n">info</span> <span class="o">+=</span> <span class="sa">f</span><span class="s2">&quot;&quot;&quot;  </span><span class="si">{</span><span class="s2">&quot;n-Body&quot;</span><span class="si">:</span><span class="s2">&gt;12</span><span class="si">}</span><span class="s2">     Total Energy            Interaction Energy                          N-body Contribution to Interaction Energy</span><span class="se">\n</span><span class="s2">&quot;&quot;&quot;</span>
    <span class="n">info</span> <span class="o">+=</span> <span class="sa">f</span><span class="s2">&quot;&quot;&quot;                   [Eh]                    [Eh]                  [kcal/mol]            [Eh]                  [kcal/mol]</span><span class="se">\n</span><span class="s2">&quot;&quot;&quot;</span>
    <span class="n">previous_e</span> <span class="o">=</span> <span class="n">energy_body_dict</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
    <span class="n">tot_e</span> <span class="o">=</span> <span class="p">(</span><span class="n">previous_e</span> <span class="o">!=</span> <span class="mf">0.0</span><span class="p">)</span>
    <span class="n">nbody_range</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">energy_body_dict</span><span class="p">)</span>
    <span class="n">nbody_range</span><span class="o">.</span><span class="n">sort</span><span class="p">()</span>
    <span class="k">for</span> <span class="n">nb</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">nfragments</span> <span class="o">+</span> <span class="mi">1</span><span class="p">):</span>
        <span class="n">lbl</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">if</span> <span class="n">nb</span> <span class="o">==</span> <span class="n">nfragments</span><span class="p">:</span>
            <span class="n">lbl</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s2">&quot;FULL&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">nb</span> <span class="o">==</span> <span class="nb">max</span><span class="p">(</span><span class="n">nbody_range</span><span class="p">):</span>
            <span class="n">lbl</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s2">&quot;RTN&quot;</span><span class="p">)</span>
        <span class="n">lbl</span> <span class="o">=</span> <span class="s2">&quot;/&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">lbl</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">nb</span> <span class="ow">in</span> <span class="n">nbody_range</span><span class="p">:</span>
            <span class="n">delta_e</span> <span class="o">=</span> <span class="p">(</span><span class="n">energy_body_dict</span><span class="p">[</span><span class="n">nb</span><span class="p">]</span> <span class="o">-</span> <span class="n">previous_e</span><span class="p">)</span>
            <span class="n">delta_e_kcal</span> <span class="o">=</span> <span class="n">delta_e</span> <span class="o">*</span> <span class="n">constants</span><span class="o">.</span><span class="n">hartree2kcalmol</span>
            <span class="k">if</span> <span class="n">embedding</span><span class="p">:</span>
                <span class="n">int_e</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>
                <span class="n">int_e_kcal</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">int_e</span> <span class="o">=</span> <span class="n">energy_body_dict</span><span class="p">[</span><span class="n">nb</span><span class="p">]</span> <span class="o">-</span> <span class="n">energy_body_dict</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
                <span class="n">int_e_kcal</span> <span class="o">=</span> <span class="n">int_e</span> <span class="o">*</span> <span class="n">constants</span><span class="o">.</span><span class="n">hartree2kcalmol</span>
            <span class="k">if</span> <span class="n">tot_e</span><span class="p">:</span>
                <span class="n">info</span> <span class="o">+=</span> <span class="sa">f</span><span class="s2">&quot;&quot;&quot;  </span><span class="si">{</span><span class="n">lbl</span><span class="si">:</span><span class="s2">&gt;8</span><span class="si">}</span><span class="s2"> </span><span class="si">{</span><span class="n">nb</span><span class="si">:</span><span class="s2">3</span><span class="si">}</span><span class="s2">  </span><span class="si">{</span><span class="n">energy_body_dict</span><span class="p">[</span><span class="n">nb</span><span class="p">]</span><span class="si">:</span><span class="s2">20.12f</span><span class="si">}</span><span class="s2">  </span><span class="si">{</span><span class="n">int_e</span><span class="si">:</span><span class="s2">20.12f</span><span class="si">}</span><span class="s2">  </span><span class="si">{</span><span class="n">int_e_kcal</span><span class="si">:</span><span class="s2">20.12f</span><span class="si">}</span><span class="s2">  </span><span class="si">{</span><span class="n">delta_e</span><span class="si">:</span><span class="s2">20.12f</span><span class="si">}</span><span class="s2">  </span><span class="si">{</span><span class="n">delta_e_kcal</span><span class="si">:</span><span class="s2">20.12f</span><span class="si">}</span><span class="se">\n</span><span class="s2">&quot;&quot;&quot;</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">info</span> <span class="o">+=</span> <span class="sa">f</span><span class="s2">&quot;&quot;&quot;  </span><span class="si">{</span><span class="n">lbl</span><span class="si">:</span><span class="s2">&gt;8</span><span class="si">}</span><span class="s2"> </span><span class="si">{</span><span class="n">nb</span><span class="si">:</span><span class="s2">3</span><span class="si">}</span><span class="s2">  </span><span class="si">{</span><span class="s2">&quot;N/A&quot;</span><span class="si">:</span><span class="s2">20</span><span class="si">}</span><span class="s2">  </span><span class="si">{</span><span class="n">int_e</span><span class="si">:</span><span class="s2">20.12f</span><span class="si">}</span><span class="s2">  </span><span class="si">{</span><span class="n">int_e_kcal</span><span class="si">:</span><span class="s2">20.12f</span><span class="si">}</span><span class="s2">  </span><span class="si">{</span><span class="n">delta_e</span><span class="si">:</span><span class="s2">20.12f</span><span class="si">}</span><span class="s2">  </span><span class="si">{</span><span class="n">delta_e_kcal</span><span class="si">:</span><span class="s2">20.12f</span><span class="si">}</span><span class="se">\n</span><span class="s2">&quot;&quot;&quot;</span>
            <span class="n">previous_e</span> <span class="o">=</span> <span class="n">energy_body_dict</span><span class="p">[</span><span class="n">nb</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">info</span> <span class="o">+=</span> <span class="sa">f</span><span class="s2">&quot;&quot;&quot;  </span><span class="si">{</span><span class="n">lbl</span><span class="si">:</span><span class="s2">&gt;8</span><span class="si">}</span><span class="s2"> </span><span class="si">{</span><span class="n">nb</span><span class="si">:</span><span class="s2">3</span><span class="si">}</span><span class="s2">        </span><span class="si">{</span><span class="s2">&quot;N/A&quot;</span><span class="si">:</span><span class="s2">20</span><span class="si">}</span><span class="s2">  </span><span class="si">{</span><span class="s2">&quot;N/A&quot;</span><span class="si">:</span><span class="s2">20</span><span class="si">}</span><span class="s2">  </span><span class="si">{</span><span class="s2">&quot;N/A&quot;</span><span class="si">:</span><span class="s2">20</span><span class="si">}</span><span class="s2">  </span><span class="si">{</span><span class="s2">&quot;N/A&quot;</span><span class="si">:</span><span class="s2">20</span><span class="si">}</span><span class="s2">  </span><span class="si">{</span><span class="s2">&quot;N/A&quot;</span><span class="si">:</span><span class="s2">20</span><span class="si">}</span><span class="se">\n</span><span class="s2">&quot;&quot;&quot;</span>

    <span class="n">info</span> <span class="o">+=</span> <span class="s2">&quot;</span><span class="se">\n</span><span class="s2">&quot;</span>
    <span class="n">core</span><span class="o">.</span><span class="n">print_out</span><span class="p">(</span><span class="n">info</span><span class="p">)</span>
    <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="n">info</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">build_nbody_compute_list</span><span class="p">(</span>
    <span class="n">bsse_type</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">BsseEnum</span><span class="p">],</span>
    <span class="n">nbodies</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="n">Literal</span><span class="p">[</span><span class="s2">&quot;supersystem&quot;</span><span class="p">]]],</span>
    <span class="n">nfragments</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span>
    <span class="n">return_total_data</span><span class="p">:</span> <span class="nb">bool</span><span class="p">,</span>
    <span class="n">verbose</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="n">Set</span><span class="p">[</span><span class="n">FragBasIndex</span><span class="p">]]]:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Generates lists of N-Body computations needed for requested BSSE treatments.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    bsse_type</span>
<span class="sd">        Requested BSSE treatments.</span>
<span class="sd">    nbodies</span>
<span class="sd">        List of n-body levels (e.g., `[2]` or `[1, 2]` or `[&quot;supersystem&quot;]`) for which to generate tasks.</span>
<span class="sd">        Often this value is an element of self.nbodies_per_mc_level.</span>
<span class="sd">        Note the natural 1-indexing, so `[1]` covers one-body contributions.</span>
<span class="sd">        Formerly nbody</span>
<span class="sd">    nfragments</span>
<span class="sd">        Number of distinct fragments comprising the full molecular supersystem. Usually self.nfragments.</span>
<span class="sd">        Formerly max_frag</span>
<span class="sd">    return_total_data</span>
<span class="sd">        Whether the total data (True; energy/gradient/Hessian) of the molecular system has been requested, as opposed to interaction data (False).</span>
<span class="sd">    verbose</span>
<span class="sd">        Control volume of printing.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    compute_dict</span>
<span class="sd">        Dictionary containing subdicts enumerating compute lists for each possible BSSE treatment.</span>
<span class="sd">        Subdict keys are n-body levels and values are sets of all the `mc_(frag, bas)` indices</span>
<span class="sd">        needed to compute that n-body level. A given index can appear multiple times within a</span>
<span class="sd">        subdict and among subdicts.</span>
<span class="sd">        Formerly, the subdict values were sets of indices needed for given BSSE treatment _of_ given</span>
<span class="sd">        n-body level. See current (left) and former (right) definitions below for CP dimer.</span>

<span class="sd">            compute_dict[&quot;cp&quot;] = {                  compute_dict[&quot;cp&quot;] = {</span>
<span class="sd">                1: set(),                               1: {((1,), (1, 2)),</span>
<span class="sd">                2: {((1,), (1, 2)),                         ((2,), (1, 2))},</span>
<span class="sd">                    ((2,), (1, 2)),                     2: {((1, 2), (1, 2))}</span>
<span class="sd">                    ((1, 2), (1, 2))}               }</span>
<span class="sd">            }</span>

<span class="sd">        Subdicts below are always returned. Any may be empty if not requested through *bsse_type*.</span>

<span class="sd">        * ``&#39;all&#39;`` |w---w| full list of computations required</span>
<span class="sd">        * ``&#39;cp&#39;`` |w---w| list of computations required for CP procedure</span>
<span class="sd">        * ``&#39;nocp&#39;`` |w---w| list of computations required for non-CP procedure</span>
<span class="sd">        * ``&#39;vmfc_compute&#39;`` |w---w| list of computations required for VMFC procedure</span>
<span class="sd">        * ``&#39;vmfc_levels&#39;`` |w---w| list of levels required for VMFC procedure</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># What levels do we need?</span>
    <span class="n">fragment_range</span> <span class="o">=</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">nfragments</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>

    <span class="c1"># Need nbodies and all lower-body in full basis</span>
    <span class="n">cp_compute_list</span> <span class="o">=</span> <span class="p">{</span><span class="n">x</span><span class="p">:</span> <span class="nb">set</span><span class="p">()</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">nbodies</span><span class="p">}</span>
    <span class="n">nocp_compute_list</span> <span class="o">=</span> <span class="p">{</span><span class="n">x</span><span class="p">:</span> <span class="nb">set</span><span class="p">()</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">nbodies</span><span class="p">}</span>
    <span class="n">vmfc_compute_list</span> <span class="o">=</span> <span class="p">{</span><span class="n">x</span><span class="p">:</span> <span class="nb">set</span><span class="p">()</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">nbodies</span><span class="p">}</span>
    <span class="n">vmfc_level_list</span> <span class="o">=</span> <span class="p">{</span><span class="n">x</span><span class="p">:</span> <span class="nb">set</span><span class="p">()</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">nbodies</span><span class="p">}</span>  <span class="c1"># Need to sum something slightly different</span>

    <span class="c1"># Verify proper passing of bsse_type. already validated in Computer</span>
    <span class="n">bsse_type_remainder</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">bsse_type</span><span class="p">)</span> <span class="o">-</span> <span class="p">{</span><span class="n">e</span><span class="o">.</span><span class="n">value</span> <span class="k">for</span> <span class="n">e</span> <span class="ow">in</span> <span class="n">BsseEnum</span><span class="p">}</span>
    <span class="k">if</span> <span class="n">bsse_type_remainder</span><span class="p">:</span>
        <span class="k">raise</span> <span class="n">ValidationError</span><span class="p">(</span><span class="s2">&quot;&quot;&quot;Unrecognized BSSE type(s): </span><span class="si">{bsse_type_remainder}</span><span class="s2">&quot;&quot;&quot;</span><span class="p">)</span>

    <span class="c1"># Build up compute sets</span>
    <span class="k">if</span> <span class="s1">&#39;cp&#39;</span> <span class="ow">in</span> <span class="n">bsse_type</span><span class="p">:</span>
        <span class="c1"># Everything is in full n-mer basis</span>
        <span class="n">basis_tuple</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">fragment_range</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">nb</span> <span class="ow">in</span> <span class="n">nbodies</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">nb</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
                <span class="k">for</span> <span class="n">sublevel</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">nb</span> <span class="o">+</span> <span class="mi">1</span><span class="p">):</span>
                    <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">itertools</span><span class="o">.</span><span class="n">combinations</span><span class="p">(</span><span class="n">fragment_range</span><span class="p">,</span> <span class="n">sublevel</span><span class="p">):</span>
                        <span class="c1"># below was `nbodies`, which would never hit. present is closest to pre-DDD. purpose unclear to me.</span>
                        <span class="c1"># if self.max_nbody == 1: break</span>
                        <span class="n">cp_compute_list</span><span class="p">[</span><span class="n">nb</span><span class="p">]</span><span class="o">.</span><span class="n">add</span><span class="p">((</span><span class="n">x</span><span class="p">,</span> <span class="n">basis_tuple</span><span class="p">))</span>

    <span class="k">if</span> <span class="s1">&#39;nocp&#39;</span> <span class="ow">in</span> <span class="n">bsse_type</span> <span class="ow">or</span> <span class="n">return_total_data</span><span class="p">:</span>
        <span class="c1"># Everything in monomer basis</span>
        <span class="k">for</span> <span class="n">nb</span> <span class="ow">in</span> <span class="n">nbodies</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">sublevel</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">nb</span> <span class="o">+</span> <span class="mi">1</span><span class="p">):</span>
                <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">itertools</span><span class="o">.</span><span class="n">combinations</span><span class="p">(</span><span class="n">fragment_range</span><span class="p">,</span> <span class="n">sublevel</span><span class="p">):</span>
                    <span class="n">nocp_compute_list</span><span class="p">[</span><span class="n">nb</span><span class="p">]</span><span class="o">.</span><span class="n">add</span><span class="p">((</span><span class="n">x</span><span class="p">,</span> <span class="n">x</span><span class="p">))</span>

    <span class="k">if</span> <span class="s1">&#39;vmfc&#39;</span> <span class="ow">in</span> <span class="n">bsse_type</span><span class="p">:</span>
        <span class="c1"># Like a CP for all combinations of pairs or greater</span>
        <span class="k">for</span> <span class="n">nb</span> <span class="ow">in</span> <span class="n">nbodies</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">cp_combos</span> <span class="ow">in</span> <span class="n">itertools</span><span class="o">.</span><span class="n">combinations</span><span class="p">(</span><span class="n">fragment_range</span><span class="p">,</span> <span class="n">nb</span><span class="p">):</span>
                <span class="n">basis_tuple</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">cp_combos</span><span class="p">)</span>
                <span class="k">for</span> <span class="n">interior_nbody</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">nb</span> <span class="o">+</span> <span class="mi">1</span><span class="p">):</span>
                    <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">itertools</span><span class="o">.</span><span class="n">combinations</span><span class="p">(</span><span class="n">cp_combos</span><span class="p">,</span> <span class="n">interior_nbody</span><span class="p">):</span>
                        <span class="n">combo_tuple</span> <span class="o">=</span> <span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">basis_tuple</span><span class="p">)</span>
                        <span class="n">vmfc_compute_list</span><span class="p">[</span><span class="n">nb</span><span class="p">]</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">combo_tuple</span><span class="p">)</span>
                        <span class="n">vmfc_level_list</span><span class="p">[</span><span class="nb">len</span><span class="p">(</span><span class="n">basis_tuple</span><span class="p">)]</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">combo_tuple</span><span class="p">)</span>

    <span class="c1"># Build a comprehensive compute range</span>
    <span class="c1"># * do not use list length to count number of {nb}-body computations</span>
    <span class="n">compute_list</span> <span class="o">=</span> <span class="p">{</span><span class="n">x</span><span class="p">:</span> <span class="nb">set</span><span class="p">()</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">nbodies</span><span class="p">}</span>
    <span class="k">for</span> <span class="n">nb</span> <span class="ow">in</span> <span class="n">nbodies</span><span class="p">:</span>
        <span class="n">compute_list</span><span class="p">[</span><span class="n">nb</span><span class="p">]</span> <span class="o">|=</span> <span class="n">cp_compute_list</span><span class="p">[</span><span class="n">nb</span><span class="p">]</span>
        <span class="n">compute_list</span><span class="p">[</span><span class="n">nb</span><span class="p">]</span> <span class="o">|=</span> <span class="n">nocp_compute_list</span><span class="p">[</span><span class="n">nb</span><span class="p">]</span>
        <span class="n">compute_list</span><span class="p">[</span><span class="n">nb</span><span class="p">]</span> <span class="o">|=</span> <span class="n">vmfc_compute_list</span><span class="p">[</span><span class="n">nb</span><span class="p">]</span>

    <span class="c1"># Rearrange compute_list from key nb having values to compute all of that nb</span>
    <span class="c1">#   to key nb including values of that nb. Use for counting.</span>
    <span class="n">compute_list_count</span> <span class="o">=</span> <span class="p">{</span><span class="n">x</span><span class="p">:</span> <span class="nb">set</span><span class="p">()</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">nbodies</span><span class="p">}</span>
    <span class="k">for</span> <span class="n">nb</span> <span class="ow">in</span> <span class="n">nbodies</span><span class="p">:</span>
        <span class="k">for</span> <span class="n">nbset</span> <span class="ow">in</span> <span class="n">compute_list</span><span class="o">.</span><span class="n">values</span><span class="p">():</span>
            <span class="k">for</span> <span class="n">item</span> <span class="ow">in</span> <span class="n">nbset</span><span class="p">:</span>
                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">item</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">==</span> <span class="n">nb</span><span class="p">:</span>
                    <span class="n">compute_list_count</span><span class="p">[</span><span class="n">nb</span><span class="p">]</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">item</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">verbose</span> <span class="o">&gt;=</span> <span class="mi">1</span><span class="p">:</span>
        <span class="n">info</span> <span class="o">=</span> <span class="s2">&quot;</span><span class="se">\n</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">([</span><span class="sa">f</span><span class="s2">&quot;        Number of </span><span class="si">{</span><span class="n">nb</span><span class="si">}</span><span class="s2">-body computations:     </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">compute_list_count</span><span class="p">[</span><span class="n">nb</span><span class="p">])</span><span class="si">}</span><span class="s2">&quot;</span> <span class="k">for</span> <span class="n">nb</span> <span class="ow">in</span> <span class="n">nbodies</span><span class="p">])</span>
        <span class="n">core</span><span class="o">.</span><span class="n">print_out</span><span class="p">(</span><span class="n">info</span> <span class="o">+</span> <span class="s2">&quot;</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="n">info</span><span class="p">)</span>

    <span class="n">compute_dict</span> <span class="o">=</span> <span class="p">{</span>
        <span class="s1">&#39;all&#39;</span><span class="p">:</span> <span class="n">compute_list</span><span class="p">,</span>
        <span class="s1">&#39;cp&#39;</span><span class="p">:</span> <span class="n">cp_compute_list</span><span class="p">,</span>
        <span class="s1">&#39;nocp&#39;</span><span class="p">:</span> <span class="n">nocp_compute_list</span><span class="p">,</span>
        <span class="s1">&#39;vmfc_compute&#39;</span><span class="p">:</span> <span class="n">vmfc_compute_list</span><span class="p">,</span>
        <span class="s1">&#39;vmfc_levels&#39;</span><span class="p">:</span> <span class="n">vmfc_level_list</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="n">compute_dict</span>


<span class="k">def</span> <span class="nf">assemble_nbody_components</span><span class="p">(</span>
    <span class="n">ptype</span><span class="p">:</span> <span class="n">DriverEnum</span><span class="p">,</span>
    <span class="n">component_results</span><span class="p">:</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Union</span><span class="p">[</span><span class="nb">float</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]],</span>
    <span class="n">metadata</span><span class="p">:</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Any</span><span class="p">],</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Any</span><span class="p">]:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Assembles N-body components for a single derivative level and a single model chemistry level into interaction quantities according to requested BSSE treatment(s).</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    ptype</span>
<span class="sd">        Derivative level of component results to assemble. Matters mostly for scalar vs. array and array dimensions.</span>
<span class="sd">    component_results</span>
<span class="sd">        Dictionary with keys &quot;mc_(frag, bas)&quot; and values e/g/H computed component results according to *ptype*.</span>
<span class="sd">    metadata</span>
<span class="sd">        Dictionary of N-body metadata. Items described below.</span>
<span class="sd">        Later, assemble_nbody_components should become a class function and the below are simply class member data.</span>
<span class="sd">    quiet : bool</span>
<span class="sd">        See class field. Whether to print/log energy summaries. Default True. False used by multilevel to suppress per-mc-level printing.</span>
<span class="sd">    nfragments : int</span>
<span class="sd">        See class field. Number of distinct fragments comprising the full molecular supersystem.</span>
<span class="sd">        Formerly max_frag</span>
<span class="sd">    return_total_data : bool</span>
<span class="sd">        See class field. Whether the total data (e/g/H) of the molecular system has been requested, as opposed to interaction data.</span>
<span class="sd">    max_nbody : int</span>
<span class="sd">        See class field. Maximum number of bodies to include in the many-body treatment.&quot;</span>
<span class="sd">    embedding_charges : bool</span>
<span class="sd">        Whether embedding charges are present. Used to NaN the output printing rather than print bad numbers.</span>
<span class="sd">    molecule : psi4.core.Molecule</span>
<span class="sd">        See class field. Used to count atoms in fragments.</span>
<span class="sd">    nbodies_per_mc_level: List[List[Union[int, Literal[&quot;supersystem&quot;]]]]</span>
<span class="sd">        See class field. Distribution of active n-body levels among model chemistry levels.</span>
<span class="sd">        Formerly nbody_list</span>
<span class="sd">    bsse_type : List[BsseEnum]</span>
<span class="sd">        See class field. Requested BSSE treatments. First in list determines which interaction or total energy/gradient/Hessian returned.</span>
<span class="sd">        Note that this is the only arg that gets RESET. Happens for supersystem &quot;nbody&quot;.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    results</span>
<span class="sd">        Dictionary of all N-body results. See contents at ManyBodyComputer.prepare_results docstring.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># which level are we assembling?</span>
    <span class="n">mc_level_labels</span> <span class="o">=</span> <span class="p">{</span><span class="nb">int</span><span class="p">(</span><span class="n">i</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s2">&quot;_&quot;</span><span class="p">)[</span><span class="mi">0</span><span class="p">])</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">component_results</span><span class="o">.</span><span class="n">keys</span><span class="p">()}</span>

    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">mc_level_labels</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">:</span>
        <span class="k">raise</span> <span class="n">ValidationError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Something&#39;s wrong - this fn handles single-level (e.g., 1- &amp; 2-body w/mp2) not multi-level (e.g., 1-body w/hf &amp; 2-body w/mp2) assembly: len(</span><span class="si">{</span><span class="n">mc_level_labels</span><span class="si">}</span><span class="s2">) != 1&quot;</span><span class="p">)</span>

    <span class="c1"># get the range of nbodies for this level</span>
    <span class="c1"># * modelchem level label (mc_level_lbl) used in qcvars and dict keys is 1-indexed counterpart to 0-indexed modelchem level position (mc_level_idx) used to navigate self.nbodies_per_mc_level</span>
    <span class="n">mc_level_lbl</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">mc_level_labels</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">nbodies</span> <span class="o">=</span> <span class="n">metadata</span><span class="p">[</span><span class="s1">&#39;nbodies_per_mc_level&#39;</span><span class="p">][</span><span class="n">mc_level_lbl</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span>
    <span class="k">if</span> <span class="n">nbodies</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="s1">&#39;supersystem&#39;</span><span class="p">:</span>
        <span class="c1"># range for supersystem sub-components</span>
        <span class="n">nbodies</span> <span class="o">=</span> <span class="n">metadata</span><span class="p">[</span><span class="s1">&#39;nbodies_per_mc_level&#39;</span><span class="p">][</span><span class="n">mc_level_lbl</span><span class="p">]</span>
        <span class="n">metadata</span><span class="p">[</span><span class="s1">&#39;bsse_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;nocp&#39;</span><span class="p">]</span>

    <span class="c1"># regenerate per-bsse required calcs list</span>
    <span class="n">compute_dict</span> <span class="o">=</span> <span class="n">build_nbody_compute_list</span><span class="p">(</span>
        <span class="n">metadata</span><span class="p">[</span><span class="s1">&#39;bsse_type&#39;</span><span class="p">],</span> <span class="n">nbodies</span><span class="p">,</span> <span class="n">metadata</span><span class="p">[</span><span class="s1">&#39;nfragments&#39;</span><span class="p">],</span> <span class="n">metadata</span><span class="p">[</span><span class="s2">&quot;return_total_data&quot;</span><span class="p">],</span> <span class="n">verbose</span><span class="o">=</span><span class="mi">0</span>
    <span class="p">)</span>

    <span class="c1"># Build size and slices dictionaries</span>
    <span class="n">fragment_size_dict</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="n">fragment_slice_dict</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="n">iat</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">for</span> <span class="n">ifr</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">metadata</span><span class="p">[</span><span class="s2">&quot;nfragments&quot;</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span><span class="p">):</span>
        <span class="n">nat</span> <span class="o">=</span> <span class="n">metadata</span><span class="p">[</span><span class="s2">&quot;molecule&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">extract_subsets</span><span class="p">(</span><span class="n">ifr</span><span class="p">)</span><span class="o">.</span><span class="n">natom</span><span class="p">()</span>
        <span class="n">fragment_size_dict</span><span class="p">[</span><span class="n">ifr</span><span class="p">]</span> <span class="o">=</span> <span class="n">nat</span>
        <span class="n">fragment_slice_dict</span><span class="p">[</span><span class="n">ifr</span><span class="p">]</span> <span class="o">=</span> <span class="nb">slice</span><span class="p">(</span><span class="n">iat</span><span class="p">,</span> <span class="n">iat</span> <span class="o">+</span> <span class="n">nat</span><span class="p">)</span>
        <span class="n">iat</span> <span class="o">+=</span> <span class="n">nat</span>

    <span class="k">def</span> <span class="nf">shaped_zero</span><span class="p">(</span><span class="n">der</span><span class="p">:</span> <span class="n">DriverEnum</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">der</span> <span class="o">==</span> <span class="s2">&quot;energy&quot;</span><span class="p">:</span>
            <span class="k">return</span> <span class="mf">0.0</span>
        <span class="k">elif</span> <span class="n">der</span> <span class="o">==</span> <span class="s2">&quot;gradient&quot;</span><span class="p">:</span>
            <span class="n">arr_shape</span> <span class="o">=</span> <span class="p">(</span><span class="n">nat</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">arr_shape</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">der</span> <span class="o">==</span> <span class="s1">&#39;hessian&#39;</span><span class="p">:</span>
            <span class="n">arr_shape</span> <span class="o">=</span> <span class="p">(</span><span class="n">nat</span> <span class="o">*</span> <span class="mi">3</span><span class="p">,</span> <span class="n">nat</span> <span class="o">*</span> <span class="mi">3</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">arr_shape</span><span class="p">)</span>

    <span class="c1"># Final dictionaries</span>
    <span class="k">if</span> <span class="n">ptype</span> <span class="o">==</span> <span class="s2">&quot;energy&quot;</span><span class="p">:</span>
        <span class="n">cp_by_level</span> <span class="o">=</span> <span class="p">{</span><span class="n">n</span><span class="p">:</span> <span class="mf">0.0</span> <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">nbodies</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)}</span>
        <span class="n">nocp_by_level</span> <span class="o">=</span> <span class="p">{</span><span class="n">n</span><span class="p">:</span> <span class="mf">0.0</span> <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">nbodies</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)}</span>
        <span class="n">vmfc_by_level</span> <span class="o">=</span> <span class="p">{</span><span class="n">n</span><span class="p">:</span> <span class="mf">0.0</span> <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">nbodies</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)}</span>

        <span class="n">cp_body_dict</span> <span class="o">=</span> <span class="p">{</span><span class="n">n</span><span class="p">:</span> <span class="mf">0.0</span> <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">nbodies</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)}</span>
        <span class="n">nocp_body_dict</span> <span class="o">=</span> <span class="p">{</span><span class="n">n</span><span class="p">:</span> <span class="mf">0.0</span> <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">nbodies</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)}</span>
        <span class="n">vmfc_body_dict</span> <span class="o">=</span> <span class="p">{</span><span class="n">n</span><span class="p">:</span> <span class="mf">0.0</span> <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">nbodies</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)}</span>

    <span class="k">else</span><span class="p">:</span>
        <span class="n">nat</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">(</span><span class="n">fragment_size_dict</span><span class="o">.</span><span class="n">values</span><span class="p">())</span>
        <span class="k">if</span> <span class="n">ptype</span> <span class="o">==</span> <span class="s1">&#39;gradient&#39;</span><span class="p">:</span>
            <span class="n">arr_shape</span> <span class="o">=</span> <span class="p">(</span><span class="n">nat</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">ptype</span> <span class="o">==</span> <span class="s1">&#39;hessian&#39;</span><span class="p">:</span>
            <span class="n">arr_shape</span> <span class="o">=</span> <span class="p">(</span><span class="n">nat</span> <span class="o">*</span> <span class="mi">3</span><span class="p">,</span> <span class="n">nat</span> <span class="o">*</span> <span class="mi">3</span><span class="p">)</span>

        <span class="n">cp_by_level</span> <span class="o">=</span> <span class="p">{</span><span class="n">n</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">arr_shape</span><span class="p">)</span> <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">nbodies</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)}</span>
        <span class="n">nocp_by_level</span> <span class="o">=</span> <span class="p">{</span><span class="n">n</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">arr_shape</span><span class="p">)</span> <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">nbodies</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)}</span>
        <span class="n">vmfc_by_level</span> <span class="o">=</span> <span class="p">{</span><span class="n">n</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">arr_shape</span><span class="p">)</span> <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">nbodies</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)}</span>

        <span class="n">cp_body_dict</span> <span class="o">=</span> <span class="p">{</span><span class="n">n</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">arr_shape</span><span class="p">)</span> <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">nbodies</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)}</span>
        <span class="n">nocp_body_dict</span> <span class="o">=</span> <span class="p">{</span><span class="n">n</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">arr_shape</span><span class="p">)</span> <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">nbodies</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)}</span>
        <span class="n">vmfc_body_dict</span> <span class="o">=</span> <span class="p">{</span><span class="n">n</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">arr_shape</span><span class="p">)</span> <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">nbodies</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)}</span>

    <span class="c1"># Sum up all of the levels</span>
    <span class="c1"># * compute_dict[bt][nb] holds all the computations needed to compute nb</span>
    <span class="c1">#   *not* all the nb-level computations, so build the latter</span>
    <span class="n">cp_compute_list</span> <span class="o">=</span> <span class="p">{</span><span class="n">nb</span><span class="p">:</span> <span class="nb">set</span><span class="p">()</span> <span class="k">for</span> <span class="n">nb</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">nbodies</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)}</span>
    <span class="n">nocp_compute_list</span> <span class="o">=</span> <span class="p">{</span><span class="n">nb</span><span class="p">:</span> <span class="nb">set</span><span class="p">()</span> <span class="k">for</span> <span class="n">nb</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">nbodies</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)}</span>

    <span class="k">for</span> <span class="n">nb</span> <span class="ow">in</span> <span class="n">nbodies</span><span class="p">:</span>
        <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">compute_dict</span><span class="p">[</span><span class="s2">&quot;cp&quot;</span><span class="p">][</span><span class="n">nb</span><span class="p">]:</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">v</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">:</span>
                <span class="n">cp_compute_list</span><span class="p">[</span><span class="nb">len</span><span class="p">(</span><span class="n">v</span><span class="p">[</span><span class="mi">0</span><span class="p">])]</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">v</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">w</span> <span class="ow">in</span> <span class="n">compute_dict</span><span class="p">[</span><span class="s2">&quot;nocp&quot;</span><span class="p">][</span><span class="n">nb</span><span class="p">]:</span>
            <span class="n">nocp_compute_list</span><span class="p">[</span><span class="nb">len</span><span class="p">(</span><span class="n">w</span><span class="p">[</span><span class="mi">0</span><span class="p">])]</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">w</span><span class="p">)</span>

    <span class="k">for</span> <span class="n">nb</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">nbodies</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span><span class="p">):</span>
        <span class="n">cp_by_level</span><span class="p">[</span><span class="n">nb</span><span class="p">]</span> <span class="o">=</span> <span class="n">_sum_cluster_ptype_data</span><span class="p">(</span>
            <span class="n">ptype</span><span class="p">,</span>
            <span class="n">component_results</span><span class="p">,</span>
            <span class="n">cp_compute_list</span><span class="p">[</span><span class="n">nb</span><span class="p">],</span>
            <span class="n">fragment_slice_dict</span><span class="p">,</span>
            <span class="n">fragment_size_dict</span><span class="p">,</span>
            <span class="n">mc_level_lbl</span><span class="o">=</span><span class="n">mc_level_lbl</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="n">nocp_by_level</span><span class="p">[</span><span class="n">nb</span><span class="p">]</span> <span class="o">=</span> <span class="n">_sum_cluster_ptype_data</span><span class="p">(</span>
            <span class="n">ptype</span><span class="p">,</span>
            <span class="n">component_results</span><span class="p">,</span>
            <span class="n">nocp_compute_list</span><span class="p">[</span><span class="n">nb</span><span class="p">],</span>
            <span class="n">fragment_slice_dict</span><span class="p">,</span>
            <span class="n">fragment_size_dict</span><span class="p">,</span>
            <span class="n">mc_level_lbl</span><span class="o">=</span><span class="n">mc_level_lbl</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="k">if</span> <span class="n">nb</span> <span class="ow">in</span> <span class="n">compute_dict</span><span class="p">[</span><span class="s2">&quot;vmfc_levels&quot;</span><span class="p">]:</span>
            <span class="n">vmfc_by_level</span><span class="p">[</span><span class="n">nb</span><span class="p">]</span> <span class="o">=</span> <span class="n">_sum_cluster_ptype_data</span><span class="p">(</span>
                <span class="n">ptype</span><span class="p">,</span>
                <span class="n">component_results</span><span class="p">,</span>
                <span class="n">compute_dict</span><span class="p">[</span><span class="s2">&quot;vmfc_levels&quot;</span><span class="p">][</span><span class="n">nb</span><span class="p">],</span>
                <span class="n">fragment_slice_dict</span><span class="p">,</span>
                <span class="n">fragment_size_dict</span><span class="p">,</span>
                <span class="n">vmfc</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                <span class="n">nb</span><span class="o">=</span><span class="n">nb</span><span class="p">,</span>
                <span class="n">mc_level_lbl</span><span class="o">=</span><span class="n">mc_level_lbl</span><span class="p">,</span>
            <span class="p">)</span>

    <span class="k">def</span> <span class="nf">labeler</span><span class="p">(</span><span class="n">item</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
        <span class="k">return</span> <span class="nb">str</span><span class="p">(</span><span class="n">mc_level_lbl</span><span class="p">)</span> <span class="o">+</span> <span class="s2">&quot;_&quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">item</span><span class="p">)</span>

    <span class="c1"># Extract data for monomers in monomer basis for CP total data</span>
    <span class="k">if</span> <span class="mi">1</span> <span class="ow">in</span> <span class="n">nbodies</span><span class="p">:</span>
        <span class="n">monomers_in_monomer_basis</span> <span class="o">=</span> <span class="p">[</span><span class="n">v</span> <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">compute_dict</span><span class="p">[</span><span class="s2">&quot;nocp&quot;</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span> <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">v</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span> <span class="o">==</span> <span class="mi">1</span><span class="p">]</span>

        <span class="k">if</span> <span class="n">ptype</span> <span class="o">==</span> <span class="s2">&quot;energy&quot;</span><span class="p">:</span>
            <span class="n">monomer_energy_list</span> <span class="o">=</span> <span class="p">[</span><span class="n">component_results</span><span class="p">[</span><span class="n">labeler</span><span class="p">(</span><span class="n">m</span><span class="p">)]</span> <span class="k">for</span> <span class="n">m</span> <span class="ow">in</span> <span class="n">monomers_in_monomer_basis</span><span class="p">]</span>
            <span class="n">monomer_sum</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">(</span><span class="n">monomer_energy_list</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">monomer_sum</span> <span class="o">=</span> <span class="n">_sum_cluster_ptype_data</span><span class="p">(</span>
                <span class="n">ptype</span><span class="p">,</span>
                <span class="n">component_results</span><span class="p">,</span>
                <span class="n">monomers_in_monomer_basis</span><span class="p">,</span>
                <span class="n">fragment_slice_dict</span><span class="p">,</span>
                <span class="n">fragment_size_dict</span><span class="p">,</span>
                <span class="n">mc_level_lbl</span><span class="o">=</span><span class="n">mc_level_lbl</span><span class="p">,</span>
            <span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">monomer_sum</span> <span class="o">=</span> <span class="n">shaped_zero</span><span class="p">(</span><span class="n">ptype</span><span class="p">)</span>

    <span class="n">nbody_dict</span> <span class="o">=</span> <span class="p">{}</span>

    <span class="c1"># Compute cp</span>
    <span class="k">if</span> <span class="s1">&#39;cp&#39;</span> <span class="ow">in</span> <span class="n">metadata</span><span class="p">[</span><span class="s1">&#39;bsse_type&#39;</span><span class="p">]:</span>
        <span class="k">for</span> <span class="n">nb</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">nbodies</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">nb</span> <span class="o">==</span> <span class="n">metadata</span><span class="p">[</span><span class="s1">&#39;nfragments&#39;</span><span class="p">]:</span>
                <span class="k">if</span> <span class="n">ptype</span> <span class="o">==</span> <span class="s2">&quot;energy&quot;</span><span class="p">:</span>
                    <span class="n">cp_body_dict</span><span class="p">[</span><span class="n">nb</span><span class="p">]</span> <span class="o">=</span> <span class="n">cp_by_level</span><span class="p">[</span><span class="n">nb</span><span class="p">]</span> <span class="o">-</span> <span class="n">bsse</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">cp_body_dict</span><span class="p">[</span><span class="n">nb</span><span class="p">][:]</span> <span class="o">=</span> <span class="n">cp_by_level</span><span class="p">[</span><span class="n">nb</span><span class="p">]</span> <span class="o">-</span> <span class="n">bsse</span>
                <span class="k">continue</span>

            <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">nb</span> <span class="o">+</span> <span class="mi">1</span><span class="p">):</span>
                <span class="n">take_nk</span> <span class="o">=</span> <span class="n">math</span><span class="o">.</span><span class="n">comb</span><span class="p">(</span><span class="n">metadata</span><span class="p">[</span><span class="s1">&#39;nfragments&#39;</span><span class="p">]</span> <span class="o">-</span> <span class="n">k</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">nb</span> <span class="o">-</span> <span class="n">k</span><span class="p">)</span>
                <span class="n">sign</span> <span class="o">=</span> <span class="p">((</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="o">**</span><span class="p">(</span><span class="n">nb</span> <span class="o">-</span> <span class="n">k</span><span class="p">))</span>
                <span class="n">cp_body_dict</span><span class="p">[</span><span class="n">nb</span><span class="p">]</span> <span class="o">+=</span> <span class="n">take_nk</span> <span class="o">*</span> <span class="n">sign</span> <span class="o">*</span> <span class="n">cp_by_level</span><span class="p">[</span><span class="n">k</span><span class="p">]</span>

            <span class="k">if</span> <span class="n">nb</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                <span class="n">bsse</span> <span class="o">=</span> <span class="n">cp_body_dict</span><span class="p">[</span><span class="n">nb</span><span class="p">]</span> <span class="o">-</span> <span class="n">monomer_sum</span>
                <span class="k">if</span> <span class="n">ptype</span> <span class="o">==</span> <span class="s2">&quot;energy&quot;</span><span class="p">:</span>
                    <span class="n">cp_body_dict</span><span class="p">[</span><span class="n">nb</span><span class="p">]</span> <span class="o">=</span> <span class="n">monomer_sum</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">cp_body_dict</span><span class="p">[</span><span class="n">nb</span><span class="p">]</span> <span class="o">=</span> <span class="n">monomer_sum</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">cp_body_dict</span><span class="p">[</span><span class="n">nb</span><span class="p">]</span> <span class="o">-=</span> <span class="n">bsse</span>

        <span class="k">if</span> <span class="n">ptype</span> <span class="o">==</span> <span class="s2">&quot;energy&quot;</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">metadata</span><span class="p">[</span><span class="s2">&quot;quiet&quot;</span><span class="p">]:</span>
                <span class="n">_print_nbody_energy</span><span class="p">(</span><span class="n">cp_body_dict</span><span class="p">,</span> <span class="s2">&quot;Counterpoise Corrected (CP)&quot;</span><span class="p">,</span> <span class="n">metadata</span><span class="p">[</span><span class="s2">&quot;nfragments&quot;</span><span class="p">],</span> <span class="n">metadata</span><span class="p">[</span><span class="s1">&#39;embedding_charges&#39;</span><span class="p">])</span>

            <span class="k">if</span> <span class="n">monomer_sum</span> <span class="o">!=</span> <span class="mf">0.0</span><span class="p">:</span>
                <span class="n">nbody_dict</span><span class="p">[</span><span class="s2">&quot;CP-CORRECTED TOTAL ENERGY&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">cp_body_dict</span><span class="p">[</span><span class="n">metadata</span><span class="p">[</span><span class="s1">&#39;max_nbody&#39;</span><span class="p">]]</span>
            <span class="n">nbody_dict</span><span class="p">[</span><span class="s2">&quot;CP-CORRECTED INTERACTION ENERGY&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">cp_body_dict</span><span class="p">[</span><span class="n">metadata</span><span class="p">[</span><span class="s1">&#39;max_nbody&#39;</span><span class="p">]]</span> <span class="o">-</span> <span class="n">cp_body_dict</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>

            <span class="k">for</span> <span class="n">nb</span> <span class="ow">in</span> <span class="n">nbodies</span><span class="p">[</span><span class="mi">1</span><span class="p">:]:</span>
                <span class="n">nbody_dict</span><span class="p">[</span><span class="sa">f</span><span class="s2">&quot;CP-CORRECTED INTERACTION ENERGY THROUGH </span><span class="si">{</span><span class="n">nb</span><span class="si">}</span><span class="s2">-BODY&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">cp_body_dict</span><span class="p">[</span><span class="n">nb</span><span class="p">]</span> <span class="o">-</span> <span class="n">cp_body_dict</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
                <span class="n">nbody_dict</span><span class="p">[</span><span class="sa">f</span><span class="s2">&quot;CP-CORRECTED </span><span class="si">{</span><span class="n">nb</span><span class="si">}</span><span class="s2">-BODY CONTRIBUTION TO ENERGY&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">cp_body_dict</span><span class="p">[</span><span class="n">nb</span><span class="p">]</span> <span class="o">-</span> <span class="n">cp_body_dict</span><span class="p">[</span><span class="n">nb</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
            <span class="k">for</span> <span class="n">nb</span> <span class="ow">in</span> <span class="n">nbodies</span><span class="p">:</span>
                <span class="n">nbody_dict</span><span class="p">[</span><span class="sa">f</span><span class="s2">&quot;CP-CORRECTED TOTAL ENERGY THROUGH </span><span class="si">{</span><span class="n">nb</span><span class="si">}</span><span class="s2">-BODY&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">cp_body_dict</span><span class="p">[</span><span class="n">nb</span><span class="p">]</span>

    <span class="c1"># Compute nocp</span>
    <span class="k">if</span> <span class="s1">&#39;nocp&#39;</span> <span class="ow">in</span> <span class="n">metadata</span><span class="p">[</span><span class="s1">&#39;bsse_type&#39;</span><span class="p">]:</span>
        <span class="k">for</span> <span class="n">nb</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">nbodies</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">nb</span> <span class="o">==</span> <span class="n">metadata</span><span class="p">[</span><span class="s1">&#39;nfragments&#39;</span><span class="p">]:</span>
                <span class="k">if</span> <span class="n">ptype</span> <span class="o">==</span> <span class="s2">&quot;energy&quot;</span><span class="p">:</span>
                    <span class="n">nocp_body_dict</span><span class="p">[</span><span class="n">nb</span><span class="p">]</span> <span class="o">=</span> <span class="n">nocp_by_level</span><span class="p">[</span><span class="n">nb</span><span class="p">]</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">nocp_body_dict</span><span class="p">[</span><span class="n">nb</span><span class="p">][:]</span> <span class="o">=</span> <span class="n">nocp_by_level</span><span class="p">[</span><span class="n">nb</span><span class="p">]</span>
                <span class="k">continue</span>

            <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">nb</span> <span class="o">+</span> <span class="mi">1</span><span class="p">):</span>
                <span class="n">take_nk</span> <span class="o">=</span> <span class="n">math</span><span class="o">.</span><span class="n">comb</span><span class="p">(</span><span class="n">metadata</span><span class="p">[</span><span class="s1">&#39;nfragments&#39;</span><span class="p">]</span> <span class="o">-</span> <span class="n">k</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">nb</span> <span class="o">-</span> <span class="n">k</span><span class="p">)</span>
                <span class="n">sign</span> <span class="o">=</span> <span class="p">((</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="o">**</span><span class="p">(</span><span class="n">nb</span> <span class="o">-</span> <span class="n">k</span><span class="p">))</span>
                <span class="n">nocp_body_dict</span><span class="p">[</span><span class="n">nb</span><span class="p">]</span> <span class="o">+=</span> <span class="n">take_nk</span> <span class="o">*</span> <span class="n">sign</span> <span class="o">*</span> <span class="n">nocp_by_level</span><span class="p">[</span><span class="n">k</span><span class="p">]</span>

        <span class="k">if</span> <span class="n">ptype</span> <span class="o">==</span> <span class="s2">&quot;energy&quot;</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">metadata</span><span class="p">[</span><span class="s2">&quot;quiet&quot;</span><span class="p">]:</span>
                <span class="n">_print_nbody_energy</span><span class="p">(</span><span class="n">nocp_body_dict</span><span class="p">,</span> <span class="s2">&quot;Non-Counterpoise Corrected (NoCP)&quot;</span><span class="p">,</span> <span class="n">metadata</span><span class="p">[</span><span class="s2">&quot;nfragments&quot;</span><span class="p">],</span> <span class="n">metadata</span><span class="p">[</span><span class="s1">&#39;embedding_charges&#39;</span><span class="p">])</span>

            <span class="n">nbody_dict</span><span class="p">[</span><span class="s1">&#39;NOCP-CORRECTED TOTAL ENERGY&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">nocp_body_dict</span><span class="p">[</span><span class="n">metadata</span><span class="p">[</span><span class="s1">&#39;max_nbody&#39;</span><span class="p">]]</span>
            <span class="n">nbody_dict</span><span class="p">[</span><span class="s1">&#39;NOCP-CORRECTED INTERACTION ENERGY&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">nocp_body_dict</span><span class="p">[</span><span class="n">metadata</span><span class="p">[</span><span class="s1">&#39;max_nbody&#39;</span><span class="p">]]</span> <span class="o">-</span> <span class="n">nocp_body_dict</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>

            <span class="k">for</span> <span class="n">nb</span> <span class="ow">in</span> <span class="n">nbodies</span><span class="p">[</span><span class="mi">1</span><span class="p">:]:</span>
                <span class="n">nbody_dict</span><span class="p">[</span><span class="sa">f</span><span class="s2">&quot;NOCP-CORRECTED INTERACTION ENERGY THROUGH </span><span class="si">{</span><span class="n">nb</span><span class="si">}</span><span class="s2">-BODY&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">nocp_body_dict</span><span class="p">[</span><span class="n">nb</span><span class="p">]</span> <span class="o">-</span> <span class="n">nocp_body_dict</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
                <span class="n">nbody_dict</span><span class="p">[</span><span class="sa">f</span><span class="s2">&quot;NOCP-CORRECTED </span><span class="si">{</span><span class="n">nb</span><span class="si">}</span><span class="s2">-BODY CONTRIBUTION TO ENERGY&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">nocp_body_dict</span><span class="p">[</span><span class="n">nb</span><span class="p">]</span> <span class="o">-</span> <span class="n">nocp_body_dict</span><span class="p">[</span><span class="n">nb</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
            <span class="k">for</span> <span class="n">nb</span> <span class="ow">in</span> <span class="n">nbodies</span><span class="p">:</span>
                <span class="n">nbody_dict</span><span class="p">[</span><span class="sa">f</span><span class="s2">&quot;NOCP-CORRECTED TOTAL ENERGY THROUGH </span><span class="si">{</span><span class="n">nb</span><span class="si">}</span><span class="s2">-BODY&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">nocp_body_dict</span><span class="p">[</span><span class="n">nb</span><span class="p">]</span>

    <span class="c1"># Compute vmfc</span>
    <span class="k">if</span> <span class="s1">&#39;vmfc&#39;</span> <span class="ow">in</span> <span class="n">metadata</span><span class="p">[</span><span class="s1">&#39;bsse_type&#39;</span><span class="p">]:</span>
        <span class="k">for</span> <span class="n">nb</span> <span class="ow">in</span> <span class="n">nbodies</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">ptype</span> <span class="o">==</span> <span class="s2">&quot;energy&quot;</span><span class="p">:</span>
                <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">nb</span> <span class="o">+</span> <span class="mi">1</span><span class="p">):</span>
                    <span class="n">vmfc_body_dict</span><span class="p">[</span><span class="n">nb</span><span class="p">]</span> <span class="o">+=</span> <span class="n">vmfc_by_level</span><span class="p">[</span><span class="n">k</span><span class="p">]</span>

            <span class="k">else</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">nb</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
                    <span class="n">vmfc_body_dict</span><span class="p">[</span><span class="n">nb</span><span class="p">]</span> <span class="o">=</span> <span class="n">vmfc_by_level</span><span class="p">[</span><span class="n">nb</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span>
                <span class="n">vmfc_body_dict</span><span class="p">[</span><span class="n">nb</span><span class="p">]</span> <span class="o">+=</span> <span class="n">vmfc_by_level</span><span class="p">[</span><span class="n">nb</span><span class="p">]</span>

        <span class="k">if</span> <span class="n">ptype</span> <span class="o">==</span> <span class="s2">&quot;energy&quot;</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">metadata</span><span class="p">[</span><span class="s2">&quot;quiet&quot;</span><span class="p">]:</span>
                <span class="n">_print_nbody_energy</span><span class="p">(</span><span class="n">vmfc_body_dict</span><span class="p">,</span> <span class="s2">&quot;Valiron-Mayer Function Counterpoise (VMFC)&quot;</span><span class="p">,</span> <span class="n">metadata</span><span class="p">[</span><span class="s2">&quot;nfragments&quot;</span><span class="p">],</span> <span class="n">metadata</span><span class="p">[</span><span class="s1">&#39;embedding_charges&#39;</span><span class="p">])</span>

            <span class="n">vmfc_interaction_energy</span> <span class="o">=</span> <span class="n">vmfc_body_dict</span><span class="p">[</span><span class="n">metadata</span><span class="p">[</span><span class="s1">&#39;max_nbody&#39;</span><span class="p">]]</span> <span class="o">-</span> <span class="n">vmfc_body_dict</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
            <span class="n">nbody_dict</span><span class="p">[</span><span class="s1">&#39;VMFC-CORRECTED TOTAL ENERGY&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">vmfc_body_dict</span><span class="p">[</span><span class="n">metadata</span><span class="p">[</span><span class="s1">&#39;max_nbody&#39;</span><span class="p">]]</span>
            <span class="n">nbody_dict</span><span class="p">[</span><span class="s1">&#39;VMFC-CORRECTED INTERACTION ENERGY&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">vmfc_interaction_energy</span>

            <span class="k">for</span> <span class="n">nb</span> <span class="ow">in</span> <span class="n">nbodies</span><span class="p">[</span><span class="mi">1</span><span class="p">:]:</span>
                <span class="n">nbody_dict</span><span class="p">[</span><span class="sa">f</span><span class="s2">&quot;VMFC-CORRECTED INTERACTION ENERGY THROUGH </span><span class="si">{</span><span class="n">nb</span><span class="si">}</span><span class="s2">-BODY&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">vmfc_body_dict</span><span class="p">[</span><span class="n">nb</span><span class="p">]</span> <span class="o">-</span> <span class="n">vmfc_body_dict</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
                <span class="n">nbody_dict</span><span class="p">[</span><span class="sa">f</span><span class="s2">&quot;VMFC-CORRECTED </span><span class="si">{</span><span class="n">nb</span><span class="si">}</span><span class="s2">-BODY CONTRIBUTION TO ENERGY&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">vmfc_body_dict</span><span class="p">[</span><span class="n">nb</span><span class="p">]</span> <span class="o">-</span> <span class="n">vmfc_body_dict</span><span class="p">[</span><span class="n">nb</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
            <span class="k">for</span> <span class="n">nb</span> <span class="ow">in</span> <span class="n">nbodies</span><span class="p">:</span>
                <span class="n">nbody_dict</span><span class="p">[</span><span class="sa">f</span><span class="s2">&quot;VMFC-CORRECTED TOTAL ENERGY THROUGH </span><span class="si">{</span><span class="n">nb</span><span class="si">}</span><span class="s2">-BODY&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">vmfc_body_dict</span><span class="p">[</span><span class="n">nb</span><span class="p">]</span>

    <span class="c1"># Collect specific and generalized returns</span>
    <span class="n">results</span> <span class="o">=</span> <span class="p">{</span>
        <span class="sa">f</span><span class="s2">&quot;cp_</span><span class="si">{</span><span class="n">ptype</span><span class="si">}</span><span class="s2">_body_dict&quot;</span> <span class="p">:</span> <span class="p">{</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">nb</span><span class="si">}</span><span class="s2">cp&quot;</span><span class="p">:</span> <span class="n">j</span> <span class="k">for</span> <span class="n">nb</span><span class="p">,</span> <span class="n">j</span> <span class="ow">in</span> <span class="n">cp_body_dict</span><span class="o">.</span><span class="n">items</span><span class="p">()},</span>
        <span class="sa">f</span><span class="s2">&quot;nocp_</span><span class="si">{</span><span class="n">ptype</span><span class="si">}</span><span class="s2">_body_dict&quot;</span><span class="p">:</span> <span class="p">{</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">nb</span><span class="si">}</span><span class="s2">nocp&quot;</span><span class="p">:</span> <span class="n">j</span> <span class="k">for</span> <span class="n">nb</span><span class="p">,</span> <span class="n">j</span> <span class="ow">in</span> <span class="n">nocp_body_dict</span><span class="o">.</span><span class="n">items</span><span class="p">()},</span>
        <span class="sa">f</span><span class="s2">&quot;vmfc_</span><span class="si">{</span><span class="n">ptype</span><span class="si">}</span><span class="s2">_body_dict&quot;</span><span class="p">:</span> <span class="p">{</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">nb</span><span class="si">}</span><span class="s2">vmfc&quot;</span><span class="p">:</span> <span class="n">j</span> <span class="k">for</span> <span class="n">nb</span><span class="p">,</span> <span class="n">j</span> <span class="ow">in</span> <span class="n">vmfc_body_dict</span><span class="o">.</span><span class="n">items</span><span class="p">()},</span>
    <span class="p">}</span>

    <span class="k">if</span> <span class="n">ptype</span> <span class="o">==</span> <span class="s2">&quot;energy&quot;</span><span class="p">:</span>
        <span class="n">results</span><span class="p">[</span><span class="s1">&#39;nbody&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">nbody_dict</span>

    <span class="n">return_bsse_type</span> <span class="o">=</span> <span class="n">metadata</span><span class="p">[</span><span class="s2">&quot;bsse_type&quot;</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>

    <span class="k">if</span> <span class="n">return_bsse_type</span> <span class="o">==</span> <span class="s2">&quot;cp&quot;</span><span class="p">:</span>
        <span class="n">results</span><span class="p">[</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">ptype</span><span class="si">}</span><span class="s2">_body_dict&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">cp_body_dict</span>
    <span class="k">elif</span> <span class="n">return_bsse_type</span> <span class="o">==</span> <span class="s2">&quot;nocp&quot;</span><span class="p">:</span>
        <span class="n">results</span><span class="p">[</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">ptype</span><span class="si">}</span><span class="s2">_body_dict&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">nocp_body_dict</span>
    <span class="k">elif</span> <span class="n">return_bsse_type</span> <span class="o">==</span> <span class="s2">&quot;vmfc&quot;</span><span class="p">:</span>
        <span class="n">results</span><span class="p">[</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">ptype</span><span class="si">}</span><span class="s2">_body_dict&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">vmfc_body_dict</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">raise</span> <span class="n">ValidationError</span><span class="p">(</span>
            <span class="s2">&quot;N-Body Wrapper: Invalid return type. Should never be here, please post this error on github.&quot;</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">ptype</span> <span class="o">==</span> <span class="s2">&quot;energy&quot;</span><span class="p">:</span>
        <span class="n">piece</span> <span class="o">=</span> <span class="n">results</span><span class="p">[</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">ptype</span><span class="si">}</span><span class="s2">_body_dict&quot;</span><span class="p">][</span><span class="n">metadata</span><span class="p">[</span><span class="s1">&#39;max_nbody&#39;</span><span class="p">]]</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">piece</span> <span class="o">=</span> <span class="n">results</span><span class="p">[</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">ptype</span><span class="si">}</span><span class="s2">_body_dict&quot;</span><span class="p">][</span><span class="n">metadata</span><span class="p">[</span><span class="s1">&#39;max_nbody&#39;</span><span class="p">]]</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>

    <span class="k">if</span> <span class="n">metadata</span><span class="p">[</span><span class="s1">&#39;return_total_data&#39;</span><span class="p">]:</span>
        <span class="n">results</span><span class="p">[</span><span class="sa">f</span><span class="s2">&quot;ret_</span><span class="si">{</span><span class="n">ptype</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">piece</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">results</span><span class="p">[</span><span class="sa">f</span><span class="s2">&quot;ret_</span><span class="si">{</span><span class="n">ptype</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">piece</span>
        <span class="n">results</span><span class="p">[</span><span class="sa">f</span><span class="s2">&quot;ret_</span><span class="si">{</span><span class="n">ptype</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">]</span> <span class="o">-=</span> <span class="n">results</span><span class="p">[</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">ptype</span><span class="si">}</span><span class="s2">_body_dict&quot;</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span>

    <span class="n">results</span><span class="p">[</span><span class="s1">&#39;ret_ptype&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">results</span><span class="p">[</span><span class="sa">f</span><span class="s2">&quot;ret_</span><span class="si">{</span><span class="n">ptype</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">]</span>

    <span class="k">return</span> <span class="n">results</span>


<div class="viewcode-block" id="ManyBodyComputer"><a class="viewcode-back" href="../../../nbody.html#psi4.driver.driver_nbody.ManyBodyComputer">[docs]</a><span class="k">class</span> <span class="nc">ManyBodyComputer</span><span class="p">(</span><span class="n">BaseComputer</span><span class="p">):</span>
    <span class="c1"># user kwargs (all but levels become fields)</span>
    <span class="c1"># ------------------------------------------</span>
    <span class="c1"># * bsse_type</span>
    <span class="c1"># * levels</span>
    <span class="c1"># * max_nbody</span>
    <span class="c1"># * molecule  -- general</span>
    <span class="c1"># * return_total_data</span>
    <span class="c1"># * return_wfn -- general</span>

    <span class="c1"># fields set in construction</span>
    <span class="c1"># --------------------------</span>
    <span class="c1"># * nfragments (&lt;- max_frag) -- from molecule</span>

    <span class="c1"># fields set in task_planner</span>
    <span class="c1"># --------------------------</span>
    <span class="c1"># * max_nbody -- from levels</span>
    <span class="c1"># * nbodies_per_mc_level -- from levels</span>

    <span class="c1"># TODO perhaps rework levels kwarg so that it&#39;s processed in class init into nbodies_per_mc_level. Right now, levels resets max_nbody.</span>
    <span class="c1"># TODO also, perhaps change nbodies_per_mc_level into dict of lists so that pos&#39;n/label indexing coincides</span>

    <span class="n">molecule</span><span class="p">:</span> <span class="n">Any</span> <span class="o">=</span> <span class="n">Field</span><span class="p">(</span><span class="o">...</span><span class="p">,</span> <span class="n">description</span><span class="o">=</span><span class="s2">&quot;The target molecule, if not the last molecule defined.&quot;</span><span class="p">)</span>
    <span class="n">basis</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;(auto)&quot;</span>
    <span class="n">method</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;(auto)&quot;</span>
    <span class="n">driver</span><span class="p">:</span> <span class="n">DriverEnum</span> <span class="o">=</span> <span class="n">Field</span><span class="p">(</span><span class="o">...</span><span class="p">,</span> <span class="n">description</span><span class="o">=</span><span class="s2">&quot;The computation driver; i.e., energy, gradient, hessian.&quot;</span><span class="p">)</span>
    <span class="n">keywords</span><span class="p">:</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Any</span><span class="p">]</span> <span class="o">=</span> <span class="n">Field</span><span class="p">({},</span> <span class="n">description</span><span class="o">=</span><span class="s2">&quot;The computation keywords/options.&quot;</span><span class="p">)</span>

    <span class="n">bsse_type</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">BsseEnum</span><span class="p">]</span> <span class="o">=</span> <span class="n">Field</span><span class="p">([</span><span class="n">BsseEnum</span><span class="o">.</span><span class="n">cp</span><span class="p">],</span> <span class="n">description</span><span class="o">=</span><span class="s2">&quot;Requested BSSE treatments. First in list determines which interaction or total energy/gradient/Hessian returned.&quot;</span><span class="p">)</span>
    <span class="n">nfragments</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="n">Field</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">description</span><span class="o">=</span><span class="s2">&quot;Number of distinct fragments comprising full molecular supersystem.&quot;</span><span class="p">)</span>  <span class="c1"># formerly max_frag</span>
    <span class="n">max_nbody</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="n">Field</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">description</span><span class="o">=</span><span class="s2">&quot;Maximum number of bodies to include in the many-body treatment. Possible: max_nbody &lt;= nfragments. Default: max_nbody = nfragments.&quot;</span><span class="p">)</span>

    <span class="n">nbodies_per_mc_level</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="n">Literal</span><span class="p">[</span><span class="s2">&quot;supersystem&quot;</span><span class="p">]]]]</span> <span class="o">=</span> <span class="n">Field</span><span class="p">([],</span> <span class="n">description</span><span class="o">=</span><span class="s2">&quot;Distribution of active n-body levels among model chemistry levels. All bodies in range [1, self.max_nbody] must be present exactly once. Number of items in outer list is how many different modelchems. Each inner list specifies what n-bodies to be run at the corresponding modelchem (e.g., `[[1, 2]]` has max_nbody=2 and 1-body and 2-body contributions computed at the same level of theory; `[[1], [2]]` has max_nbody=2 and 1-body and 2-body contributions computed at different levels of theory. An entry &#39;supersystem&#39; means all higher order n-body effects up to the number of fragments. The n-body levels are effectively sorted in the outer list, and any &#39;supersystem&#39; element is at the end.&quot;</span><span class="p">)</span>  <span class="c1"># formerly nbody_list</span>

    <span class="n">embedding_charges</span><span class="p">:</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="n">List</span><span class="p">[</span><span class="nb">float</span><span class="p">]]</span> <span class="o">=</span> <span class="n">Field</span><span class="p">({},</span> <span class="n">description</span><span class="o">=</span><span class="s2">&quot;Atom-centered point charges to be used on molecule fragments whose basis sets are not included in the computation. Keys: 1-based index of fragment. Values: list of atom charges for that fragment.&quot;</span><span class="p">)</span>

    <span class="n">return_total_data</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">bool</span><span class="p">]</span> <span class="o">=</span> <span class="n">Field</span><span class="p">(</span><span class="kc">None</span><span class="p">,</span> <span class="n">description</span><span class="o">=</span><span class="s2">&quot;When True, returns the total data (energy/gradient/Hessian) of the system, otherwise returns interaction data. Default is False for energies, True for gradients and Hessians. Note that the calculation of total counterpoise corrected energies implies the calculation of the energies of monomers in the monomer basis, hence specifying ``return_total_data = True`` may carry out more computations than ``return_total_data = False``.&quot;</span><span class="p">)</span>
    <span class="n">quiet</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="n">Field</span><span class="p">(</span><span class="kc">False</span><span class="p">,</span> <span class="n">description</span><span class="o">=</span><span class="s2">&quot;Whether to print/log formatted n-body energy analysis. Presently used by multi to suppress output. Candidate for removal from class once in-class/out-of-class functions sorted.&quot;</span><span class="p">)</span>

    <span class="n">task_list</span><span class="p">:</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">SubTaskComputers</span><span class="p">]</span> <span class="o">=</span> <span class="p">{}</span>

    <span class="c1"># Note that validation of user fields happens through typing and validator functions, so no class __init__ needed.</span>

<div class="viewcode-block" id="ManyBodyComputer.set_bsse_type"><a class="viewcode-back" href="../../../nbody.html#psi4.driver.driver_nbody.ManyBodyComputer.set_bsse_type">[docs]</a>    <span class="nd">@validator</span><span class="p">(</span><span class="s2">&quot;bsse_type&quot;</span><span class="p">,</span> <span class="n">pre</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">set_bsse_type</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">v</span><span class="p">):</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="nb">list</span><span class="p">):</span>
            <span class="n">v</span> <span class="o">=</span> <span class="p">[</span><span class="n">v</span><span class="p">]</span>
        <span class="c1"># emulate ordered set</span>
        <span class="k">return</span> <span class="nb">list</span><span class="p">(</span><span class="nb">dict</span><span class="o">.</span><span class="n">fromkeys</span><span class="p">([</span><span class="n">bt</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span> <span class="k">for</span> <span class="n">bt</span> <span class="ow">in</span> <span class="n">v</span><span class="p">]))</span></div>

<div class="viewcode-block" id="ManyBodyComputer.set_molecule"><a class="viewcode-back" href="../../../nbody.html#psi4.driver.driver_nbody.ManyBodyComputer.set_molecule">[docs]</a>    <span class="nd">@validator</span><span class="p">(</span><span class="s1">&#39;molecule&#39;</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">set_molecule</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">mol</span><span class="p">):</span>
        <span class="n">mol</span><span class="o">.</span><span class="n">update_geometry</span><span class="p">()</span>
        <span class="n">mol</span><span class="o">.</span><span class="n">fix_com</span><span class="p">(</span><span class="kc">True</span><span class="p">)</span>
        <span class="n">mol</span><span class="o">.</span><span class="n">fix_orientation</span><span class="p">(</span><span class="kc">True</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">mol</span></div>

<div class="viewcode-block" id="ManyBodyComputer.set_nfragments"><a class="viewcode-back" href="../../../nbody.html#psi4.driver.driver_nbody.ManyBodyComputer.set_nfragments">[docs]</a>    <span class="nd">@validator</span><span class="p">(</span><span class="s2">&quot;nfragments&quot;</span><span class="p">,</span> <span class="n">always</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">set_nfragments</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">v</span><span class="p">,</span> <span class="n">values</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">values</span><span class="p">[</span><span class="s2">&quot;molecule&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">nfragments</span><span class="p">()</span></div>

<div class="viewcode-block" id="ManyBodyComputer.set_max_nbody"><a class="viewcode-back" href="../../../nbody.html#psi4.driver.driver_nbody.ManyBodyComputer.set_max_nbody">[docs]</a>    <span class="nd">@validator</span><span class="p">(</span><span class="s2">&quot;max_nbody&quot;</span><span class="p">,</span> <span class="n">always</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">set_max_nbody</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">v</span><span class="p">,</span> <span class="n">values</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">v</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">values</span><span class="p">[</span><span class="s2">&quot;nfragments&quot;</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="nb">min</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">values</span><span class="p">[</span><span class="s2">&quot;nfragments&quot;</span><span class="p">])</span></div>

<div class="viewcode-block" id="ManyBodyComputer.set_embedding_charges"><a class="viewcode-back" href="../../../nbody.html#psi4.driver.driver_nbody.ManyBodyComputer.set_embedding_charges">[docs]</a>    <span class="nd">@validator</span><span class="p">(</span><span class="s2">&quot;embedding_charges&quot;</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">set_embedding_charges</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">v</span><span class="p">,</span> <span class="n">values</span><span class="p">):</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">v</span><span class="p">)</span> <span class="o">!=</span> <span class="n">values</span><span class="p">[</span><span class="s2">&quot;nfragments&quot;</span><span class="p">]:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;embedding_charges dict should have entries for each 1-indexed fragment.&quot;</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">v</span></div>

<div class="viewcode-block" id="ManyBodyComputer.set_return_total_data"><a class="viewcode-back" href="../../../nbody.html#psi4.driver.driver_nbody.ManyBodyComputer.set_return_total_data">[docs]</a>    <span class="nd">@validator</span><span class="p">(</span><span class="s2">&quot;return_total_data&quot;</span><span class="p">,</span> <span class="n">always</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">set_return_total_data</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">v</span><span class="p">,</span> <span class="n">values</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">v</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">rtd</span> <span class="o">=</span> <span class="n">v</span>
        <span class="k">elif</span> <span class="n">values</span><span class="p">[</span><span class="s2">&quot;driver&quot;</span><span class="p">]</span> <span class="ow">in</span> <span class="p">[</span><span class="s2">&quot;gradient&quot;</span><span class="p">,</span> <span class="s2">&quot;hessian&quot;</span><span class="p">]:</span>
            <span class="n">rtd</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">rtd</span> <span class="o">=</span> <span class="kc">False</span>

        <span class="k">if</span> <span class="n">values</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;embedding_charges&quot;</span><span class="p">,</span> <span class="kc">False</span><span class="p">)</span> <span class="ow">and</span> <span class="n">rtd</span> <span class="ow">is</span> <span class="kc">False</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Cannot return interaction data when using embedding scheme.&quot;</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">rtd</span></div>

<div class="viewcode-block" id="ManyBodyComputer.build_tasks"><a class="viewcode-back" href="../../../nbody.html#psi4.driver.driver_nbody.ManyBodyComputer.build_tasks">[docs]</a>    <span class="k">def</span> <span class="nf">build_tasks</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">mb_computer</span><span class="p">:</span> <span class="n">SubTaskComputers</span><span class="p">,</span>
        <span class="n">mc_level_idx</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span>
        <span class="o">**</span><span class="n">kwargs</span><span class="p">:</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Any</span><span class="p">],</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Adds to the task_list as many new unique tasks as necessary to treat a single model chemistry level at one or several n-body levels.</span>
<span class="sd">        New tasks are of type *mb_computer* with model chemistry level specified in *kwargs* and n-body levels accessed through *mc_level_idx*.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        mb_computer</span>
<span class="sd">            Class of task computers to instantiate and add to self.task_list. Usually :class:`~psi4.driver.AtomicComputer` but may be other when wrappers are layered.</span>
<span class="sd">        mc_level_idx</span>
<span class="sd">            Position in field self.nbodies_per_mc_level used to obtain ``nbodies``, the list of n-body</span>
<span class="sd">            levels (e.g., `[1]` or `[1, 2]` or `[&quot;supersystem&quot;]`) to which the modelchem specified in **kwargs** applies.</span>
<span class="sd">            That is, `nbodies = self.nbodies_per_mc_level[mc_level_idx]`.</span>
<span class="sd">            Note the natural 1-indexing of ``nbodies`` _contents_, so `[1]` covers one-body contributions.</span>
<span class="sd">            The corresponding user label is the 1-indexed counterpart, `mc_level_lbl = mc_level_idx + 1`</span>
<span class="sd">            Formerly nlevel as in `nbody = self.nbody_list[nbody_level=nlevel]`.</span>
<span class="sd">        kwargs</span>
<span class="sd">            Other arguments for initializing **mb_computer**. In particular, specifies model chemistry.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        count : int</span>
<span class="sd">            Number of new tasks planned by this call.</span>
<span class="sd">            Formerly, didn&#39;t include supersystem in count.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Get the n-body orders for this level</span>
        <span class="n">nbodies</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">nbodies_per_mc_level</span><span class="p">[</span><span class="n">mc_level_idx</span><span class="p">]</span>

        <span class="n">info</span> <span class="o">=</span> <span class="s2">&quot;</span><span class="se">\n</span><span class="s2">&quot;</span> <span class="o">+</span> <span class="n">p4util</span><span class="o">.</span><span class="n">banner</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot; ManyBody Setup: N-Body Levels </span><span class="si">{</span><span class="n">nbodies</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">,</span> <span class="n">strNotOutfile</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span> <span class="o">+</span> <span class="s2">&quot;</span><span class="se">\n</span><span class="s2">&quot;</span>
        <span class="n">core</span><span class="o">.</span><span class="n">print_out</span><span class="p">(</span><span class="n">info</span><span class="p">)</span>
        <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="n">info</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">kwg</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;dft_functional&#39;</span><span class="p">]:</span>
            <span class="k">if</span> <span class="n">kwg</span> <span class="ow">in</span> <span class="n">kwargs</span><span class="p">:</span>
                <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;keywords&#39;</span><span class="p">][</span><span class="s1">&#39;function_kwargs&#39;</span><span class="p">][</span><span class="n">kwg</span><span class="p">]</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="n">kwg</span><span class="p">)</span>

        <span class="n">count</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">template</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="n">kwargs</span><span class="p">)</span>

        <span class="c1"># Get compute list</span>
        <span class="k">if</span> <span class="n">nbodies</span> <span class="o">==</span> <span class="p">[</span><span class="s2">&quot;supersystem&quot;</span><span class="p">]:</span>
            <span class="c1"># Add supersystem computation if requested -- always nocp</span>
            <span class="n">data</span> <span class="o">=</span> <span class="n">template</span>
            <span class="n">data</span><span class="p">[</span><span class="s2">&quot;molecule&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">molecule</span>
            <span class="n">key</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;supersystem_</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">nfragments</span><span class="si">}</span><span class="s2">&quot;</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">task_list</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="n">mb_computer</span><span class="p">(</span><span class="o">**</span><span class="n">data</span><span class="p">)</span>
            <span class="n">count</span> <span class="o">+=</span> <span class="mi">1</span>

            <span class="n">compute_dict</span> <span class="o">=</span> <span class="n">build_nbody_compute_list</span><span class="p">(</span>
                <span class="p">[</span><span class="s2">&quot;nocp&quot;</span><span class="p">],</span> <span class="nb">list</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">max_nbody</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)),</span> <span class="bp">self</span><span class="o">.</span><span class="n">nfragments</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">return_total_data</span>
            <span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">compute_dict</span> <span class="o">=</span> <span class="n">build_nbody_compute_list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">bsse_type</span><span class="p">,</span> <span class="n">nbodies</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">nfragments</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">return_total_data</span><span class="p">)</span>

        <span class="k">def</span> <span class="nf">labeler</span><span class="p">(</span><span class="n">item</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
            <span class="n">mc_level_lbl</span> <span class="o">=</span> <span class="n">mc_level_idx</span> <span class="o">+</span> <span class="mi">1</span>
            <span class="k">return</span> <span class="nb">str</span><span class="p">(</span><span class="n">mc_level_lbl</span><span class="p">)</span> <span class="o">+</span> <span class="s2">&quot;_&quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">item</span><span class="p">)</span>

        <span class="c1"># Add current compute list to the master task list</span>
        <span class="c1"># * `pair` looks like `((1,), (1, 3))` where first is real (not ghost) fragment indices</span>
        <span class="c1">#    and second is basis set fragment indices, all 1-indexed</span>
        <span class="k">for</span> <span class="n">nb</span> <span class="ow">in</span> <span class="n">compute_dict</span><span class="p">[</span><span class="s2">&quot;all&quot;</span><span class="p">]:</span>
            <span class="k">for</span> <span class="n">pair</span> <span class="ow">in</span> <span class="n">compute_dict</span><span class="p">[</span><span class="s2">&quot;all&quot;</span><span class="p">][</span><span class="n">nb</span><span class="p">]:</span>
                <span class="n">lbl</span> <span class="o">=</span> <span class="n">labeler</span><span class="p">(</span><span class="n">pair</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">lbl</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">task_list</span><span class="p">:</span>
                    <span class="k">continue</span>

                <span class="n">data</span> <span class="o">=</span> <span class="n">template</span>
                <span class="n">ghost</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="n">pair</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span> <span class="o">-</span> <span class="nb">set</span><span class="p">(</span><span class="n">pair</span><span class="p">[</span><span class="mi">0</span><span class="p">]))</span>
                <span class="n">data</span><span class="p">[</span><span class="s2">&quot;molecule&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">molecule</span><span class="o">.</span><span class="n">extract_subsets</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">pair</span><span class="p">[</span><span class="mi">0</span><span class="p">]),</span> <span class="n">ghost</span><span class="p">)</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">embedding_charges</span><span class="p">:</span>
                    <span class="n">embedding_frags</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">nfragments</span> <span class="o">+</span> <span class="mi">1</span><span class="p">))</span> <span class="o">-</span> <span class="nb">set</span><span class="p">(</span><span class="n">pair</span><span class="p">[</span><span class="mi">1</span><span class="p">]))</span>
                    <span class="n">charges</span> <span class="o">=</span> <span class="p">[]</span>
                    <span class="k">for</span> <span class="n">frag</span> <span class="ow">in</span> <span class="n">embedding_frags</span><span class="p">:</span>
                        <span class="n">positions</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">molecule</span><span class="o">.</span><span class="n">extract_subsets</span><span class="p">(</span><span class="n">frag</span><span class="p">)</span><span class="o">.</span><span class="n">geometry</span><span class="p">()</span><span class="o">.</span><span class="n">np</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span>
                        <span class="n">charges</span><span class="o">.</span><span class="n">extend</span><span class="p">([[</span><span class="n">chg</span><span class="p">,</span> <span class="n">i</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">chg</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">positions</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">embedding_charges</span><span class="p">[</span><span class="n">frag</span><span class="p">])])</span>
                    <span class="n">data</span><span class="p">[</span><span class="s1">&#39;keywords&#39;</span><span class="p">][</span><span class="s1">&#39;function_kwargs&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">update</span><span class="p">({</span><span class="s1">&#39;external_potentials&#39;</span><span class="p">:</span> <span class="n">charges</span><span class="p">})</span>

                <span class="bp">self</span><span class="o">.</span><span class="n">task_list</span><span class="p">[</span><span class="n">lbl</span><span class="p">]</span> <span class="o">=</span> <span class="n">mb_computer</span><span class="p">(</span><span class="o">**</span><span class="n">data</span><span class="p">)</span>
                <span class="n">count</span> <span class="o">+=</span> <span class="mi">1</span>

        <span class="k">return</span> <span class="n">count</span></div>

<div class="viewcode-block" id="ManyBodyComputer.plan"><a class="viewcode-back" href="../../../nbody.html#psi4.driver.driver_nbody.ManyBodyComputer.plan">[docs]</a>    <span class="k">def</span> <span class="nf">plan</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="c1"># uncalled function</span>
        <span class="k">return</span> <span class="p">[</span><span class="n">t</span><span class="o">.</span><span class="n">plan</span><span class="p">()</span> <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">task_list</span><span class="o">.</span><span class="n">values</span><span class="p">()]</span></div>

<div class="viewcode-block" id="ManyBodyComputer.compute"><a class="viewcode-back" href="../../../nbody.html#psi4.driver.driver_nbody.ManyBodyComputer.compute">[docs]</a>    <span class="k">def</span> <span class="nf">compute</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">client</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="s2">&quot;qcportal.FractalClient&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Run quantum chemistry.&quot;&quot;&quot;</span>

        <span class="n">info</span> <span class="o">=</span> <span class="s2">&quot;</span><span class="se">\n</span><span class="s2">&quot;</span> <span class="o">+</span> <span class="n">p4util</span><span class="o">.</span><span class="n">banner</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot; ManyBody Computations &quot;</span><span class="p">,</span> <span class="n">strNotOutfile</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span> <span class="o">+</span> <span class="s2">&quot;</span><span class="se">\n</span><span class="s2">&quot;</span>
        <span class="c1">#core.print_out(info)</span>
        <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="n">info</span><span class="p">)</span>

        <span class="k">with</span> <span class="n">p4util</span><span class="o">.</span><span class="n">hold_options_state</span><span class="p">():</span>
            <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">task_list</span><span class="o">.</span><span class="n">values</span><span class="p">():</span>
                <span class="n">t</span><span class="o">.</span><span class="n">compute</span><span class="p">(</span><span class="n">client</span><span class="o">=</span><span class="n">client</span><span class="p">)</span></div>

<div class="viewcode-block" id="ManyBodyComputer.prepare_results"><a class="viewcode-back" href="../../../nbody.html#psi4.driver.driver_nbody.ManyBodyComputer.prepare_results">[docs]</a>    <span class="k">def</span> <span class="nf">prepare_results</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">results</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">SubTaskComputers</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">client</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="s2">&quot;qcportal.FractalClient&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Any</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Process the results from all n-body component molecular systems and model chemistry levels into final quantities.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        results</span>
<span class="sd">            A set of tasks to process instead of self.task_list. Used in multilevel processing to pass a subset of</span>
<span class="sd">            self.task_list filtered to only one modelchem level.</span>
<span class="sd">        client</span>
<span class="sd">            QCFractal client if using QCArchive for distributed compute.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        nbody_results</span>
<span class="sd">            When the ManyBodyComputer specifies a single model chemistry level (see self.nbodies_per_mc_level), the</span>
<span class="sd">            return is a dictionary, nbody_results, described in the table below. Many of the items are actually filled</span>
<span class="sd">            by successive calls to assemble_nbody_components(). When multiple model chemistry levels are specified, this</span>
<span class="sd">            function diverts its return to driver_nbody_multilevel.prepare_results() wherein each mc level calls this</span>
<span class="sd">            function again and collects separate nbody_results dictionaries and processes them into a final return that</span>
<span class="sd">            is a small subset of the table below.</span>


<span class="sd">                                       ptype_size = (1,)/(nat, 3)/(3 * nat, 3 * nat)</span>
<span class="sd">                                        e/g/h := energy or gradient or Hessian</span>
<span class="sd">                                        rtd := return_total_data</span>

<span class="sd">        .. |em| unicode:: U+02003 .. em space</span>

<span class="sd">        .. _`table:nbody_return`:</span>

<span class="sd">        +---------------------------------------------------------------+----------------------+--------------------------------------------------------------------+--------------------------------------------------------------------------------------------------------------------+</span>
<span class="sd">        | item                                                          | size                 | present / zeroed                                                   | contents / interpretation                                                                                          |</span>
<span class="sd">        +===============================================================+======================+====================================================================+====================================================================================================================+</span>
<span class="sd">        | ret_ptype                                                     | ptype_size           | always                                                             | interaction data requested: IE or total (depending on return_total_data) e/g/h (depending on driver)               |</span>
<span class="sd">        |                                                               |                      |                                                                    |   with cp/nocp/vmfc treatment (depending on 1st of bsse_type)                                                      |</span>
<span class="sd">        +---------------------------------------------------------------+----------------------+--------------------------------------------------------------------+--------------------------------------------------------------------------------------------------------------------+</span>
<span class="sd">        | ret_energy                                                    | 1                    | always                                                             | interaction energy: IE or total (depending on return_total_data) w/ cp/nocp/vmfc treat. (dep. on 1st of bsse_type) |</span>
<span class="sd">        +---------------------------------------------------------------+----------------------+--------------------------------------------------------------------+--------------------------------------------------------------------------------------------------------------------+</span>
<span class="sd">        | ret_gradient                                                  | (nat, 3)             | when driver is g/h                                                 | interaction gradient: IE or total (depending on return_total_data) w/ cp/nocp/vmfc treat. (dep. on 1st of bsse_type|</span>
<span class="sd">        +---------------------------------------------------------------+----------------------+--------------------------------------------------------------------+--------------------------------------------------------------------------------------------------------------------+</span>
<span class="sd">        | ret_hessian                                                   | (nat * 3, nat * 3)   | when driver is h                                                   | interaction Hessian: IE or total (depending on return_total_data) w/ cp/nocp/vmfc treat. (dep. on 1st of bsse_type)|</span>
<span class="sd">        +---------------------------------------------------------------+----------------------+--------------------------------------------------------------------+--------------------------------------------------------------------------------------------------------------------+</span>
<span class="sd">        |                                                               |                      |                                                                    |                                                                                                                    |</span>
<span class="sd">        +---------------------------------------------------------------+----------------------+--------------------------------------------------------------------+--------------------------------------------------------------------------------------------------------------------+</span>
<span class="sd">        | nbody                                                         | &gt;=1                  | always                                                             | energy n-body QCVariables to be set                                                                                |</span>
<span class="sd">        +---------------------------------------------------------------+----------------------+--------------------------------------------------------------------+--------------------------------------------------------------------------------------------------------------------+</span>
<span class="sd">        |   |em| CP-CORRECTED TOTAL ENERGY THROUGH 1-BODY               |  |em| 1              | when cp in bsse_type                                               | MBE sum of subsystems of 1-body. summed are total energies with cp treatment                                       |</span>
<span class="sd">        +---------------------------------------------------------------+----------------------+--------------------------------------------------------------------+--------------------------------------------------------------------------------------------------------------------+</span>
<span class="sd">        |   |em| CP-CORRECTED TOTAL ENERGY THROUGH 2-BODY               |  |em| 1              | when cp in bsse_type &amp; max_nbody&gt;=2                                | MBE sum of subsystems of 2-body or fewer (cumulative); summed are total energies with cp treatment                 |</span>
<span class="sd">        +---------------------------------------------------------------+----------------------+--------------------------------------------------------------------+--------------------------------------------------------------------------------------------------------------------+</span>
<span class="sd">        |   |em| CP-CORRECTED TOTAL ENERGY THROUGH {nb}-BODY            |  |em| 1              | when cp in bsse_type                                               | MBE sum of subsystems of {max_nbody}-body or fewer (cumulative); summed are total energies w/ cp treatment         |</span>
<span class="sd">        +---------------------------------------------------------------+----------------------+--------------------------------------------------------------------+--------------------------------------------------------------------------------------------------------------------+</span>
<span class="sd">        |   |em| CP-CORRECTED TOTAL ENERGY                              |  |em| 1              | when cp in bsse_type &amp; rtd=T                                       | best available total energy with cp treatment: CP-CORRECTED TOTAL ENERGY THROUGH {max_nbody}-BODY                  |</span>
<span class="sd">        +---------------------------------------------------------------+----------------------+--------------------------------------------------------------------+--------------------------------------------------------------------------------------------------------------------+</span>
<span class="sd">        |   |em| CP-CORRECTED INTERACTION ENERGY THROUGH 2-BODY         |  |em| 1              | when cp in bsse_type &amp; max_nbody&gt;=2                                | 2-body total data less 1-body total data for cumulative IE; inputs are total energies with cp treatment            |</span>
<span class="sd">        +---------------------------------------------------------------+----------------------+--------------------------------------------------------------------+--------------------------------------------------------------------------------------------------------------------+</span>
<span class="sd">        |   |em| CP-CORRECTED INTERACTION ENERGY THROUGH {nb}-BODY      |  |em| 1              | when cp in bsse_type                                               | {max_nbody}-body total data less 1-body total data for cumulative IE; inputs are total energies with cp treatment  |</span>
<span class="sd">        +---------------------------------------------------------------+----------------------+--------------------------------------------------------------------+--------------------------------------------------------------------------------------------------------------------+</span>
<span class="sd">        |   |em| CP-CORRECTED INTERACTION ENERGY                        |  |em| 1              | when cp in bsse_type                                               | best available interaction energy with cp treatment: CP-CORRECTED INTERACTION ENERGY THROUGH {max_nbody}-BODY      |</span>
<span class="sd">        +---------------------------------------------------------------+----------------------+--------------------------------------------------------------------+--------------------------------------------------------------------------------------------------------------------+</span>
<span class="sd">        |   |em| CP-CORRECTED 2-BODY CONTRIBUTION TO ENERGY             |  |em| 1              | when cp in bsse_type &amp; max_nbody&gt;=2                                | 2-body total data less (2-1)-body total data for partial IE; inputs are total energies w/ cp treatment             |</span>
<span class="sd">        +---------------------------------------------------------------+----------------------+--------------------------------------------------------------------+--------------------------------------------------------------------------------------------------------------------+</span>
<span class="sd">        |   |em| CP-CORRECTED {nb}-BODY CONTRIBUTION TO ENERGY          |  |em| 1              | when cp in bsse_type                                               | {max_nbody}-body total data less ({max_nbody}-1)-body data for partial IE; inputs are total energies w/ cp treat.  |</span>
<span class="sd">        +---------------------------------------------------------------+----------------------+--------------------------------------------------------------------+--------------------------------------------------------------------------------------------------------------------+</span>
<span class="sd">        |                                                               |                      |                                                                    |                                                                                                                    |</span>
<span class="sd">        +---------------------------------------------------------------+----------------------+--------------------------------------------------------------------+--------------------------------------------------------------------------------------------------------------------+</span>
<span class="sd">        |   |em| NOCP-CORRECTED TOTAL ENERGY THROUGH 1-BODY             |  |em| 1              | when nocp in bsse_type                                             | MBE sum of subsystems of 1-body. summed are total energies without cp treatment                                    |</span>
<span class="sd">        +---------------------------------------------------------------+----------------------+--------------------------------------------------------------------+--------------------------------------------------------------------------------------------------------------------+</span>
<span class="sd">        |   |em| NOCP-CORRECTED TOTAL ENERGY THROUGH 2-BODY             |  |em| 1              | when nocp in bsse_type &amp; max_nbody&gt;=2                              | MBE sum of subsystems of 2-body or fewer (cumulative); summed are total energies without cp treatment              |</span>
<span class="sd">        +---------------------------------------------------------------+----------------------+--------------------------------------------------------------------+--------------------------------------------------------------------------------------------------------------------+</span>
<span class="sd">        |   |em| NOCP-CORRECTED TOTAL ENERGY THROUGH {nb}-BODY          |  |em| 1              | when nocp in bsse_type                                             | MBE sum of subsystems of {max_nbody}-body or fewer (cumulative); summed are total energies w/o cp treatment        |</span>
<span class="sd">        +---------------------------------------------------------------+----------------------+--------------------------------------------------------------------+--------------------------------------------------------------------------------------------------------------------+</span>
<span class="sd">        |   |em| NOCP-CORRECTED TOTAL ENERGY                            |  |em| 1              | when nocp in bsse_type                                             | best available total energy without cp treatment: NOCP-CORRECTED TOTAL ENERGY THROUGH {max_nbody}-BODY             |</span>
<span class="sd">        +---------------------------------------------------------------+----------------------+--------------------------------------------------------------------+--------------------------------------------------------------------------------------------------------------------+</span>
<span class="sd">        |   |em| NOCP-CORRECTED INTERACTION ENERGY THROUGH 2-BODY       |  |em| 1              | when nocp in bsse_type &amp; max_nbody&gt;=2                              | 2-body total data less 1-body total data for cumulative IE; inputs are total energies w/o cp treatment             |</span>
<span class="sd">        +---------------------------------------------------------------+----------------------+--------------------------------------------------------------------+--------------------------------------------------------------------------------------------------------------------+</span>
<span class="sd">        |   |em| NOCP-CORRECTED INTERACTION ENERGY THROUGH {nb}-BODY    |  |em| 1              | when nocp in bsse_type                                             | {max_nbody}-body total data less 1-body total data for cumulative IE; inputs are total energies w/o cp treatment   |</span>
<span class="sd">        +---------------------------------------------------------------+----------------------+--------------------------------------------------------------------+--------------------------------------------------------------------------------------------------------------------+</span>
<span class="sd">        |   |em| NOCP-CORRECTED INTERACTION ENERGY                      |  |em| 1              | when nocp in bsse_type                                             | best available interaction energy without cp treatment: NOCP-CORRECTED INTERACTION ENERGY THROUGH {max_nbody}-BODY |</span>
<span class="sd">        +---------------------------------------------------------------+----------------------+--------------------------------------------------------------------+--------------------------------------------------------------------------------------------------------------------+</span>
<span class="sd">        |   |em| NOCP-CORRECTED 2-BODY CONTRIBUTION TO ENERGY           |  |em| 1              | when nocp in bsse_type &amp; max_nbody&gt;=2                              | 2-body total data less (2-1)-body total data for partial IE; inputs are total energies w/o cp treatment            |</span>
<span class="sd">        +---------------------------------------------------------------+----------------------+--------------------------------------------------------------------+--------------------------------------------------------------------------------------------------------------------+</span>
<span class="sd">        |   |em| NOCP-CORRECTED {nb}-BODY CONTRIBUTION TO ENERGY        |  |em| 1              | when nocp in bsse_type                                             | {max_nbody}-body total data less ({max_nbody}-1)-body data for partial IE; inputs are total energies w/o cp treat. |</span>
<span class="sd">        +---------------------------------------------------------------+----------------------+--------------------------------------------------------------------+--------------------------------------------------------------------------------------------------------------------+</span>
<span class="sd">        |                                                               |                      |                                                                    |                                                                                                                    |</span>
<span class="sd">        +---------------------------------------------------------------+----------------------+--------------------------------------------------------------------+--------------------------------------------------------------------------------------------------------------------+</span>
<span class="sd">        |   |em| VMFC-CORRECTED TOTAL ENERGY THROUGH 1-BODY             |  |em| 1              | when vmfc in bsse_type                                             | MBE sum of subsystems of 1-body. summed are total energies with vmfc treatment                                     |</span>
<span class="sd">        +---------------------------------------------------------------+----------------------+--------------------------------------------------------------------+--------------------------------------------------------------------------------------------------------------------+</span>
<span class="sd">        |   |em| VMFC-CORRECTED TOTAL ENERGY THROUGH 2-BODY             |  |em| 1              | when vmfc in bsse_type &amp; max_nbody&gt;=2                              | MBE sum of subsystems of 2-body or fewer (cumulative); summed are total energies with vmfc treatment               |</span>
<span class="sd">        +---------------------------------------------------------------+----------------------+--------------------------------------------------------------------+--------------------------------------------------------------------------------------------------------------------+</span>
<span class="sd">        |   |em| VMFC-CORRECTED TOTAL ENERGY THROUGH {nb}-BODY          |  |em| 1              | when vmfc in bsse_type                                             | MBE sum of subsystems of {max_nbody}-body or fewer (cumulative); summed are total energies w/ vmfc treatment       |</span>
<span class="sd">        +---------------------------------------------------------------+----------------------+--------------------------------------------------------------------+--------------------------------------------------------------------------------------------------------------------+</span>
<span class="sd">        |   |em| VMFC-CORRECTED TOTAL ENERGY                            |  |em| 1              | when vmfc in bsse_type                                             | best available total energy with vmfc treatment: VMFC-CORRECTED TOTAL ENERGY THROUGH {max_nbody}-BODY              |</span>
<span class="sd">        +---------------------------------------------------------------+----------------------+--------------------------------------------------------------------+--------------------------------------------------------------------------------------------------------------------+</span>
<span class="sd">        |   |em| VMFC-CORRECTED INTERACTION ENERGY THROUGH 2-BODY       |  |em| 1              | when vmfc in bsse_type &amp; max_nbody&gt;=2                              | 2-body total data less 1-body total data for cumulative IE; inputs are total energies w/ vmfc treatment            |</span>
<span class="sd">        +---------------------------------------------------------------+----------------------+--------------------------------------------------------------------+--------------------------------------------------------------------------------------------------------------------+</span>
<span class="sd">        |   |em| VMFC-CORRECTED INTERACTION ENERGY THROUGH {nb}-BODY    |  |em| 1              | when vmfc in bsse_type                                             | {max_nbody}-body total data less 1-body total data for cumulative IE; inputs are total energies w/ vmfc treatment  |</span>
<span class="sd">        +---------------------------------------------------------------+----------------------+--------------------------------------------------------------------+--------------------------------------------------------------------------------------------------------------------+</span>
<span class="sd">        |   |em| VMFC-CORRECTED INTERACTION ENERGY                      |  |em| 1              | when vmfc in bsse_type                                             | best available interaction energy with vmfc treatment: VMFC-CORRECTED INTERACTION ENERGY THROUGH {max_nbody}-BODY  |</span>
<span class="sd">        +---------------------------------------------------------------+----------------------+--------------------------------------------------------------------+--------------------------------------------------------------------------------------------------------------------+</span>
<span class="sd">        |   |em| VMFC-CORRECTED 2-BODY CONTRIBUTION TO ENERGY           |  |em| 1              | when vmfc in bsse_type &amp; max_nbody&gt;=2                              | 2-body total data less (2-1)-body total data for partial IE; inputs are total energies w/ vmfc treatment           |</span>
<span class="sd">        +---------------------------------------------------------------+----------------------+--------------------------------------------------------------------+--------------------------------------------------------------------------------------------------------------------+</span>
<span class="sd">        |   |em| VMFC-CORRECTED {nb}-BODY CONTRIBUTION TO ENERGY        |  |em| 1              | when vmfc in bsse_type                                             | {max_nbody}-body total data less ({max_nbody}-1)-body data for partial IE; inputs are total energies w/ vmfc treat.|</span>
<span class="sd">        +---------------------------------------------------------------+----------------------+--------------------------------------------------------------------+--------------------------------------------------------------------------------------------------------------------+</span>
<span class="sd">        |                                                               |                      |                                                                    |                                                                                                                    |</span>
<span class="sd">        +---------------------------------------------------------------+----------------------+--------------------------------------------------------------------+--------------------------------------------------------------------------------------------------------------------+</span>
<span class="sd">        | energy_body_dict                                              | max_nbody            | always                                                             | total energies at each n-body level                                                                                |</span>
<span class="sd">        +---------------------------------------------------------------+----------------------+--------------------------------------------------------------------+--------------------------------------------------------------------------------------------------------------------+</span>
<span class="sd">        |  |em| 1                                                       |  |em| 1              | always; zeroed if cp &amp; rtd=F                                       | cumulative through 1-body total energies w/ cp/nocp/vmfc treatment (dep. on 1st of bsse_type)                      |</span>
<span class="sd">        +---------------------------------------------------------------+----------------------+--------------------------------------------------------------------+--------------------------------------------------------------------------------------------------------------------+</span>
<span class="sd">        |  |em| 2                                                       |  |em| 1              | max_nbody&gt;=2                                                       | cumulative through 2-body total energies w/ cp/nocp/vmfc treatment (dep. on 1st of bsse_type)                      |</span>
<span class="sd">        +---------------------------------------------------------------+----------------------+--------------------------------------------------------------------+--------------------------------------------------------------------------------------------------------------------+</span>
<span class="sd">        |  |em| {max_nbody}                                             |  |em| 1              | always                                                             | cumulative through {max_nbody}-body total energies w/ cp/nocp/vmfc treatment (dep. on 1st of bsse_type)            |</span>
<span class="sd">        +---------------------------------------------------------------+----------------------+--------------------------------------------------------------------+--------------------------------------------------------------------------------------------------------------------+</span>
<span class="sd">        | gradient_body_dict                                            | max_nbody            | when driver is g/h                                                 |                                                                                                                    |</span>
<span class="sd">        +---------------------------------------------------------------+----------------------+--------------------------------------------------------------------+--------------------------------------------------------------------------------------------------------------------+</span>
<span class="sd">        |  |em| 1                                                       |  |em| (nat, 3)       | when driver is g/h                                                 | cumulative through 1-body total gradients with cp/nocp/vmfc treatment (dep. on 1st of bsse_type)                   |</span>
<span class="sd">        +---------------------------------------------------------------+----------------------+--------------------------------------------------------------------+--------------------------------------------------------------------------------------------------------------------+</span>
<span class="sd">        |  |em| 2                                                       |  |em| (nat, 3)       | when driver is g/h &amp; max_nbody&gt;=2                                  | cumulative through 2-body total gradients with cp/nocp/vmfc treatment (dep. on 1st of bsse_type)                   |</span>
<span class="sd">        +---------------------------------------------------------------+----------------------+--------------------------------------------------------------------+--------------------------------------------------------------------------------------------------------------------+</span>
<span class="sd">        |  |em| {max_nbody}                                             |  |em| (nat, 3)       | when driver is g/h                                                 | cumulative through {max_nbody}-body total gradients w/ cp/nocp/vmfc treatment (dep. on 1st of bsse_type)           |</span>
<span class="sd">        +---------------------------------------------------------------+----------------------+--------------------------------------------------------------------+--------------------------------------------------------------------------------------------------------------------+</span>
<span class="sd">        | hessian_body_dict                                             | max_nbody            | when driver is h                                                   |                                                                                                                    |</span>
<span class="sd">        +---------------------------------------------------------------+----------------------+--------------------------------------------------------------------+--------------------------------------------------------------------------------------------------------------------+</span>
<span class="sd">        |  |em| 1                                                       |  |em| (nat*3, nat*3) | when driver is h                                                   | cumulative through 1-body total Hessians w/ cp/nocp/vmfc treatment (dep. on 1st of bsse_type)                      |</span>
<span class="sd">        +---------------------------------------------------------------+----------------------+--------------------------------------------------------------------+--------------------------------------------------------------------------------------------------------------------+</span>
<span class="sd">        |  |em| 2                                                       |  |em| (nat*3, nat*3) | when driver is h &amp; max_nbody&gt;=2                                    | cumulative through 2-body total Hessians w/ cp/nocp/vmfc treatment (dep. on 1st of bsse_type)                      |</span>
<span class="sd">        +---------------------------------------------------------------+----------------------+--------------------------------------------------------------------+--------------------------------------------------------------------------------------------------------------------+</span>
<span class="sd">        |  |em| {max_nbody}                                             |  |em| (nat*3, nat*3) | when driver is h                                                   | cumulative through {max_nbody}-body total Hessians w/ cp/nocp/vmfc treatment (dep. on 1st of bsse_type)            |</span>
<span class="sd">        +---------------------------------------------------------------+----------------------+--------------------------------------------------------------------+--------------------------------------------------------------------------------------------------------------------+</span>
<span class="sd">        |                                                               |                      |                                                                    |                                                                                                                    |</span>
<span class="sd">        +---------------------------------------------------------------+----------------------+--------------------------------------------------------------------+--------------------------------------------------------------------------------------------------------------------+</span>
<span class="sd">        | cp_energy_body_dict                                           | max_nbody            | always; zeroed if cp not in bsse_type                              | total energies at each n-body level with cp treatment                                                              |</span>
<span class="sd">        +---------------------------------------------------------------+----------------------+--------------------------------------------------------------------+--------------------------------------------------------------------------------------------------------------------+</span>
<span class="sd">        |   |em| 1cp                                                    |  |em| 1              | always; zeroed if cp not in bsse_type or rtd=F                     | cumulative through 1-body total energies with cp treatment                                                         |</span>
<span class="sd">        +---------------------------------------------------------------+----------------------+--------------------------------------------------------------------+--------------------------------------------------------------------------------------------------------------------+</span>
<span class="sd">        |   |em| 2cp                                                    |  |em| 1              | when max_nbody&gt;=2; zeroed if cp not in bsse_type                   | cumulative through 2-body total energies with cp treatment                                                         |</span>
<span class="sd">        +---------------------------------------------------------------+----------------------+--------------------------------------------------------------------+--------------------------------------------------------------------------------------------------------------------+</span>
<span class="sd">        |   |em| {max_nbody}cp                                          |  |em| 1              | always; zeroed if cp not in bsse_type                              | cumulative through {max_nbody}-body total energies with cp treatment                                               |</span>
<span class="sd">        +---------------------------------------------------------------+----------------------+--------------------------------------------------------------------+--------------------------------------------------------------------------------------------------------------------+</span>
<span class="sd">        | cp_gradient_body_dict                                         | max_nbody            | when driver is g/h; zeroed if cp not in bsse_type                  | total gradients at each n-body level with cp treatment                                                             |</span>
<span class="sd">        +---------------------------------------------------------------+----------------------+--------------------------------------------------------------------+--------------------------------------------------------------------------------------------------------------------+</span>
<span class="sd">        |   |em| 1cp                                                    |  |em| (nat, 3)       | when driver is g/h; zeroed if cp not in bsse_type or rtd=F         | cumulative through 1-body total gradients with cp treatment                                                        |</span>
<span class="sd">        +---------------------------------------------------------------+----------------------+--------------------------------------------------------------------+--------------------------------------------------------------------------------------------------------------------+</span>
<span class="sd">        |   |em| 2cp                                                    |  |em| (nat, 3)       | when driver is g/h &amp; max_nbody&gt;=2; zeroed if cp not in bsse_type   | cumulative through 2-body total gradients with cp treatment                                                        |</span>
<span class="sd">        +---------------------------------------------------------------+----------------------+--------------------------------------------------------------------+--------------------------------------------------------------------------------------------------------------------+</span>
<span class="sd">        |   |em| {max_nbody}cp                                          |  |em| (nat, 3)       | when driver is g/h; zeroed if cp not in bsse_type                  | cumulative through {max_nbody}-body total gradients with cp treatment                                              |</span>
<span class="sd">        +---------------------------------------------------------------+----------------------+--------------------------------------------------------------------+--------------------------------------------------------------------------------------------------------------------+</span>
<span class="sd">        | cp_hessian_body_dict                                          | max_nbody            | when driver is h; zeroed if cp not in bsse_type                    | total Hessians at each n-body level with cp treatment                                                              |</span>
<span class="sd">        +---------------------------------------------------------------+----------------------+--------------------------------------------------------------------+--------------------------------------------------------------------------------------------------------------------+</span>
<span class="sd">        |   |em| 1cp                                                    |  |em| (nat*3, nat*3) | when driver is h; zeroed if cp not in bsse_type or rtd=F           | cumulative through 1-body total Hessians with cp treatment                                                         |</span>
<span class="sd">        +---------------------------------------------------------------+----------------------+--------------------------------------------------------------------+--------------------------------------------------------------------------------------------------------------------+</span>
<span class="sd">        |   |em| 2cp                                                    |  |em| (nat*3, nat*3) | when driver is h &amp; max_nbody&gt;=2; zeroed if cp not in bsse_type     | cumulative through 2-body total Hessians with cp treatment                                                         |</span>
<span class="sd">        +---------------------------------------------------------------+----------------------+--------------------------------------------------------------------+--------------------------------------------------------------------------------------------------------------------+</span>
<span class="sd">        |   |em| {max_nbody}cp                                          |  |em| (nat*3, nat*3) | when driver is h; zeroed if cp not in bsse_type                    | cumulative through {max_nbody}-body total Hessians with cp treatment                                               |</span>
<span class="sd">        +---------------------------------------------------------------+----------------------+--------------------------------------------------------------------+--------------------------------------------------------------------------------------------------------------------+</span>
<span class="sd">        |                                                               |                      |                                                                    |                                                                                                                    |</span>
<span class="sd">        +---------------------------------------------------------------+----------------------+--------------------------------------------------------------------+--------------------------------------------------------------------------------------------------------------------+</span>
<span class="sd">        | nocp_energy_body_dict                                         | max_nbody            | always; zeroed if nocp not in bsse_type                            | total energies at each n-body level with nocp treatment                                                            |</span>
<span class="sd">        +---------------------------------------------------------------+----------------------+--------------------------------------------------------------------+--------------------------------------------------------------------------------------------------------------------+</span>
<span class="sd">        |   |em| 1nocp                                                  |  |em| 1              | always; zeroed if nocp not in bsse_type                            | cumulative through 1-body total energies with nocp treatment                                                       |</span>
<span class="sd">        +---------------------------------------------------------------+----------------------+--------------------------------------------------------------------+--------------------------------------------------------------------------------------------------------------------+</span>
<span class="sd">        |   |em| 2nocp                                                  |  |em| 1              | when max_nbody&gt;=2; zeroed if nocp not in bsse_type                 | cumulative through 2-body total energies with nocp treatment                                                       |</span>
<span class="sd">        +---------------------------------------------------------------+----------------------+--------------------------------------------------------------------+--------------------------------------------------------------------------------------------------------------------+</span>
<span class="sd">        |   |em| {max_nbody}nocp                                        |  |em| 1              | always; zeroed if nocp not in bsse_type                            | cumulative through {max_nbody}-body total energies with nocp treatment                                             |</span>
<span class="sd">        +---------------------------------------------------------------+----------------------+--------------------------------------------------------------------+--------------------------------------------------------------------------------------------------------------------+</span>
<span class="sd">        | nocp_gradient_body_dict                                       | max_nbody            | when driver is g/h; zeroed if nocp not in bsse_type                | total gradients at each n-body level with nocp treatment                                                           |</span>
<span class="sd">        +---------------------------------------------------------------+----------------------+--------------------------------------------------------------------+--------------------------------------------------------------------------------------------------------------------+</span>
<span class="sd">        |   |em| 1nocp                                                  |  |em| (nat, 3)       | when driver is g/h; zeroed if nocp not in bsse_type                | cumulative through 1-body total gradients with nocp treatment                                                      |</span>
<span class="sd">        +---------------------------------------------------------------+----------------------+--------------------------------------------------------------------+--------------------------------------------------------------------------------------------------------------------+</span>
<span class="sd">        |   |em| 2nocp                                                  |  |em| (nat, 3)       | when driver is g/h &amp; max_nbody&gt;=2; zeroed if nocp not in bsse_type | cumulative through 2-body total gradients with nocp treatment                                                      |</span>
<span class="sd">        +---------------------------------------------------------------+----------------------+--------------------------------------------------------------------+--------------------------------------------------------------------------------------------------------------------+</span>
<span class="sd">        |   |em| {max_nbody}nocp                                        |  |em| (nat, 3)       | when driver is g/h; zeroed if nocp not in bsse_type                | cumulative through {max_nbody}-body total gradients with nocp treatment                                            |</span>
<span class="sd">        +---------------------------------------------------------------+----------------------+--------------------------------------------------------------------+--------------------------------------------------------------------------------------------------------------------+</span>
<span class="sd">        | nocp_hessian_body_dict                                        | max_nbody            | when driver is h; zeroed if nocp not in bsse_type                  | total Hessians at each n-body level with nocp treatment                                                            |</span>
<span class="sd">        +---------------------------------------------------------------+----------------------+--------------------------------------------------------------------+--------------------------------------------------------------------------------------------------------------------+</span>
<span class="sd">        |   |em| 1nocp                                                  |  |em| (nat*3, nat*3) | when driver is h; zeroed if nocp not in bsse_type                  | cumulative through 1-body total Hessians with nocp treatment                                                       |</span>
<span class="sd">        +---------------------------------------------------------------+----------------------+--------------------------------------------------------------------+--------------------------------------------------------------------------------------------------------------------+</span>
<span class="sd">        |   |em| 2nocp                                                  |  |em| (nat*3, nat*3) | when driver is h &amp; max_nbody&gt;=2; zeroed if nocp not in bsse_type   | cumulative through 2-body total Hessians with nocp treatment                                                       |</span>
<span class="sd">        +---------------------------------------------------------------+----------------------+--------------------------------------------------------------------+--------------------------------------------------------------------------------------------------------------------+</span>
<span class="sd">        |   |em| {max_nbody}nocp                                        |  |em| (nat*3, nat*3) | when driver is h; zeroed if nocp not in bsse_type                  | cumulative through {max_nbody}-body total Hessians with nocp treatment                                             |</span>
<span class="sd">        +---------------------------------------------------------------+----------------------+--------------------------------------------------------------------+--------------------------------------------------------------------------------------------------------------------+</span>
<span class="sd">        |                                                               |                      |                                                                    |                                                                                                                    |</span>
<span class="sd">        +---------------------------------------------------------------+----------------------+--------------------------------------------------------------------+--------------------------------------------------------------------------------------------------------------------+</span>
<span class="sd">        | vmfc_energy_body_dict                                         | max_nbody            | always; zeroed if vmfc not in bsse_type                            | total energies at each n-body level with vmfc treatment                                                            |</span>
<span class="sd">        +---------------------------------------------------------------+----------------------+--------------------------------------------------------------------+--------------------------------------------------------------------------------------------------------------------+</span>
<span class="sd">        |   |em| 1vmfc                                                  |  |em| 1              | always; zeroed if vmfc not in bsse_type                            | cumulative through 1-body total energies with vmfc treatment                                                       |</span>
<span class="sd">        +---------------------------------------------------------------+----------------------+--------------------------------------------------------------------+--------------------------------------------------------------------------------------------------------------------+</span>
<span class="sd">        |   |em| 2vmfc                                                  |  |em| 1              | when max_nbody&gt;=2; zeroed if vmfc not in bsse_type                 | cumulative through 2-body total energies with vmfc treatment                                                       |</span>
<span class="sd">        +---------------------------------------------------------------+----------------------+--------------------------------------------------------------------+--------------------------------------------------------------------------------------------------------------------+</span>
<span class="sd">        |   |em| {max_nbody}vmfc                                        |  |em| 1              | always; zeroed if vmfc not in bsse_type                            | cumulative through {max_nbody}-body total energies with vmfc treatment                                             |</span>
<span class="sd">        +---------------------------------------------------------------+----------------------+--------------------------------------------------------------------+--------------------------------------------------------------------------------------------------------------------+</span>
<span class="sd">        | vmfc_gradient_body_dict                                       | max_nbody            | when driver is g/h; zeroed if vmfc not in bsse_type                | total gradients at each n-body level with vmfc treatment                                                           |</span>
<span class="sd">        +---------------------------------------------------------------+----------------------+--------------------------------------------------------------------+--------------------------------------------------------------------------------------------------------------------+</span>
<span class="sd">        |   |em| 1vmfc                                                  |  |em| (nat, 3)       | when driver is g/h; zeroed if vmfc not in bsse_type                | cumulative through 1-body total gradients with vmfc treatment                                                      |</span>
<span class="sd">        +---------------------------------------------------------------+----------------------+--------------------------------------------------------------------+--------------------------------------------------------------------------------------------------------------------+</span>
<span class="sd">        |   |em| 2vmfc                                                  |  |em| (nat, 3)       | when driver is g/h &amp; max_nbody&gt;=2; zeroed if vmfc not in bsse_type | cumulative through 2-body total gradients with vmfc treatment                                                      |</span>
<span class="sd">        +---------------------------------------------------------------+----------------------+--------------------------------------------------------------------+--------------------------------------------------------------------------------------------------------------------+</span>
<span class="sd">        |   |em| {max_nbody}vmfc                                        |  |em| (nat, 3)       | when driver is g/h; zeroed if vmfc not in bsse_type                | cumulative through {max_nbody}-body total gradients with vmfc treatment                                            |</span>
<span class="sd">        +---------------------------------------------------------------+----------------------+--------------------------------------------------------------------+--------------------------------------------------------------------------------------------------------------------+</span>
<span class="sd">        | vmfc_hessian_body_dict                                        | max_nbody            | when driver is h; zeroed if vmfc not in bsse_type                  | total Hessians at each n-body level with vmfc treatment                                                            |</span>
<span class="sd">        +---------------------------------------------------------------+----------------------+--------------------------------------------------------------------+--------------------------------------------------------------------------------------------------------------------+</span>
<span class="sd">        |   |em| 1vmfc                                                  |  |em| (nat*3, nat*3) | when driver is h; zeroed if vmfc not in bsse_type                  | cumulative through 1-body total Hessians with vmfc treatment                                                       |</span>
<span class="sd">        +---------------------------------------------------------------+----------------------+--------------------------------------------------------------------+--------------------------------------------------------------------------------------------------------------------+</span>
<span class="sd">        |   |em| 2vmfc                                                  |  |em| (nat*3, nat*3) | when driver is h &amp; max_nbody&gt;=2; zeroed if vmfc not in bsse_type   | cumulative through 2-body total Hessians with vmfc treatment                                                       |</span>
<span class="sd">        +---------------------------------------------------------------+----------------------+--------------------------------------------------------------------+--------------------------------------------------------------------------------------------------------------------+</span>
<span class="sd">        |   |em| {max_nbody}vmfc                                        |  |em| (nat*3, nat*3) | when driver is h; zeroed if vmfc not in bsse_type                  | cumulative through {max_nbody}-body total Hessians with vmfc treatment                                             |</span>
<span class="sd">        +---------------------------------------------------------------+----------------------+--------------------------------------------------------------------+--------------------------------------------------------------------------------------------------------------------+</span>
<span class="sd">        |                                                               |                      |                                                                    |                                                                                                                    |</span>
<span class="sd">        +---------------------------------------------------------------+----------------------+--------------------------------------------------------------------+--------------------------------------------------------------------------------------------------------------------+</span>
<span class="sd">        | intermediates                                                 | ntasks               | always                                                             | all individual energies with nice labels                                                                           |</span>
<span class="sd">        +---------------------------------------------------------------+----------------------+--------------------------------------------------------------------+--------------------------------------------------------------------------------------------------------------------+</span>
<span class="sd">        |   |em| N-BODY (1, 2)@(1, 2) TOTAL ENERGY                      |  |em| 1              | always                                                             | total energy for 1st modelchem, 1st &amp; 2nd fragments in basis of 1st &amp; 2nd fragments                                |</span>
<span class="sd">        +---------------------------------------------------------------+----------------------+--------------------------------------------------------------------+--------------------------------------------------------------------------------------------------------------------+</span>
<span class="sd">        |   |em| N-BODY (3)@(2, 3) TOTAL ENERGY                         |  |em| 1              | always                                                             | total energy for 2nd modelchem, 3rd fragment in basis of 2nd and 3rd fragments                                     |</span>
<span class="sd">        +---------------------------------------------------------------+----------------------+--------------------------------------------------------------------+--------------------------------------------------------------------------------------------------------------------+</span>
<span class="sd">        |   |em| ...                                                    |                      |                                                                    |                                                                                                                    |</span>
<span class="sd">        +---------------------------------------------------------------+----------------------+--------------------------------------------------------------------+--------------------------------------------------------------------------------------------------------------------+</span>
<span class="sd">        |                                                               |                      |                                                                    |                                                                                                                    |</span>
<span class="sd">        +---------------------------------------------------------------+----------------------+--------------------------------------------------------------------+--------------------------------------------------------------------------------------------------------------------+</span>
<span class="sd">        | intermediates_energy                                          | ntasks               | always                                                             | all individual energies                                                                                            |</span>
<span class="sd">        +---------------------------------------------------------------+----------------------+--------------------------------------------------------------------+--------------------------------------------------------------------------------------------------------------------+</span>
<span class="sd">        |   |em| 1_((1, 2), (1, 2))                                     |  |em| 1              | always                                                             | total energy for 1st modelchem, 1st &amp; 2nd fragments in basis of 1st &amp; 2nd fragments                                |</span>
<span class="sd">        +---------------------------------------------------------------+----------------------+--------------------------------------------------------------------+--------------------------------------------------------------------------------------------------------------------+</span>
<span class="sd">        |   |em| 2_((3,), (2, 3))                                       |  |em| 1              | always                                                             | total energy for 2nd modelchem, 3rd fragment in basis of 2nd and 3rd fragments                                     |</span>
<span class="sd">        +---------------------------------------------------------------+----------------------+--------------------------------------------------------------------+--------------------------------------------------------------------------------------------------------------------+</span>
<span class="sd">        |   |em| ...                                                    |                      |                                                                    |                                                                                                                    |</span>
<span class="sd">        +---------------------------------------------------------------+----------------------+--------------------------------------------------------------------+--------------------------------------------------------------------------------------------------------------------+</span>
<span class="sd">        |                                                               |                      |                                                                    |                                                                                                                    |</span>
<span class="sd">        +---------------------------------------------------------------+----------------------+--------------------------------------------------------------------+--------------------------------------------------------------------------------------------------------------------+</span>
<span class="sd">        | intermediates_gradient                                        | ntasks               | when driver is g/h                                                 | all individual gradients                                                                                           |</span>
<span class="sd">        +---------------------------------------------------------------+----------------------+--------------------------------------------------------------------+--------------------------------------------------------------------------------------------------------------------+</span>
<span class="sd">        |   |em| 1_((1, 2), (1, 2))                                     |  |em| (nat, 3)       | when driver is g/h                                                 | total gradient for 1st modelchem, 1st &amp; 2nd fragments in basis of 1st &amp; 2nd fragments                              |</span>
<span class="sd">        +---------------------------------------------------------------+----------------------+--------------------------------------------------------------------+--------------------------------------------------------------------------------------------------------------------+</span>
<span class="sd">        |   |em| 2_((3,), (2, 3))                                       |  |em| (nat, 3)       | when driver is g/h                                                 | total gradient for 2nd modelchem, 3rd fragment in basis of 2nd and 3rd fragments                                   |</span>
<span class="sd">        +---------------------------------------------------------------+----------------------+--------------------------------------------------------------------+--------------------------------------------------------------------------------------------------------------------+</span>
<span class="sd">        |   |em| ...                                                    |                      |                                                                    |                                                                                                                    |</span>
<span class="sd">        +---------------------------------------------------------------+----------------------+--------------------------------------------------------------------+--------------------------------------------------------------------------------------------------------------------+</span>
<span class="sd">        |                                                               |                      |                                                                    |                                                                                                                    |</span>
<span class="sd">        +---------------------------------------------------------------+----------------------+--------------------------------------------------------------------+--------------------------------------------------------------------------------------------------------------------+</span>
<span class="sd">        | intermediates_hessian                                         | ntasks               | when driver is h                                                   | all individual Hessians                                                                                            |</span>
<span class="sd">        +---------------------------------------------------------------+----------------------+--------------------------------------------------------------------+--------------------------------------------------------------------------------------------------------------------+</span>
<span class="sd">        |   |em| 1_((1, 2), (1, 2))                                     |  |em| (nat*3, nat*3) | when driver is h                                                   | total Hessian for 1st modelchem, 1st &amp; 2nd fragments in basis of 1st &amp; 2nd fragments                               |</span>
<span class="sd">        +---------------------------------------------------------------+----------------------+--------------------------------------------------------------------+--------------------------------------------------------------------------------------------------------------------+</span>
<span class="sd">        |   |em| 2_((3,), (2, 3))                                       |  |em| (nat*3, nat*3) | when driver is h                                                   | total Hessian for 2nd modelchem, 3rd fragment in basis of 2nd and 3rd fragments                                    |</span>
<span class="sd">        +---------------------------------------------------------------+----------------------+--------------------------------------------------------------------+--------------------------------------------------------------------------------------------------------------------+</span>
<span class="sd">        |   |em| ...                                                    |                      |                                                                    |                                                                                                                    |</span>
<span class="sd">        +---------------------------------------------------------------+----------------------+--------------------------------------------------------------------+--------------------------------------------------------------------------------------------------------------------+</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">results</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">results</span> <span class="o">=</span> <span class="p">{}</span>

        <span class="c1"># formerly nlevels</span>
        <span class="n">mc_level_labels</span> <span class="o">=</span> <span class="p">{</span><span class="n">i</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s2">&quot;_&quot;</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">task_list</span><span class="p">}</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">mc_level_labels</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">results</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">driver_nbody_multilevel</span><span class="o">.</span><span class="n">prepare_results</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">client</span><span class="p">)</span>

        <span class="n">results_list</span> <span class="o">=</span> <span class="p">{</span><span class="n">k</span><span class="p">:</span> <span class="n">v</span><span class="o">.</span><span class="n">get_results</span><span class="p">(</span><span class="n">client</span><span class="o">=</span><span class="n">client</span><span class="p">)</span> <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="p">(</span><span class="n">results</span><span class="o">.</span><span class="n">items</span><span class="p">()</span> <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">task_list</span><span class="o">.</span><span class="n">items</span><span class="p">())}</span>
        <span class="n">trove</span> <span class="o">=</span> <span class="p">{</span>  <span class="c1"># AtomicResult.properties return None if missing</span>
            <span class="s2">&quot;energy&quot;</span><span class="p">:</span> <span class="p">{</span><span class="n">k</span><span class="p">:</span> <span class="n">v</span><span class="o">.</span><span class="n">properties</span><span class="o">.</span><span class="n">return_energy</span> <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">results_list</span><span class="o">.</span><span class="n">items</span><span class="p">()},</span>
            <span class="s2">&quot;gradient&quot;</span><span class="p">:</span> <span class="p">{</span><span class="n">k</span><span class="p">:</span> <span class="n">v</span><span class="o">.</span><span class="n">properties</span><span class="o">.</span><span class="n">return_gradient</span> <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">results_list</span><span class="o">.</span><span class="n">items</span><span class="p">()},</span>
            <span class="s2">&quot;hessian&quot;</span><span class="p">:</span> <span class="p">{</span><span class="n">k</span><span class="p">:</span> <span class="n">v</span><span class="o">.</span><span class="n">properties</span><span class="o">.</span><span class="n">return_hessian</span> <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">results_list</span><span class="o">.</span><span class="n">items</span><span class="p">()},</span>
        <span class="p">}</span>

        <span class="c1"># TODO: make assemble_nbody_components and driver_nbody_multilevel.prepare_results into class functions.</span>
        <span class="c1">#   note that the former uses metadata as read-only (except for one solveable case) while the latter overwrites self (!).</span>
        <span class="n">metadata</span> <span class="o">=</span> <span class="p">{</span>
            <span class="s2">&quot;quiet&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">quiet</span><span class="p">,</span>
            <span class="s2">&quot;nbodies_per_mc_level&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">nbodies_per_mc_level</span><span class="p">,</span>
            <span class="s2">&quot;bsse_type&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">bsse_type</span><span class="p">,</span>
            <span class="s2">&quot;nfragments&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">nfragments</span><span class="p">,</span>
            <span class="s2">&quot;return_total_data&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">return_total_data</span><span class="p">,</span>
            <span class="s2">&quot;molecule&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">molecule</span><span class="p">,</span>
            <span class="s2">&quot;embedding_charges&quot;</span><span class="p">:</span> <span class="nb">bool</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">embedding_charges</span><span class="p">),</span>
            <span class="s2">&quot;max_nbody&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">max_nbody</span><span class="p">,</span>
        <span class="p">}</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">driver</span><span class="o">.</span><span class="n">name</span> <span class="o">==</span> <span class="s2">&quot;energy&quot;</span><span class="p">:</span>
            <span class="n">nbody_results</span> <span class="o">=</span> <span class="n">assemble_nbody_components</span><span class="p">(</span><span class="s2">&quot;energy&quot;</span><span class="p">,</span> <span class="n">trove</span><span class="p">[</span><span class="s2">&quot;energy&quot;</span><span class="p">],</span> <span class="n">metadata</span><span class="o">.</span><span class="n">copy</span><span class="p">())</span>

        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">driver</span><span class="o">.</span><span class="n">name</span> <span class="o">==</span> <span class="s2">&quot;gradient&quot;</span><span class="p">:</span>
            <span class="n">nbody_results</span> <span class="o">=</span> <span class="n">assemble_nbody_components</span><span class="p">(</span><span class="s2">&quot;energy&quot;</span><span class="p">,</span> <span class="n">trove</span><span class="p">[</span><span class="s2">&quot;energy&quot;</span><span class="p">],</span> <span class="n">metadata</span><span class="o">.</span><span class="n">copy</span><span class="p">())</span>
            <span class="n">nbody_results</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">assemble_nbody_components</span><span class="p">(</span><span class="s2">&quot;gradient&quot;</span><span class="p">,</span> <span class="n">trove</span><span class="p">[</span><span class="s2">&quot;gradient&quot;</span><span class="p">],</span> <span class="n">metadata</span><span class="o">.</span><span class="n">copy</span><span class="p">()))</span>

        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">driver</span><span class="o">.</span><span class="n">name</span> <span class="o">==</span> <span class="s2">&quot;hessian&quot;</span><span class="p">:</span>
            <span class="n">nbody_results</span> <span class="o">=</span> <span class="n">assemble_nbody_components</span><span class="p">(</span><span class="s2">&quot;energy&quot;</span><span class="p">,</span> <span class="n">trove</span><span class="p">[</span><span class="s2">&quot;energy&quot;</span><span class="p">],</span> <span class="n">metadata</span><span class="o">.</span><span class="n">copy</span><span class="p">())</span>
            <span class="n">nbody_results</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">assemble_nbody_components</span><span class="p">(</span><span class="s2">&quot;gradient&quot;</span><span class="p">,</span> <span class="n">trove</span><span class="p">[</span><span class="s2">&quot;gradient&quot;</span><span class="p">],</span> <span class="n">metadata</span><span class="o">.</span><span class="n">copy</span><span class="p">()))</span>
            <span class="n">nbody_results</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">assemble_nbody_components</span><span class="p">(</span><span class="s2">&quot;hessian&quot;</span><span class="p">,</span> <span class="n">trove</span><span class="p">[</span><span class="s2">&quot;hessian&quot;</span><span class="p">],</span> <span class="n">metadata</span><span class="o">.</span><span class="n">copy</span><span class="p">()))</span>

        <span class="k">def</span> <span class="nf">delabeler</span><span class="p">(</span><span class="n">item</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">return_obj</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Union</span><span class="p">[</span><span class="n">Tuple</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">],</span> <span class="n">Tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="n">Tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">],</span> <span class="n">Tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">]]]:</span>
<span class="w">            </span><span class="sd">&quot;&quot;&quot;Transform labels like string &quot;1_((2,), (1, 2))&quot; into string tuple (&quot;1&quot;, &quot;2&quot;, &quot;1, 2&quot;) or object tuple (1, (2,), (1, 2)).&quot;&quot;&quot;</span>

            <span class="n">mc</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">fragbas</span> <span class="o">=</span> <span class="n">item</span><span class="o">.</span><span class="n">partition</span><span class="p">(</span><span class="s2">&quot;_&quot;</span><span class="p">)</span>
            <span class="n">frag</span><span class="p">,</span> <span class="n">bas</span> <span class="o">=</span> <span class="n">literal_eval</span><span class="p">(</span><span class="n">fragbas</span><span class="p">)</span>

            <span class="k">if</span> <span class="n">return_obj</span><span class="p">:</span>
                <span class="k">return</span> <span class="nb">int</span><span class="p">(</span><span class="n">mc</span><span class="p">),</span> <span class="n">frag</span><span class="p">,</span> <span class="n">bas</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">mc</span><span class="p">,</span> <span class="s2">&quot;, &quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="nb">str</span><span class="p">,</span> <span class="n">frag</span><span class="p">)),</span> <span class="s2">&quot;, &quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="nb">str</span><span class="p">,</span> <span class="n">bas</span><span class="p">))</span>

        <span class="c1"># save some mc_(frag, bas) component results</span>
        <span class="c1"># * formerly, intermediates_energy was intermediates2</span>
        <span class="c1"># * formerly, intermediates_gradient was intermediates_ptype</span>
        <span class="c1"># * formerly, intermediates_hessian was intermediates_ptype</span>

        <span class="n">nbody_results</span><span class="p">[</span><span class="s2">&quot;intermediates&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">for</span> <span class="n">idx</span><span class="p">,</span> <span class="n">task</span> <span class="ow">in</span> <span class="n">results_list</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="n">mc</span><span class="p">,</span> <span class="n">frag</span><span class="p">,</span> <span class="n">bas</span> <span class="o">=</span> <span class="n">delabeler</span><span class="p">(</span><span class="n">idx</span><span class="p">)</span>
            <span class="n">nbody_results</span><span class="p">[</span><span class="s2">&quot;intermediates&quot;</span><span class="p">][</span><span class="sa">f</span><span class="s2">&quot;N-BODY (</span><span class="si">{</span><span class="n">frag</span><span class="si">}</span><span class="s2">)@(</span><span class="si">{</span><span class="n">bas</span><span class="si">}</span><span class="s2">) TOTAL ENERGY&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">task</span><span class="o">.</span><span class="n">properties</span><span class="o">.</span><span class="n">return_energy</span>

        <span class="n">nbody_results</span><span class="p">[</span><span class="s2">&quot;intermediates_energy&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">trove</span><span class="p">[</span><span class="s2">&quot;energy&quot;</span><span class="p">]</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="nb">all</span><span class="p">(</span><span class="n">x</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">trove</span><span class="p">[</span><span class="s2">&quot;gradient&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">values</span><span class="p">()):</span>
            <span class="n">nbody_results</span><span class="p">[</span><span class="s2">&quot;intermediates_gradient&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">trove</span><span class="p">[</span><span class="s2">&quot;gradient&quot;</span><span class="p">]</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="nb">all</span><span class="p">(</span><span class="n">x</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">trove</span><span class="p">[</span><span class="s2">&quot;hessian&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">values</span><span class="p">()):</span>
            <span class="n">nbody_results</span><span class="p">[</span><span class="s2">&quot;intermediates_hessian&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">trove</span><span class="p">[</span><span class="s2">&quot;hessian&quot;</span><span class="p">]</span>

        <span class="n">debug</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="k">if</span> <span class="n">debug</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">nbody_results</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">):</span>
                    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;CLS-prepared results &gt;&gt;&gt; </span><span class="si">{</span><span class="n">k</span><span class="si">}</span><span class="s2"> </span><span class="si">{</span><span class="n">v</span><span class="o">.</span><span class="n">size</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
                <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="nb">dict</span><span class="p">):</span>
                    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;CLS-prepared results &gt;&gt;&gt; </span><span class="si">{</span><span class="n">k</span><span class="si">}</span><span class="s2"> </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">v</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
                    <span class="k">for</span> <span class="n">k2</span><span class="p">,</span> <span class="n">v2</span> <span class="ow">in</span> <span class="n">v</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">v2</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">):</span>
                            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;CLS-prepared results      &gt;&gt;&gt; </span><span class="si">{</span><span class="n">k2</span><span class="si">}</span><span class="s2"> </span><span class="si">{</span><span class="n">v2</span><span class="o">.</span><span class="n">size</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
                        <span class="k">else</span><span class="p">:</span>
                            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;CLS-prepared results      &gt;&gt;&gt; </span><span class="si">{</span><span class="n">k2</span><span class="si">}</span><span class="s2"> </span><span class="si">{</span><span class="n">v2</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;CLS-prepared results &gt;&gt;&gt; </span><span class="si">{</span><span class="n">k</span><span class="si">}</span><span class="s2"> </span><span class="si">{</span><span class="n">v</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">nbody_results</span></div>

<div class="viewcode-block" id="ManyBodyComputer.get_results"><a class="viewcode-back" href="../../../nbody.html#psi4.driver.driver_nbody.ManyBodyComputer.get_results">[docs]</a>    <span class="k">def</span> <span class="nf">get_results</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">client</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="s2">&quot;qcportal.FractalClient&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">AtomicResult</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Return results as ManyBody-flavored QCSchema.&quot;&quot;&quot;</span>

        <span class="n">info</span> <span class="o">=</span> <span class="s2">&quot;</span><span class="se">\n</span><span class="s2">&quot;</span> <span class="o">+</span> <span class="n">p4util</span><span class="o">.</span><span class="n">banner</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot; ManyBody Results &quot;</span><span class="p">,</span> <span class="n">strNotOutfile</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span> <span class="o">+</span> <span class="s2">&quot;</span><span class="se">\n</span><span class="s2">&quot;</span>
        <span class="n">core</span><span class="o">.</span><span class="n">print_out</span><span class="p">(</span><span class="n">info</span><span class="p">)</span>
        <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="n">info</span><span class="p">)</span>

        <span class="n">results</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">prepare_results</span><span class="p">(</span><span class="n">client</span><span class="o">=</span><span class="n">client</span><span class="p">)</span>
        <span class="n">ret_energy</span> <span class="o">=</span> <span class="n">results</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s2">&quot;ret_energy&quot;</span><span class="p">)</span>
        <span class="n">ret_ptype</span> <span class="o">=</span> <span class="n">results</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s2">&quot;ret_ptype&quot;</span><span class="p">)</span>
        <span class="n">ret_gradient</span> <span class="o">=</span> <span class="n">results</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s2">&quot;ret_gradient&quot;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>

        <span class="c1"># load QCVariables</span>
        <span class="n">qcvars</span> <span class="o">=</span> <span class="p">{</span>
            <span class="s1">&#39;NUCLEAR REPULSION ENERGY&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">molecule</span><span class="o">.</span><span class="n">nuclear_repulsion_energy</span><span class="p">(),</span>
            <span class="s1">&#39;NBODY NUMBER&#39;</span><span class="p">:</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">task_list</span><span class="p">),</span>
        <span class="p">}</span>

        <span class="n">properties</span> <span class="o">=</span> <span class="p">{</span>
            <span class="s2">&quot;calcinfo_natom&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">molecule</span><span class="o">.</span><span class="n">natom</span><span class="p">(),</span>
            <span class="s2">&quot;nuclear_repulsion_energy&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">molecule</span><span class="o">.</span><span class="n">nuclear_repulsion_energy</span><span class="p">(),</span>
            <span class="s2">&quot;return_energy&quot;</span><span class="p">:</span> <span class="n">ret_energy</span><span class="p">,</span>
        <span class="p">}</span>

        <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">val</span> <span class="ow">in</span> <span class="n">results</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="n">qcvars</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="n">val</span>

        <span class="n">qcvars</span><span class="p">[</span><span class="s1">&#39;CURRENT ENERGY&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">ret_energy</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">driver</span> <span class="o">==</span> <span class="s1">&#39;gradient&#39;</span><span class="p">:</span>
            <span class="n">qcvars</span><span class="p">[</span><span class="s1">&#39;CURRENT GRADIENT&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">ret_ptype</span>
            <span class="n">properties</span><span class="p">[</span><span class="s2">&quot;return_gradient&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">ret_ptype</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">driver</span> <span class="o">==</span> <span class="s1">&#39;hessian&#39;</span><span class="p">:</span>
            <span class="n">qcvars</span><span class="p">[</span><span class="s1">&#39;CURRENT GRADIENT&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">ret_gradient</span>
            <span class="n">qcvars</span><span class="p">[</span><span class="s1">&#39;CURRENT HESSIAN&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">ret_ptype</span>
            <span class="n">properties</span><span class="p">[</span><span class="s2">&quot;return_gradient&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">ret_gradient</span>
            <span class="n">properties</span><span class="p">[</span><span class="s2">&quot;return_hessian&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">ret_ptype</span>

        <span class="n">component_results</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">dict</span><span class="p">()[</span><span class="s1">&#39;task_list&#39;</span><span class="p">]</span>
        <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">val</span> <span class="ow">in</span> <span class="n">component_results</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="n">val</span><span class="p">[</span><span class="s1">&#39;molecule&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">val</span><span class="p">[</span><span class="s1">&#39;molecule&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">to_schema</span><span class="p">(</span><span class="n">dtype</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>

        <span class="n">nbody_model</span> <span class="o">=</span> <span class="n">AtomicResult</span><span class="p">(</span>
            <span class="o">**</span><span class="p">{</span>
                <span class="s1">&#39;driver&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">driver</span><span class="p">,</span>
                <span class="s1">&#39;model&#39;</span><span class="p">:</span> <span class="p">{</span>
                    <span class="s1">&#39;method&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">method</span><span class="p">,</span>
                    <span class="s1">&#39;basis&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">basis</span><span class="p">,</span>
                <span class="p">},</span>
                <span class="s1">&#39;molecule&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">molecule</span><span class="o">.</span><span class="n">to_schema</span><span class="p">(</span><span class="n">dtype</span><span class="o">=</span><span class="mi">2</span><span class="p">),</span>
                <span class="s1">&#39;properties&#39;</span><span class="p">:</span> <span class="n">properties</span><span class="p">,</span>
                <span class="s1">&#39;provenance&#39;</span><span class="p">:</span> <span class="n">p4util</span><span class="o">.</span><span class="n">provenance_stamp</span><span class="p">(</span><span class="vm">__name__</span><span class="p">),</span>
                <span class="s1">&#39;extras&#39;</span><span class="p">:</span> <span class="p">{</span>
                    <span class="s1">&#39;qcvars&#39;</span><span class="p">:</span> <span class="n">qcvars</span><span class="p">,</span>
                    <span class="s1">&#39;component_results&#39;</span><span class="p">:</span> <span class="n">component_results</span><span class="p">,</span>
                <span class="p">},</span>
                <span class="s1">&#39;return_result&#39;</span><span class="p">:</span> <span class="n">ret_ptype</span><span class="p">,</span>
                <span class="s1">&#39;success&#39;</span><span class="p">:</span> <span class="kc">True</span><span class="p">,</span>
            <span class="p">})</span>

        <span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s1">&#39;</span><span class="se">\n</span><span class="s1">NBODY QCSchema:</span><span class="se">\n</span><span class="s1">&#39;</span> <span class="o">+</span> <span class="n">pp</span><span class="o">.</span><span class="n">pformat</span><span class="p">(</span><span class="n">nbody_model</span><span class="o">.</span><span class="n">dict</span><span class="p">()))</span>

        <span class="k">return</span> <span class="n">nbody_model</span></div>

<div class="viewcode-block" id="ManyBodyComputer.get_psi_results"><a class="viewcode-back" href="../../../nbody.html#psi4.driver.driver_nbody.ManyBodyComputer.get_psi_results">[docs]</a>    <span class="k">def</span> <span class="nf">get_psi_results</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">client</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="s2">&quot;qcportal.FractalClient&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="o">*</span><span class="p">,</span>
        <span class="n">return_wfn</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">EnergyGradientHessianWfnReturn</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Called by driver to assemble results into ManyBody-flavored QCSchema,</span>
<span class="sd">        then reshape and return them in the customary Psi4 driver interface: ``(e/g/h, wfn)``.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        return_wfn</span>
<span class="sd">            Whether to additionally return the dummy :py:class:`~psi4.core.Wavefunction`</span>
<span class="sd">            calculation result as the second element of a tuple. Contents are:</span>

<span class="sd">            - supersystem molecule</span>
<span class="sd">            - dummy basis, def2-svp</span>
<span class="sd">            - e/g/h member data</span>
<span class="sd">            - QCVariables</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        ret</span>
<span class="sd">            Energy, gradient, or Hessian according to self.driver.</span>
<span class="sd">        wfn</span>
<span class="sd">            Wavefunction described above when *return_wfn* specified.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">nbody_model</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_results</span><span class="p">(</span><span class="n">client</span><span class="o">=</span><span class="n">client</span><span class="p">)</span>
        <span class="n">ret</span> <span class="o">=</span> <span class="n">nbody_model</span><span class="o">.</span><span class="n">return_result</span>

        <span class="n">wfn</span> <span class="o">=</span> <span class="n">core</span><span class="o">.</span><span class="n">Wavefunction</span><span class="o">.</span><span class="n">build</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">molecule</span><span class="p">,</span> <span class="s2">&quot;def2-svp&quot;</span><span class="p">,</span> <span class="n">quiet</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

        <span class="c1"># TODO all besides nbody may be better candidates for extras than qcvars. energy/gradient/hessian_body_dict in particular are too simple for qcvars (e.g., &quot;2&quot;)</span>
        <span class="n">dicts</span> <span class="o">=</span> <span class="p">[</span>
            <span class="c1">#&quot;energies&quot;,  # retired</span>
            <span class="c1">#&quot;ptype&quot;,     # retired</span>
            <span class="s2">&quot;intermediates&quot;</span><span class="p">,</span>
            <span class="s2">&quot;intermediates_energy&quot;</span><span class="p">,</span>  <span class="c1">#&quot;intermediates2&quot;,</span>
            <span class="s2">&quot;intermediates_gradient&quot;</span><span class="p">,</span>  <span class="c1">#&quot;intermediates_ptype&quot;,</span>
            <span class="s2">&quot;intermediates_hessian&quot;</span><span class="p">,</span>  <span class="c1">#&quot;intermediates_ptype&quot;,</span>
            <span class="s2">&quot;energy_body_dict&quot;</span><span class="p">,</span>
            <span class="s2">&quot;gradient_body_dict&quot;</span><span class="p">,</span>  <span class="c1"># ptype_body_dict</span>
            <span class="s2">&quot;hessian_body_dict&quot;</span><span class="p">,</span>  <span class="c1"># ptype_body_dict</span>
            <span class="s2">&quot;nbody&quot;</span><span class="p">,</span>
            <span class="s2">&quot;cp_energy_body_dict&quot;</span><span class="p">,</span>
            <span class="s2">&quot;nocp_energy_body_dict&quot;</span><span class="p">,</span>
            <span class="s2">&quot;vmfc_energy_body_dict&quot;</span><span class="p">,</span>
            <span class="s2">&quot;cp_gradient_body_dict&quot;</span><span class="p">,</span>
            <span class="s2">&quot;nocp_gradient_body_dict&quot;</span><span class="p">,</span>
            <span class="s2">&quot;vmfc_gradient_body_dict&quot;</span><span class="p">,</span>
            <span class="s2">&quot;cp_hessian_body_dict&quot;</span><span class="p">,</span>
            <span class="s2">&quot;nocp_hessian_body_dict&quot;</span><span class="p">,</span>
            <span class="s2">&quot;vmfc_hessian_body_dict&quot;</span><span class="p">,</span>
        <span class="p">]</span>

        <span class="k">for</span> <span class="n">qcv</span><span class="p">,</span> <span class="n">val</span> <span class="ow">in</span> <span class="n">nbody_model</span><span class="o">.</span><span class="n">extras</span><span class="p">[</span><span class="s1">&#39;qcvars&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">val</span><span class="p">,</span> <span class="nb">dict</span><span class="p">):</span>
                <span class="k">if</span> <span class="n">qcv</span> <span class="ow">in</span> <span class="n">dicts</span><span class="p">:</span>
                    <span class="k">for</span> <span class="n">qcv2</span><span class="p">,</span> <span class="n">val2</span> <span class="ow">in</span> <span class="n">val</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                        <span class="k">for</span> <span class="n">obj</span> <span class="ow">in</span> <span class="p">[</span><span class="n">core</span><span class="p">,</span> <span class="n">wfn</span><span class="p">]:</span>
                            <span class="k">try</span><span class="p">:</span>
                                <span class="n">obj</span><span class="o">.</span><span class="n">set_variable</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">qcv2</span><span class="p">),</span> <span class="n">val2</span><span class="p">)</span>
                            <span class="k">except</span> <span class="n">ValidationError</span><span class="p">:</span>
                                <span class="n">obj</span><span class="o">.</span><span class="n">set_variable</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">driver</span><span class="o">.</span><span class="n">name</span><span class="si">}</span><span class="s2"> </span><span class="si">{</span><span class="n">qcv2</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">,</span> <span class="n">val2</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">for</span> <span class="n">obj</span> <span class="ow">in</span> <span class="p">[</span><span class="n">core</span><span class="p">,</span> <span class="n">wfn</span><span class="p">]:</span>
                    <span class="n">obj</span><span class="o">.</span><span class="n">set_variable</span><span class="p">(</span><span class="n">qcv</span><span class="p">,</span> <span class="n">val</span><span class="p">)</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">driver</span> <span class="o">==</span> <span class="s1">&#39;gradient&#39;</span><span class="p">:</span>
            <span class="n">ret</span> <span class="o">=</span> <span class="n">core</span><span class="o">.</span><span class="n">Matrix</span><span class="o">.</span><span class="n">from_array</span><span class="p">(</span><span class="n">ret</span><span class="p">)</span>
            <span class="n">wfn</span><span class="o">.</span><span class="n">set_gradient</span><span class="p">(</span><span class="n">ret</span><span class="p">)</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">driver</span> <span class="o">==</span> <span class="s1">&#39;hessian&#39;</span><span class="p">:</span>
            <span class="n">ret</span> <span class="o">=</span> <span class="n">core</span><span class="o">.</span><span class="n">Matrix</span><span class="o">.</span><span class="n">from_array</span><span class="p">(</span><span class="n">ret</span><span class="p">)</span>
            <span class="n">grad</span> <span class="o">=</span> <span class="n">core</span><span class="o">.</span><span class="n">Matrix</span><span class="o">.</span><span class="n">from_array</span><span class="p">(</span><span class="n">nbody_model</span><span class="o">.</span><span class="n">properties</span><span class="o">.</span><span class="n">return_gradient</span><span class="p">)</span>
            <span class="n">wfn</span><span class="o">.</span><span class="n">set_hessian</span><span class="p">(</span><span class="n">ret</span><span class="p">)</span>
            <span class="n">wfn</span><span class="o">.</span><span class="n">set_gradient</span><span class="p">(</span><span class="n">grad</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">return_wfn</span><span class="p">:</span>
            <span class="k">return</span> <span class="p">(</span><span class="n">ret</span><span class="p">,</span> <span class="n">wfn</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">ret</span></div></div>


<span class="c1"># TODO questions to check:</span>
<span class="c1"># * can work with supersystem and embedding_charges?</span>
<span class="c1"># * can levels work with same method, different basis?</span>
</pre></div>

            <div class="clearer"></div>
          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper"><!-- 
#
# @BEGIN LICENSE
#
# Psi4: an open-source quantum chemistry software package
#
# Copyright (c) 2007-2017 The Psi4 Developers.
#
# The copyrights for code used from other parties are included in
# the corresponding files.
#
# This file is part of Psi4.
#
# Psi4 is free software; you can redistribute it and/or modify
# it under the terms of the GNU Lesser General Public License as published by
# the Free Software Foundation, version 3.
#
# Psi4 is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU Lesser General Public License for more details.
#
# You should have received a copy of the GNU Lesser General Public License along
# with Psi4; if not, write to the Free Software Foundation, Inc.,
# 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
#
# @END LICENSE
# -->


<div id="searchbox" style="display: none" role="search">
  <!--<h3>Quick search</h3>-->
    <form class="search" action="../../../search.html" method="get">
      <!--<div><input type="text" name="q" placeholder="search docs" /></div>-->
      <div><input type="text" name="q" placeholder="&#xF002;" style="font-family:FontAwesome, Ariel" /></div>
      <!--<div><input type="submit" value="Go" /></div>-->
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
    
    
        <div class="sidebar-toggle-group no-js">
            
            <button class="sidebar-toggle" id="sidebar-hide" title="Hide the sidebar menu">
                 
                <span class="show-for-small">hide menu</span>
                
            </button>
            <button class="sidebar-toggle" id="sidebar-show" title="Show the sidebar menu">
                
                <span class="show-for-small">menu</span>
                <span class="hide-for-small">sidebar</span>
                 
            </button>
        </div>
    
      <div class="clearer"></div>
    </div>
    <div class="relbar-bottom">
        
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../../genindex.html" title="General Index"
             >Index</a></li>
        <li class="right" >
          <a href="../../../py-modindex.html" title="Python Module Index"
             >modules</a> &nbsp; &nbsp;</li>
        <li class="right" >
          <a href="../../../index.html" title="Table Of Contents"
             ><i class="fa fa-book fa-lg"></i></a> &nbsp; &nbsp;</li>
    <li><a href="http://psicode.org/"><i class="fa fa-home fa-lg"></i></a></li>
    <li><a href="http://github.com/psi4/psi4"><i class="fa fa-github fa-lg"></i></a></li>
    <li><a href="http://forum.psicode.org"><i class="fa fa-comments-o fa-lg"></i></a></li>
    <li><a href="http://github.com/psi4/psi4/edit/master/doc/sphinxman/source/_modules/psi4/driver/driver_nbody.rst"><i class="fa fa-pencil fa-lg"></i></a></li>
    <li style="color: #1a4162">&nbsp;&middot;&nbsp;</li>
    <li><a href="http://github.com/psi4/psi4/tree/eed5177">1.9a1.dev27</a></li>
    <li style="color: #1a4162">&nbsp;&middot;&nbsp;</li>
    <li class="nav-item nav-item-0"><a href="../../../index.html">
        <span style="font-family: Optima, sans-serif;">P<span style="font-size: 82%;">SI</span>4</span>
        </a><i class="fa fa-angle-double-right" style="color: #a2a7b3; text-shadow: none;"></i></li>

          <li class="nav-item nav-item-1"><a href="../../index.html" >Module code</a><i class="fa fa-angle-double-right" style="color: #a2a7b3; text-shadow: none;"></i></li>
        <li class="nav-item nav-item-this"><a href="">psi4.driver.driver_nbody</a></li> 
      </ul>
    </div>
    </div>

    <div class="footer" role="contentinfo">
        &#169; Copyright 2007-2023, The Psi4 Project.
      Last updated on Monday, 10 July 2023 10:41PM.
      Created using <a href="https://www.sphinx-doc.org/">Sphinx</a> 7.0.1.
    </div>
    <!-- cloud_sptheme 1.4 -->
  </body>
</html>