<!-- 
#
# @BEGIN LICENSE
#
# Psi4: an open-source quantum chemistry software package
#
# Copyright (c) 2007-2017 The Psi4 Developers.
#
# The copyrights for code used from other parties are included in
# the corresponding files.
#
# This file is part of Psi4.
#
# Psi4 is free software; you can redistribute it and/or modify
# it under the terms of the GNU Lesser General Public License as published by
# the Free Software Foundation, version 3.
#
# Psi4 is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU Lesser General Public License for more details.
#
# You should have received a copy of the GNU Lesser General Public License along
# with Psi4; if not, write to the Free Software Foundation, Inc.,
# 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
#
# @END LICENSE
# -->






<!DOCTYPE html>

<html>
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>psi4.driver.inputparser</title>
    <link rel="stylesheet" type="text/css" href="../../../_static/pygments.css" />
    <link rel="stylesheet" type="text/css" href="../../../_static/psi4.css" />
    <link rel="stylesheet" type="text/css" href="../../../_static/graphviz.css" />
    <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/font-awesome/4.4.0/css/font-awesome.min.css" type="text/css" />
    <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Noticia+Text:400,i,b,bi|Open+Sans:400,i,b,bi|Roboto+Mono:400,i,b,bi&amp;display=swap" type="text/css" />
    
    <script data-url_root="../../../" id="documentation_options" src="../../../_static/documentation_options.js"></script>
    <script src="../../../_static/jquery.js"></script>
    <script src="../../../_static/underscore.js"></script>
    <script src="../../../_static/doctools.js"></script>
    <script crossorigin="anonymous" integrity="sha256-Ae2Vz/4ePdIu6ZyI/5ZGsYnb+m0JlOmKPjt6XZ9JJkA=" src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.4/require.min.js"></script>

    
    
     
        <script src="../../../_static/jquery.cookie.js"></script>
    

    
     
        <script src="../../../_static/cloud.base.js"></script>
    

    
     
        <script src="../../../_static/cloud.js"></script>
    

    <link rel="shortcut icon" href="../../../_static/favicon-psi4.ico"/>
    <link rel="index" title="Index" href="../../../genindex.html" />
    <link rel="search" title="Search" href="../../../search.html" /> 
        <meta name="viewport" content="width=device-width, initial-scale=1">
  </head><body>
    <div class="relbar-top">
        
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../../genindex.html" title="General Index"
             accesskey="I">Index</a></li>
        <li class="right" >
          <a href="../../../py-modindex.html" title="Python Module Index"
             >modules</a> &nbsp; &nbsp;</li>
        <li class="right" >
          <a href="../../../index.html" title="Table Of Contents"
             accesskey="C"><i class="fa fa-book fa-lg"></i></a> &nbsp; &nbsp;</li>
    <li><a href="http://psicode.org/"><i class="fa fa-home fa-lg"></i></a></li>
    <li><a href="http://github.com/psi4/psi4"><i class="fa fa-github fa-lg"></i></a></li>
    <li><a href="http://forum.psicode.org"><i class="fa fa-comments-o fa-lg"></i></a></li>
    <li><a href="http://github.com/psi4/psi4/edit/master/doc/sphinxman/source/_modules/psi4/driver/inputparser.rst"><i class="fa fa-pencil fa-lg"></i></a></li>
    <li style="color: #1a4162">&nbsp;&middot;&nbsp;</li>
    <li><a href="http://github.com/psi4/psi4/tree/19c2642">1.6a1.dev39</a></li>
    <li style="color: #1a4162">&nbsp;&middot;&nbsp;</li>
    <li class="nav-item nav-item-0"><a href="../../../index.html">
        <span style="font-family: Optima, sans-serif;">P<span style="font-size: 82%;">SI</span>4</span>
        </a><i class="fa fa-angle-double-right" style="color: #a2a7b3; text-shadow: none;"></i></li>

          <li class="nav-item nav-item-1"><a href="../../index.html" accesskey="U">Module code</a><i class="fa fa-angle-double-right" style="color: #a2a7b3; text-shadow: none;"></i></li>
        <li class="nav-item nav-item-this"><a href="">psi4.driver.inputparser</a></li> 
      </ul>
    </div>
    </div>
  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <h1>Source code for psi4.driver.inputparser</h1><div class="highlight"><pre>
<span></span><span class="c1">#</span>
<span class="c1"># @BEGIN LICENSE</span>
<span class="c1">#</span>
<span class="c1"># Psi4: an open-source quantum chemistry software package</span>
<span class="c1">#</span>
<span class="c1"># Copyright (c) 2007-2022 The Psi4 Developers.</span>
<span class="c1">#</span>
<span class="c1"># The copyrights for code used from other parties are included in</span>
<span class="c1"># the corresponding files.</span>
<span class="c1">#</span>
<span class="c1"># This file is part of Psi4.</span>
<span class="c1">#</span>
<span class="c1"># Psi4 is free software; you can redistribute it and/or modify</span>
<span class="c1"># it under the terms of the GNU Lesser General Public License as published by</span>
<span class="c1"># the Free Software Foundation, version 3.</span>
<span class="c1">#</span>
<span class="c1"># Psi4 is distributed in the hope that it will be useful,</span>
<span class="c1"># but WITHOUT ANY WARRANTY; without even the implied warranty of</span>
<span class="c1"># MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the</span>
<span class="c1"># GNU Lesser General Public License for more details.</span>
<span class="c1">#</span>
<span class="c1"># You should have received a copy of the GNU Lesser General Public License along</span>
<span class="c1"># with Psi4; if not, write to the Free Software Foundation, Inc.,</span>
<span class="c1"># 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.</span>
<span class="c1">#</span>
<span class="c1"># @END LICENSE</span>
<span class="c1">#</span>
<span class="sd">&quot;&quot;&quot;Module with functions to parse the input file and convert</span>
<span class="sd">Psithon into standard Python. Particularly, forms psi4</span>
<span class="sd">module calls that access the C++ side of Psi4.</span>

<span class="sd">&quot;&quot;&quot;</span>

<span class="kn">import</span> <span class="nn">os</span>
<span class="kn">import</span> <span class="nn">re</span>
<span class="kn">import</span> <span class="nn">sys</span>
<span class="kn">import</span> <span class="nn">uuid</span>

<span class="kn">from</span> <span class="nn">psi4</span> <span class="kn">import</span> <span class="n">core</span>
<span class="kn">from</span> <span class="nn">psi4.driver.p4util.util</span> <span class="kn">import</span> <span class="n">set_memory</span>
<span class="kn">from</span> <span class="nn">psi4.driver.p4util.exceptions</span> <span class="kn">import</span> <span class="o">*</span>


<span class="c1"># inputfile contents to be preserved from the processor</span>
<span class="n">literals</span> <span class="o">=</span> <span class="p">{}</span>

<span class="c1"># experimental - whether to run py statements as they&#39;re parsed from psithon</span>
<span class="n">runalso</span> <span class="o">=</span> <span class="kc">False</span>


<span class="k">def</span> <span class="nf">bad_option_syntax</span><span class="p">(</span><span class="n">line</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Function to report bad syntax to screen and output file.&quot;&quot;&quot;</span>
    <span class="n">message</span> <span class="o">=</span> <span class="p">(</span><span class="s1">&#39;Unsupported syntax:</span><span class="se">\n\n</span><span class="si">%s</span><span class="se">\n\n</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">line</span><span class="p">))</span>
    <span class="k">raise</span> <span class="n">TestComparisonError</span><span class="p">(</span><span class="n">message</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">process_word_quotes</span><span class="p">(</span><span class="n">matchobj</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Function to determine if argument needs wrapping in quotes as string.&quot;&quot;&quot;</span>
    <span class="n">dollar</span> <span class="o">=</span> <span class="n">matchobj</span><span class="o">.</span><span class="n">group</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
    <span class="n">val</span> <span class="o">=</span> <span class="n">matchobj</span><span class="o">.</span><span class="n">group</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">dollar</span><span class="p">:</span>
        <span class="c1"># This is a python variable, make sure that it starts with a letter</span>
        <span class="k">if</span> <span class="n">re</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="sa">r</span><span class="s1">&#39;^[A-Za-z][\w]*&#39;</span><span class="p">,</span> <span class="n">val</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">val</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">message</span> <span class="o">=</span> <span class="p">(</span><span class="s2">&quot;Invalid Python variable: </span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">val</span><span class="p">))</span>
            <span class="k">raise</span> <span class="n">TestComparisonError</span><span class="p">(</span><span class="n">message</span><span class="p">)</span>
    <span class="k">elif</span> <span class="n">re</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="sa">r</span><span class="s1">&#39;^-?\d+\.?\d*(?:[Ee]-?\d+)?$&#39;</span><span class="p">,</span> <span class="n">val</span><span class="p">):</span>
        <span class="c1"># This must be a number, don&#39;t wrap it in quotes</span>
        <span class="k">return</span> <span class="n">val</span>
    <span class="k">elif</span> <span class="n">re</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="sa">r</span><span class="s1">&#39;^</span><span class="se">\&#39;</span><span class="s1">.*</span><span class="se">\&#39;</span><span class="s1">$&#39;</span><span class="p">,</span> <span class="n">val</span><span class="p">)</span> <span class="ow">or</span> <span class="n">re</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="sa">r</span><span class="s1">&#39;^\&quot;.*\&quot;$&#39;</span><span class="p">,</span> <span class="n">val</span><span class="p">):</span>
        <span class="c1"># This is already wrapped in quotes, do nothing</span>
        <span class="k">return</span> <span class="n">val</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="c1"># This must be a string</span>
        <span class="k">return</span> <span class="s2">&quot;</span><span class="se">\&quot;</span><span class="si">%s</span><span class="se">\&quot;</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">val</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">quotify</span><span class="p">(</span><span class="n">string</span><span class="p">,</span> <span class="n">isbasis</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Function to wrap anything that looks like a string in quotes</span>
<span class="sd">    and to remove leading dollar signs from python variables. When *basis*</span>
<span class="sd">    is True, allows commas, since basis sets may have commas and are assured to</span>
<span class="sd">    not involve arrays.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># This wraps anything that looks like a string in quotes, and removes leading</span>
    <span class="c1"># dollar signs from python variables</span>
    <span class="k">if</span> <span class="n">isbasis</span><span class="p">:</span>
        <span class="n">wordre</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">compile</span><span class="p">(</span><span class="sa">r</span><span class="s1">&#39;(([$]?)([-+()*.,\w\&quot;</span><span class="se">\&#39;</span><span class="s1">/</span><span class="se">\\</span><span class="s1">]+))&#39;</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">wordre</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">compile</span><span class="p">(</span><span class="sa">r</span><span class="s1">&#39;(([$]?)([-+()*.\w\&quot;</span><span class="se">\&#39;</span><span class="s1">/</span><span class="se">\\</span><span class="s1">]+))&#39;</span><span class="p">)</span>
    <span class="n">string</span> <span class="o">=</span> <span class="n">wordre</span><span class="o">.</span><span class="n">sub</span><span class="p">(</span><span class="n">process_word_quotes</span><span class="p">,</span> <span class="n">string</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">string</span>


<span class="k">def</span> <span class="nf">dequotify</span><span class="p">(</span><span class="n">string</span><span class="p">):</span>
    <span class="k">if</span> <span class="n">string</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="s1">&#39;&quot;&#39;</span> <span class="ow">and</span> <span class="n">string</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="s1">&#39;&quot;&#39;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">string</span><span class="p">[</span><span class="mi">1</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">string</span>


<span class="k">def</span> <span class="nf">process_option</span><span class="p">(</span><span class="n">spaces</span><span class="p">,</span> <span class="n">module</span><span class="p">,</span> <span class="n">key</span><span class="p">,</span> <span class="n">value</span><span class="p">,</span> <span class="n">line</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Function to process a line with set or in a set block</span>
<span class="sd">    into global/local domain and keyword/value.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">module</span> <span class="o">=</span> <span class="n">module</span><span class="o">.</span><span class="n">upper</span><span class="p">()</span>
    <span class="n">key</span> <span class="o">=</span> <span class="n">key</span><span class="o">.</span><span class="n">upper</span><span class="p">()</span>
    <span class="n">isbasis</span> <span class="o">=</span> <span class="kc">True</span> <span class="k">if</span> <span class="s1">&#39;BASIS&#39;</span> <span class="ow">in</span> <span class="n">key</span> <span class="k">else</span> <span class="kc">False</span>
    <span class="n">value</span> <span class="o">=</span> <span class="n">quotify</span><span class="p">(</span><span class="n">value</span><span class="o">.</span><span class="n">strip</span><span class="p">(),</span> <span class="n">isbasis</span><span class="o">=</span><span class="n">isbasis</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">module</span> <span class="o">==</span> <span class="s2">&quot;GLOBALS&quot;</span> <span class="ow">or</span> <span class="n">module</span> <span class="o">==</span> <span class="s2">&quot;GLOBAL&quot;</span> <span class="ow">or</span> <span class="n">module</span> <span class="o">==</span> <span class="s2">&quot;&quot;</span> <span class="ow">or</span> <span class="n">module</span><span class="o">.</span><span class="n">isspace</span><span class="p">():</span>
        <span class="c1"># If it&#39;s really a global, we need slightly different syntax</span>
        <span class="k">if</span> <span class="n">runalso</span><span class="p">:</span>
            <span class="n">core</span><span class="o">.</span><span class="n">set_global_option</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="n">dequotify</span><span class="p">(</span><span class="n">value</span><span class="p">))</span>
        <span class="k">return</span> <span class="s2">&quot;</span><span class="si">%s</span><span class="s2">core.set_global_option(</span><span class="se">\&quot;</span><span class="si">%s</span><span class="se">\&quot;</span><span class="s2">, </span><span class="si">%s</span><span class="s2">)</span><span class="se">\n</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">spaces</span><span class="p">,</span> <span class="n">key</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="c1"># It&#39;s a local option, so we need the module name in there too</span>
        <span class="k">if</span> <span class="n">runalso</span><span class="p">:</span>
            <span class="n">core</span><span class="o">.</span><span class="n">set_local_option</span><span class="p">(</span><span class="n">module</span><span class="p">,</span> <span class="n">key</span><span class="p">,</span> <span class="n">dequotify</span><span class="p">(</span><span class="n">value</span><span class="p">))</span>
        <span class="k">return</span> <span class="s2">&quot;</span><span class="si">%s</span><span class="s2">core.set_local_option(</span><span class="se">\&quot;</span><span class="si">%s</span><span class="se">\&quot;</span><span class="s2">, </span><span class="se">\&quot;</span><span class="si">%s</span><span class="se">\&quot;</span><span class="s2">, </span><span class="si">%s</span><span class="s2">)</span><span class="se">\n</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">spaces</span><span class="p">,</span> <span class="n">module</span><span class="p">,</span> <span class="n">key</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">process_set_command</span><span class="p">(</span><span class="n">matchobj</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Function to process match of all individual ``set (module_list)</span>
<span class="sd">    key {[value_list] or $value or value}``.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">result</span> <span class="o">=</span> <span class="s2">&quot;&quot;</span>
    <span class="n">module_string</span> <span class="o">=</span> <span class="s2">&quot;&quot;</span>
    <span class="k">if</span> <span class="n">matchobj</span><span class="o">.</span><span class="n">group</span><span class="p">(</span><span class="mi">2</span><span class="p">):</span>
        <span class="n">module_string</span> <span class="o">=</span> <span class="n">matchobj</span><span class="o">.</span><span class="n">group</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">module</span> <span class="ow">in</span> <span class="n">module_string</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s2">&quot;,&quot;</span><span class="p">):</span>
        <span class="n">result</span> <span class="o">+=</span> <span class="n">process_option</span><span class="p">(</span><span class="n">matchobj</span><span class="o">.</span><span class="n">group</span><span class="p">(</span><span class="mi">1</span><span class="p">),</span> <span class="n">module</span><span class="p">,</span> <span class="n">matchobj</span><span class="o">.</span><span class="n">group</span><span class="p">(</span><span class="mi">3</span><span class="p">),</span> <span class="n">matchobj</span><span class="o">.</span><span class="n">group</span><span class="p">(</span><span class="mi">4</span><span class="p">),</span> <span class="n">matchobj</span><span class="o">.</span><span class="n">group</span><span class="p">(</span><span class="mi">0</span><span class="p">))</span>
    <span class="k">return</span> <span class="n">result</span>


<span class="k">def</span> <span class="nf">process_set_commands</span><span class="p">(</span><span class="n">matchobj</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Function to process match of ``set name? { ... }``.&quot;&quot;&quot;</span>
    <span class="n">spaces</span> <span class="o">=</span> <span class="n">matchobj</span><span class="o">.</span><span class="n">group</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
    <span class="n">commands</span> <span class="o">=</span> <span class="n">matchobj</span><span class="o">.</span><span class="n">group</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
    <span class="n">command_lines</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39;</span><span class="se">\n</span><span class="s1">&#39;</span><span class="p">,</span> <span class="n">commands</span><span class="p">)</span>
    <span class="c1"># Remove trailing newline from each line</span>
    <span class="nb">map</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span><span class="o">.</span><span class="n">strip</span><span class="p">(),</span> <span class="n">command_lines</span><span class="p">)</span>
    <span class="n">result</span> <span class="o">=</span> <span class="s2">&quot;&quot;</span>
    <span class="n">module_string</span> <span class="o">=</span> <span class="s2">&quot;&quot;</span>
    <span class="n">command</span> <span class="o">=</span> <span class="s2">&quot;&quot;</span>
    <span class="k">if</span> <span class="n">matchobj</span><span class="o">.</span><span class="n">group</span><span class="p">(</span><span class="mi">2</span><span class="p">):</span>
        <span class="n">module_string</span> <span class="o">=</span> <span class="n">matchobj</span><span class="o">.</span><span class="n">group</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">module</span> <span class="ow">in</span> <span class="n">module_string</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s2">&quot;,&quot;</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">line</span> <span class="ow">in</span> <span class="n">command_lines</span><span class="p">:</span>
            <span class="c1"># Chomp the trailing newline and accumulate</span>
            <span class="n">command</span> <span class="o">+=</span> <span class="n">line</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">check_parentheses_and_brackets</span><span class="p">(</span><span class="n">command</span><span class="p">,</span> <span class="mi">0</span><span class="p">):</span>
                <span class="c1"># If the brackets don&#39;t match up, we need to move on to the next line</span>
                <span class="c1"># and keep going, until they do match. Only then do we process the command</span>
                <span class="k">continue</span>
            <span class="c1"># Ignore blank/empty lines</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">line</span> <span class="ow">or</span> <span class="n">line</span><span class="o">.</span><span class="n">isspace</span><span class="p">():</span>
                <span class="k">continue</span>
            <span class="n">matchobj</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="sa">r</span><span class="s1">&#39;^\s*(\w+)[\s=]+(.*?)$&#39;</span><span class="p">,</span> <span class="n">command</span><span class="p">)</span>
            <span class="c1"># Is the syntax correct? If so, process the line</span>
            <span class="k">if</span> <span class="n">matchobj</span><span class="p">:</span>
                <span class="n">result</span> <span class="o">+=</span> <span class="n">process_option</span><span class="p">(</span><span class="n">spaces</span><span class="p">,</span> <span class="n">module</span><span class="p">,</span> <span class="n">matchobj</span><span class="o">.</span><span class="n">group</span><span class="p">(</span><span class="mi">1</span><span class="p">),</span> <span class="n">matchobj</span><span class="o">.</span><span class="n">group</span><span class="p">(</span><span class="mi">2</span><span class="p">),</span> <span class="n">command</span><span class="p">)</span>
                <span class="c1"># Reset the string</span>
                <span class="n">command</span> <span class="o">=</span> <span class="s2">&quot;&quot;</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">bad_option_syntax</span><span class="p">(</span><span class="n">command</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">result</span>


<span class="k">def</span> <span class="nf">process_from_file_command</span><span class="p">(</span><span class="n">matchobj</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Function that process a match of ``from_file`` in molecule block.&quot;&quot;&quot;</span>
    <span class="n">string</span> <span class="o">=</span> <span class="n">matchobj</span><span class="o">.</span><span class="n">group</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
    <span class="n">mol</span> <span class="o">=</span> <span class="n">core</span><span class="o">.</span><span class="n">mol_from_file</span><span class="p">(</span><span class="n">string</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
    <span class="n">tempmol</span> <span class="o">=</span> <span class="p">[</span><span class="n">line</span> <span class="k">for</span> <span class="n">line</span> <span class="ow">in</span> <span class="n">mol</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39;</span><span class="se">\n</span><span class="s1">&#39;</span><span class="p">)</span> <span class="k">if</span> <span class="n">line</span><span class="o">.</span><span class="n">strip</span><span class="p">()</span> <span class="o">!=</span> <span class="s1">&#39;&#39;</span><span class="p">]</span>
    <span class="n">mol2</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">tempmol</span><span class="p">)</span>
    <span class="n">mol</span> <span class="o">=</span> <span class="s2">&quot;&quot;</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">mol2</span><span class="p">:</span>
        <span class="n">mol</span> <span class="o">+=</span> <span class="n">i</span>
        <span class="n">mol</span> <span class="o">+=</span> <span class="s2">&quot;</span><span class="se">\n</span><span class="s2">&quot;</span>
    <span class="k">return</span> <span class="n">mol</span>


<span class="k">def</span> <span class="nf">process_molecule_command</span><span class="p">(</span><span class="n">matchobj</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Function to process match of ``molecule name? { ... }``.&quot;&quot;&quot;</span>
    <span class="n">spaces</span> <span class="o">=</span> <span class="n">matchobj</span><span class="o">.</span><span class="n">group</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
    <span class="n">name</span> <span class="o">=</span> <span class="n">matchobj</span><span class="o">.</span><span class="n">group</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
    <span class="n">geometry</span> <span class="o">=</span> <span class="n">matchobj</span><span class="o">.</span><span class="n">group</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
    <span class="n">from_filere</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">compile</span><span class="p">(</span><span class="sa">r</span><span class="s1">&#39;^(\s*from_file\s*:\s*(.*)\n)$&#39;</span><span class="p">,</span> <span class="n">re</span><span class="o">.</span><span class="n">MULTILINE</span> <span class="o">|</span> <span class="n">re</span><span class="o">.</span><span class="n">IGNORECASE</span><span class="p">)</span>
    <span class="n">geometry</span> <span class="o">=</span> <span class="n">from_filere</span><span class="o">.</span><span class="n">sub</span><span class="p">(</span><span class="n">process_from_file_command</span><span class="p">,</span> <span class="n">geometry</span><span class="p">)</span>
    <span class="n">molecule</span> <span class="o">=</span> <span class="n">spaces</span>

    <span class="k">if</span> <span class="n">name</span> <span class="o">!=</span> <span class="s2">&quot;&quot;</span><span class="p">:</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">name</span><span class="o">.</span><span class="n">isidentifier</span><span class="p">():</span>
            <span class="k">raise</span> <span class="n">ValidationError</span><span class="p">(</span><span class="s1">&#39;Molecule name not valid Python identifier: &#39;</span> <span class="o">+</span> <span class="n">name</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">name</span> <span class="o">!=</span> <span class="s2">&quot;&quot;</span><span class="p">:</span>
        <span class="n">molecule</span> <span class="o">+=</span> <span class="s1">&#39;</span><span class="si">%s</span><span class="s1"> = &#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">name</span><span class="p">)</span>

    <span class="n">molecule</span> <span class="o">+=</span> <span class="s1">&#39;geometry(&quot;&quot;&quot;</span><span class="si">%s</span><span class="s1">&quot;&quot;&quot;&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">geometry</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">name</span> <span class="o">!=</span> <span class="s2">&quot;&quot;</span><span class="p">:</span>
        <span class="n">molecule</span> <span class="o">+=</span> <span class="s1">&#39;,&quot;</span><span class="si">%s</span><span class="s1">&quot;&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">name</span><span class="p">)</span>

    <span class="n">molecule</span> <span class="o">+=</span> <span class="s2">&quot;)</span><span class="se">\n</span><span class="s2">&quot;</span>
    <span class="n">molecule</span> <span class="o">+=</span> <span class="s1">&#39;</span><span class="si">%s</span><span class="s1">core.IO.set_default_namespace(&quot;</span><span class="si">%s</span><span class="s1">&quot;)&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">spaces</span><span class="p">,</span> <span class="n">name</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">molecule</span>


<span class="k">def</span> <span class="nf">process_literal_blocks</span><span class="p">(</span><span class="n">matchobj</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Function to process match of ``literals_psi4_yo-...``.&quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">literals</span><span class="p">[</span><span class="n">matchobj</span><span class="o">.</span><span class="n">group</span><span class="p">(</span><span class="mi">1</span><span class="p">)]</span>


<span class="k">def</span> <span class="nf">process_cfour_command</span><span class="p">(</span><span class="n">matchobj</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Function to process match of ``cfour name? { ... }``.&quot;&quot;&quot;</span>
    <span class="n">spaces</span> <span class="o">=</span> <span class="n">matchobj</span><span class="o">.</span><span class="n">group</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
    <span class="n">name</span> <span class="o">=</span> <span class="n">matchobj</span><span class="o">.</span><span class="n">group</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
    <span class="n">cfourblock</span> <span class="o">=</span> <span class="n">matchobj</span><span class="o">.</span><span class="n">group</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>

    <span class="n">literalkey</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="n">uuid</span><span class="o">.</span><span class="n">uuid4</span><span class="p">())[:</span><span class="mi">8</span><span class="p">]</span>
    <span class="n">literals</span><span class="p">[</span><span class="n">literalkey</span><span class="p">]</span> <span class="o">=</span> <span class="n">cfourblock</span>
    <span class="k">return</span> <span class="s2">&quot;</span><span class="si">%s</span><span class="s2">core.set_global_option(</span><span class="se">\&quot;</span><span class="si">%s</span><span class="se">\&quot;</span><span class="s2">, </span><span class="se">\&quot;\&quot;\&quot;</span><span class="si">%s</span><span class="se">\n\&quot;\&quot;\&quot;</span><span class="s2">)</span><span class="se">\n</span><span class="s2">&quot;</span> <span class="o">%</span> \
        <span class="p">(</span><span class="n">spaces</span><span class="p">,</span> <span class="s1">&#39;LITERAL_CFOUR&#39;</span><span class="p">,</span> <span class="s1">&#39;literals_psi4_yo-&#39;</span> <span class="o">+</span> <span class="n">literalkey</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">process_extract_command</span><span class="p">(</span><span class="n">matchobj</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Function to process match of ``extract_subsets``.&quot;&quot;&quot;</span>
    <span class="n">spaces</span> <span class="o">=</span> <span class="n">matchobj</span><span class="o">.</span><span class="n">group</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
    <span class="n">name</span> <span class="o">=</span> <span class="n">matchobj</span><span class="o">.</span><span class="n">group</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
    <span class="n">result</span> <span class="o">=</span> <span class="n">matchobj</span><span class="o">.</span><span class="n">group</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
    <span class="n">result</span> <span class="o">+=</span> <span class="s1">&#39;</span><span class="si">%s%s</span><span class="s1">.set_name(&quot;</span><span class="si">%s</span><span class="s1">&quot;)&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">spaces</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">name</span><span class="p">)</span>
    <span class="n">result</span> <span class="o">+=</span> <span class="s2">&quot;</span><span class="se">\n</span><span class="si">%s</span><span class="s2">core.set_active_molecule(</span><span class="si">%s</span><span class="s2">)&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">spaces</span><span class="p">,</span> <span class="n">name</span><span class="p">)</span>
    <span class="n">result</span> <span class="o">+=</span> <span class="s1">&#39;</span><span class="se">\n</span><span class="si">%s</span><span class="s1">core.IO.set_default_namespace(&quot;</span><span class="si">%s</span><span class="s1">&quot;)&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">spaces</span><span class="p">,</span> <span class="n">name</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">result</span>


<span class="k">def</span> <span class="nf">process_print_command</span><span class="p">(</span><span class="n">matchobj</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Function to process match of ``print`` and transform</span>
<span class="sd">    it to ``core.print_out()``.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">spaces</span> <span class="o">=</span> <span class="n">matchobj</span><span class="o">.</span><span class="n">group</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
    <span class="n">string</span> <span class="o">=</span> <span class="n">matchobj</span><span class="o">.</span><span class="n">group</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>

    <span class="k">return</span> <span class="s2">&quot;</span><span class="si">%s</span><span class="s2">core.print_out(str(</span><span class="si">%s</span><span class="s2">))</span><span class="se">\n</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">spaces</span><span class="p">,</span> <span class="nb">str</span><span class="p">(</span><span class="n">string</span><span class="p">))</span>


<span class="k">def</span> <span class="nf">process_memory_command</span><span class="p">(</span><span class="n">matchobj</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Function to process match of ``memory ...``.&quot;&quot;&quot;</span>
    <span class="n">spaces</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="n">matchobj</span><span class="o">.</span><span class="n">group</span><span class="p">(</span><span class="mi">1</span><span class="p">))</span>
    <span class="n">sig</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="n">matchobj</span><span class="o">.</span><span class="n">group</span><span class="p">(</span><span class="mi">2</span><span class="p">))</span>
    <span class="n">units</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="n">matchobj</span><span class="o">.</span><span class="n">group</span><span class="p">(</span><span class="mi">3</span><span class="p">))</span>

    <span class="n">mem_in_bytes</span> <span class="o">=</span> <span class="n">set_memory</span><span class="p">(</span><span class="n">sig</span> <span class="o">+</span> <span class="n">units</span><span class="p">,</span> <span class="n">execute</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>

    <span class="k">return</span> <span class="s2">&quot;</span><span class="si">%s</span><span class="s2">core.set_memory_bytes(</span><span class="si">%d</span><span class="s2">)</span><span class="se">\n</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">spaces</span><span class="p">,</span> <span class="n">mem_in_bytes</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">basname</span><span class="p">(</span><span class="n">name</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Imitates BasisSet.make_filename() without the gbs extension&quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">name</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s1">&#39;+&#39;</span><span class="p">,</span> <span class="s1">&#39;p&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s1">&#39;*&#39;</span><span class="p">,</span> <span class="s1">&#39;s&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s1">&#39;(&#39;</span><span class="p">,</span> <span class="s1">&#39;_&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s1">&#39;)&#39;</span><span class="p">,</span> <span class="s1">&#39;_&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s1">&#39;,&#39;</span><span class="p">,</span> <span class="s1">&#39;_&#39;</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">process_basis_block</span><span class="p">(</span><span class="n">matchobj</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Function to process match of ``basis name? { ... }``.&quot;&quot;&quot;</span>
    <span class="n">spaces</span> <span class="o">=</span> <span class="n">matchobj</span><span class="o">.</span><span class="n">group</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
    <span class="n">basistype</span> <span class="o">=</span> <span class="n">matchobj</span><span class="o">.</span><span class="n">group</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span><span class="o">.</span><span class="n">upper</span><span class="p">()</span>
    <span class="n">name</span> <span class="o">=</span> <span class="n">matchobj</span><span class="o">.</span><span class="n">group</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
    <span class="n">name</span> <span class="o">=</span> <span class="p">(</span><span class="s1">&#39;anonymous&#39;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">uuid</span><span class="o">.</span><span class="n">uuid4</span><span class="p">())[:</span><span class="mi">8</span><span class="p">])</span> <span class="k">if</span> <span class="n">name</span> <span class="o">==</span> <span class="s1">&#39;&#39;</span> <span class="k">else</span> <span class="n">name</span>
    <span class="n">cleanbas</span> <span class="o">=</span> <span class="n">basname</span><span class="p">(</span><span class="n">name</span><span class="p">)</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s1">&#39;-&#39;</span><span class="p">,</span> <span class="s1">&#39;&#39;</span><span class="p">)</span>  <span class="c1"># further remove hyphens so can be function name</span>
    <span class="n">command_lines</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39;</span><span class="se">\n</span><span class="s1">&#39;</span><span class="p">,</span> <span class="n">matchobj</span><span class="o">.</span><span class="n">group</span><span class="p">(</span><span class="mi">4</span><span class="p">))</span>

    <span class="n">symbol_re</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">compile</span><span class="p">(</span><span class="sa">r</span><span class="s1">&#39;^\s*assign\s+(?P&lt;symbol&gt;[A-Z]{1,3})\s+(?P&lt;basis&gt;[-+*\(\)\w]+)\s*$&#39;</span><span class="p">,</span> <span class="n">re</span><span class="o">.</span><span class="n">IGNORECASE</span><span class="p">)</span>
    <span class="n">label_re</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">compile</span><span class="p">(</span>
        <span class="sa">r</span><span class="s1">&#39;^\s*assign\s+(?P&lt;label&gt;(?P&lt;symbol&gt;[A-Z]{1,3})(?:(_\w+)|(\d+))?)\s+(?P&lt;basis&gt;[-+*\(\)\w]+)\s*$&#39;</span><span class="p">,</span>
        <span class="n">re</span><span class="o">.</span><span class="n">IGNORECASE</span><span class="p">)</span>
    <span class="n">all_re</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">compile</span><span class="p">(</span><span class="sa">r</span><span class="s1">&#39;^\s*assign\s+(?P&lt;basis&gt;[-+*\(\)\w]+)\s*$&#39;</span><span class="p">,</span> <span class="n">re</span><span class="o">.</span><span class="n">IGNORECASE</span><span class="p">)</span>
    <span class="n">basislabel</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">compile</span><span class="p">(</span><span class="sa">r</span><span class="s1">&#39;\s*\[\s*([-*\(\)\w]+)\s*\]\s*&#39;</span><span class="p">)</span>

    <span class="n">result</span> <span class="o">=</span> <span class="s2">&quot;&quot;&quot;</span><span class="si">%s</span><span class="s2">def basisspec_psi4_yo__</span><span class="si">%s</span><span class="s2">(mol, role):</span><span class="se">\n</span><span class="s2">&quot;&quot;&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">spaces</span><span class="p">,</span> <span class="n">cleanbas</span><span class="p">)</span>
    <span class="n">result</span> <span class="o">+=</span> <span class="s2">&quot;&quot;&quot;</span><span class="si">%s</span><span class="s2">    basstrings = </span><span class="si">{}</span><span class="se">\n</span><span class="s2">&quot;&quot;&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">spaces</span><span class="p">)</span>

    <span class="c1"># Start by looking for assign lines, and remove them</span>
    <span class="n">leftover_lines</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">line</span> <span class="ow">in</span> <span class="n">command_lines</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">symbol_re</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="n">line</span><span class="p">):</span>
            <span class="n">m</span> <span class="o">=</span> <span class="n">symbol_re</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="n">line</span><span class="p">)</span>
            <span class="n">result</span> <span class="o">+=</span> <span class="s2">&quot;&quot;&quot;</span><span class="si">%s</span><span class="s2">    mol.set_basis_by_symbol(&quot;</span><span class="si">%s</span><span class="s2">&quot;, &quot;</span><span class="si">%s</span><span class="s2">&quot;, role=role)</span><span class="se">\n</span><span class="s2">&quot;&quot;&quot;</span> <span class="o">%</span> \
                <span class="p">(</span><span class="n">spaces</span><span class="p">,</span> <span class="n">m</span><span class="o">.</span><span class="n">group</span><span class="p">(</span><span class="s1">&#39;symbol&#39;</span><span class="p">),</span> <span class="n">m</span><span class="o">.</span><span class="n">group</span><span class="p">(</span><span class="s1">&#39;basis&#39;</span><span class="p">))</span>

        <span class="k">elif</span> <span class="n">label_re</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="n">line</span><span class="p">):</span>
            <span class="n">m</span> <span class="o">=</span> <span class="n">label_re</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="n">line</span><span class="p">)</span>
            <span class="n">result</span> <span class="o">+=</span> <span class="s2">&quot;&quot;&quot;</span><span class="si">%s</span><span class="s2">    mol.set_basis_by_label(&quot;</span><span class="si">%s</span><span class="s2">&quot;, &quot;</span><span class="si">%s</span><span class="s2">&quot;, role=role)</span><span class="se">\n</span><span class="s2">&quot;&quot;&quot;</span> <span class="o">%</span> \
                <span class="p">(</span><span class="n">spaces</span><span class="p">,</span> <span class="n">m</span><span class="o">.</span><span class="n">group</span><span class="p">(</span><span class="s1">&#39;label&#39;</span><span class="p">),</span> <span class="n">m</span><span class="o">.</span><span class="n">group</span><span class="p">(</span><span class="s1">&#39;basis&#39;</span><span class="p">))</span>

        <span class="k">elif</span> <span class="n">all_re</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="n">line</span><span class="p">):</span>
            <span class="n">m</span> <span class="o">=</span> <span class="n">all_re</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="n">line</span><span class="p">)</span>
            <span class="n">result</span> <span class="o">+=</span> <span class="s2">&quot;&quot;&quot;</span><span class="si">%s</span><span class="s2">    mol.set_basis_all_atoms(&quot;</span><span class="si">%s</span><span class="s2">&quot;, role=role)</span><span class="se">\n</span><span class="s2">&quot;&quot;&quot;</span> <span class="o">%</span> \
                <span class="p">(</span><span class="n">spaces</span><span class="p">,</span> <span class="n">m</span><span class="o">.</span><span class="n">group</span><span class="p">(</span><span class="s1">&#39;basis&#39;</span><span class="p">))</span>

        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># Ignore blank lines and accumulate remainder</span>
            <span class="k">if</span> <span class="n">line</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">line</span><span class="o">.</span><span class="n">isspace</span><span class="p">():</span>
                <span class="n">leftover_lines</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">line</span><span class="o">.</span><span class="n">strip</span><span class="p">())</span>

    <span class="c1"># Now look for regular basis set definitions</span>
    <span class="n">basblock</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">filter</span><span class="p">(</span><span class="kc">None</span><span class="p">,</span> <span class="n">basislabel</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39;</span><span class="se">\n</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">leftover_lines</span><span class="p">))))</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">basblock</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">result</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39;</span><span class="se">\n</span><span class="s1">&#39;</span><span class="p">))</span> <span class="o">==</span> <span class="mi">3</span><span class="p">:</span>
            <span class="c1"># case with no [basname] markers where whole block is contents of gbs file</span>
            <span class="n">result</span> <span class="o">+=</span> <span class="s2">&quot;&quot;&quot;</span><span class="si">%s</span><span class="s2">    mol.set_basis_all_atoms(&quot;</span><span class="si">%s</span><span class="s2">&quot;, role=role)</span><span class="se">\n</span><span class="s2">&quot;&quot;&quot;</span> <span class="o">%</span> \
                <span class="p">(</span><span class="n">spaces</span><span class="p">,</span> <span class="n">name</span><span class="p">)</span>
            <span class="n">result</span> <span class="o">+=</span> <span class="s2">&quot;&quot;&quot;</span><span class="si">%s</span><span class="s2">    basstrings[&#39;</span><span class="si">%s</span><span class="s2">&#39;] = </span><span class="se">\&quot;\&quot;\&quot;\n</span><span class="si">%s</span><span class="se">\n\&quot;\&quot;\&quot;\n</span><span class="s2">&quot;&quot;&quot;</span> <span class="o">%</span> \
                <span class="p">(</span><span class="n">spaces</span><span class="p">,</span> <span class="n">basname</span><span class="p">(</span><span class="n">name</span><span class="p">),</span> <span class="n">basblock</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">message</span> <span class="o">=</span> <span class="p">(</span><span class="s2">&quot;Conflicting basis set specification: assign lines present but shells have no [basname] label.&quot;&quot;&quot;</span><span class="p">)</span>
            <span class="k">raise</span> <span class="n">TestComparisonError</span><span class="p">(</span><span class="n">message</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="c1"># case with specs separated by [basname] markers</span>
        <span class="k">for</span> <span class="n">idx</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">basblock</span><span class="p">),</span> <span class="mi">2</span><span class="p">):</span>
            <span class="n">result</span> <span class="o">+=</span> <span class="s2">&quot;&quot;&quot;</span><span class="si">%s</span><span class="s2">    basstrings[&#39;</span><span class="si">%s</span><span class="s2">&#39;] = </span><span class="se">\&quot;\&quot;\&quot;\n</span><span class="si">%s</span><span class="se">\n\&quot;\&quot;\&quot;\n</span><span class="s2">&quot;&quot;&quot;</span> <span class="o">%</span> \
                <span class="p">(</span><span class="n">spaces</span><span class="p">,</span> <span class="n">basname</span><span class="p">(</span><span class="n">basblock</span><span class="p">[</span><span class="n">idx</span><span class="p">]),</span> <span class="n">basblock</span><span class="p">[</span><span class="n">idx</span> <span class="o">+</span> <span class="mi">1</span><span class="p">])</span>

    <span class="n">result</span> <span class="o">+=</span> <span class="s2">&quot;&quot;&quot;</span><span class="si">%s</span><span class="s2">    return basstrings</span><span class="se">\n</span><span class="s2">&quot;&quot;&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">spaces</span><span class="p">)</span>
    <span class="n">result</span> <span class="o">+=</span> <span class="s2">&quot;&quot;&quot;</span><span class="si">{}</span><span class="s2">qcdb.libmintsbasisset.basishorde[&#39;</span><span class="si">{}</span><span class="s2">&#39;] = </span><span class="si">{}</span><span class="se">\n</span><span class="s2">&quot;&quot;&quot;</span> \
              <span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">spaces</span><span class="p">,</span> <span class="n">name</span><span class="o">.</span><span class="n">upper</span><span class="p">(),</span> <span class="s1">&#39;basisspec_psi4_yo__&#39;</span> <span class="o">+</span> <span class="n">cleanbas</span><span class="p">)</span>
    <span class="n">result</span> <span class="o">+=</span> <span class="s2">&quot;&quot;&quot;</span><span class="si">%s</span><span class="s2">core.set_global_option(</span><span class="se">\&quot;</span><span class="si">%s</span><span class="se">\&quot;</span><span class="s2">, </span><span class="se">\&quot;</span><span class="si">%s</span><span class="se">\&quot;</span><span class="s2">)&quot;&quot;&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">spaces</span><span class="p">,</span> <span class="n">basistype</span><span class="p">,</span> <span class="n">name</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">result</span>


<span class="k">def</span> <span class="nf">process_pcm_command</span><span class="p">(</span><span class="n">matchobj</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Function to process match of ``pcm name? { ... }``.&quot;&quot;&quot;</span>
    <span class="n">spacing</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="n">matchobj</span><span class="o">.</span><span class="n">group</span><span class="p">(</span><span class="mi">1</span><span class="p">))</span>  <span class="c1"># Ignore..</span>
    <span class="n">name</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="n">matchobj</span><span class="o">.</span><span class="n">group</span><span class="p">(</span><span class="mi">2</span><span class="p">))</span>  <span class="c1"># Ignore..</span>
    <span class="n">block</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="n">matchobj</span><span class="o">.</span><span class="n">group</span><span class="p">(</span><span class="mi">3</span><span class="p">))</span>  <span class="c1"># Get input to PCMSolver</span>
    <span class="n">suffix</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">getpid</span><span class="p">())</span> <span class="o">+</span> <span class="s1">&#39;.&#39;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">uuid</span><span class="o">.</span><span class="n">uuid4</span><span class="p">())[:</span><span class="mi">8</span><span class="p">]</span>
    <span class="n">pcmsolver_fname</span> <span class="o">=</span> <span class="s1">&#39;pcmsolver.&#39;</span> <span class="o">+</span> <span class="n">suffix</span> <span class="o">+</span> <span class="s1">&#39;.inp&#39;</span>
    <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">pcmsolver_fname</span><span class="p">,</span> <span class="s1">&#39;w&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">handle</span><span class="p">:</span>
        <span class="n">handle</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="n">block</span><span class="p">)</span>
    <span class="kn">import</span> <span class="nn">pcmsolver</span>
    <span class="n">parsed_pcm</span> <span class="o">=</span> <span class="n">pcmsolver</span><span class="o">.</span><span class="n">parse_pcm_input</span><span class="p">(</span><span class="n">pcmsolver_fname</span><span class="p">)</span><span class="o">.</span><span class="n">splitlines</span><span class="p">()</span>
    <span class="n">os</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="n">pcmsolver_fname</span><span class="p">)</span>
    <span class="n">pcmsolver_parsed_fname</span> <span class="o">=</span> <span class="s1">&#39;@pcmsolver.&#39;</span> <span class="o">+</span> <span class="n">suffix</span>
    <span class="n">write_input_for_pcm</span> <span class="o">=</span> <span class="s2">&quot;parsedFile = os.path.join(os.getcwd(), &#39;</span><span class="si">{}</span><span class="s2">&#39;)</span><span class="se">\n</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">pcmsolver_parsed_fname</span><span class="p">)</span>
    <span class="n">write_input_for_pcm</span> <span class="o">+=</span> <span class="s2">&quot;with open(parsedFile, &#39;w&#39;) as tmp:</span><span class="se">\n</span><span class="s2">&quot;</span>
    <span class="n">write_input_for_pcm</span> <span class="o">+=</span> <span class="s2">&quot;    tmp.write(&#39;</span><span class="se">\\</span><span class="s2">n&#39;.join(</span><span class="si">{}</span><span class="s2">))</span><span class="se">\n\n</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">parsed_pcm</span><span class="p">)</span>
    <span class="n">write_input_for_pcm</span> <span class="o">+=</span> <span class="s2">&quot;core.set_local_option(</span><span class="se">\&#39;</span><span class="s2">PCM</span><span class="se">\&#39;</span><span class="s2">, </span><span class="se">\&#39;</span><span class="s2">PCMSOLVER_PARSED_FNAME</span><span class="se">\&#39;</span><span class="s2">, </span><span class="se">\&#39;</span><span class="si">{}</span><span class="se">\&#39;</span><span class="s2">)</span><span class="se">\n\n</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
        <span class="n">pcmsolver_parsed_fname</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">write_input_for_pcm</span>


<span class="k">def</span> <span class="nf">process_external_command</span><span class="p">(</span><span class="n">matchobj</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Function to process match of ``external name? { ... }``.&quot;&quot;&quot;</span>
    <span class="n">spaces</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="n">matchobj</span><span class="o">.</span><span class="n">group</span><span class="p">(</span><span class="mi">1</span><span class="p">))</span>
    <span class="n">name</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="n">matchobj</span><span class="o">.</span><span class="n">group</span><span class="p">(</span><span class="mi">2</span><span class="p">))</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">name</span> <span class="ow">or</span> <span class="n">name</span><span class="o">.</span><span class="n">isspace</span><span class="p">():</span>
        <span class="n">name</span> <span class="o">=</span> <span class="s2">&quot;extern&quot;</span>
    <span class="n">block</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="n">matchobj</span><span class="o">.</span><span class="n">group</span><span class="p">(</span><span class="mi">3</span><span class="p">))</span>
    <span class="n">lines</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39;</span><span class="se">\n</span><span class="s1">&#39;</span><span class="p">,</span> <span class="n">block</span><span class="p">)</span>

    <span class="n">extern</span> <span class="o">=</span> <span class="s2">&quot;</span><span class="si">%s</span><span class="s2">qmmm = QMMM()</span><span class="se">\n</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">spaces</span><span class="p">)</span>

    <span class="n">NUMBER</span> <span class="o">=</span> <span class="s2">&quot;((?:[-+]?</span><span class="se">\\</span><span class="s2">d*</span><span class="se">\\</span><span class="s2">.</span><span class="se">\\</span><span class="s2">d+(?:[DdEe][-+]?</span><span class="se">\\</span><span class="s2">d+)?)|(?:[-+]?</span><span class="se">\\</span><span class="s2">d+</span><span class="se">\\</span><span class="s2">.</span><span class="se">\\</span><span class="s2">d*(?:[DdEe][-+]?</span><span class="se">\\</span><span class="s2">d+)?))&quot;</span>

    <span class="c1"># Comments are all removed by this point</span>
    <span class="c1"># 0. Remove blank lines</span>
    <span class="n">re_blank</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">compile</span><span class="p">(</span><span class="sa">r</span><span class="s1">&#39;^\s*$&#39;</span><span class="p">)</span>
    <span class="n">lines2</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">line</span> <span class="ow">in</span> <span class="n">lines</span><span class="p">:</span>
        <span class="n">mobj</span> <span class="o">=</span> <span class="n">re_blank</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="n">line</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">mobj</span><span class="p">:</span>
            <span class="k">pass</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">lines2</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">line</span><span class="p">)</span>
    <span class="n">lines</span> <span class="o">=</span> <span class="n">lines2</span>

    <span class="c1"># 1. Look for units [ang|bohr|au|a.u.] defaults to ang</span>
    <span class="n">re_units</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">compile</span><span class="p">(</span><span class="sa">r</span><span class="s1">&#39;^\s*units?[\s=]+((ang)|(angstrom)|(bohr)|(au)|(a\.u\.))$\s*&#39;</span><span class="p">,</span> <span class="n">re</span><span class="o">.</span><span class="n">IGNORECASE</span><span class="p">)</span>
    <span class="n">units</span> <span class="o">=</span> <span class="s1">&#39;ang&#39;</span>
    <span class="n">lines2</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">line</span> <span class="ow">in</span> <span class="n">lines</span><span class="p">:</span>
        <span class="n">mobj</span> <span class="o">=</span> <span class="n">re_units</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="n">line</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">mobj</span><span class="p">:</span>
            <span class="n">unit</span> <span class="o">=</span> <span class="n">mobj</span><span class="o">.</span><span class="n">group</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">unit</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;bohr&#39;</span><span class="p">,</span> <span class="s1">&#39;au&#39;</span><span class="p">,</span> <span class="s1">&#39;a.u.&#39;</span><span class="p">]:</span>
                <span class="n">units</span> <span class="o">=</span> <span class="s1">&#39;bohr&#39;</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">units</span> <span class="o">=</span> <span class="s1">&#39;ang&#39;</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">lines2</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">line</span><span class="p">)</span>
    <span class="n">lines</span> <span class="o">=</span> <span class="n">lines2</span>

    <span class="c1"># 2. Look for basis basisname, defaults to cc-pvdz</span>
    <span class="c1"># 3. Look for df_basis_scf basisname, defaults to cc-pvdz-jkfit</span>
    <span class="n">re_basis</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">compile</span><span class="p">(</span><span class="sa">r</span><span class="s1">&#39;\s*basis[\s=]+(\S+)\s*$&#39;</span><span class="p">,</span> <span class="n">re</span><span class="o">.</span><span class="n">IGNORECASE</span><span class="p">)</span>
    <span class="n">re_df_basis</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">compile</span><span class="p">(</span><span class="sa">r</span><span class="s1">&#39;\s*df_basis_scf[\s=]+(\S+)\s*$&#39;</span><span class="p">,</span> <span class="n">re</span><span class="o">.</span><span class="n">IGNORECASE</span><span class="p">)</span>
    <span class="n">basis</span> <span class="o">=</span> <span class="s1">&#39;cc-pvdz&#39;</span>
    <span class="n">df_basis_scf</span> <span class="o">=</span> <span class="s1">&#39;cc-pvdz-jkfit&#39;</span>
    <span class="n">lines2</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">line</span> <span class="ow">in</span> <span class="n">lines</span><span class="p">:</span>
        <span class="n">mobj</span> <span class="o">=</span> <span class="n">re_basis</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="n">line</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">mobj</span><span class="p">:</span>
            <span class="n">basis</span> <span class="o">=</span> <span class="n">mobj</span><span class="o">.</span><span class="n">group</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">mobj</span> <span class="o">=</span> <span class="n">re_df_basis</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="n">line</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">mobj</span><span class="p">:</span>
                <span class="n">df_basis_scf</span> <span class="o">=</span> <span class="n">mobj</span><span class="o">.</span><span class="n">group</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">lines2</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">line</span><span class="p">)</span>
    <span class="n">lines</span> <span class="o">=</span> <span class="n">lines2</span>

    <span class="c1"># 4. Look for charge lines Z x y z, convert according to unit convention</span>
    <span class="n">charge_re</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">compile</span><span class="p">(</span><span class="sa">r</span><span class="s1">&#39;^\s*&#39;</span> <span class="o">+</span> <span class="n">NUMBER</span> <span class="o">+</span> <span class="sa">r</span><span class="s1">&#39;\s+&#39;</span> <span class="o">+</span> <span class="n">NUMBER</span> <span class="o">+</span> <span class="sa">r</span><span class="s1">&#39;\s+&#39;</span> <span class="o">+</span> <span class="n">NUMBER</span> <span class="o">+</span> <span class="sa">r</span><span class="s1">&#39;\s+&#39;</span> <span class="o">+</span> <span class="n">NUMBER</span> <span class="o">+</span> <span class="sa">r</span><span class="s1">&#39;\s*$&#39;</span><span class="p">)</span>
    <span class="n">lines2</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">line</span> <span class="ow">in</span> <span class="n">lines</span><span class="p">:</span>
        <span class="n">mobj</span> <span class="o">=</span> <span class="n">charge_re</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="n">line</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">mobj</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">units</span> <span class="o">==</span> <span class="s1">&#39;ang&#39;</span><span class="p">:</span>
                <span class="n">extern</span> <span class="o">+=</span> <span class="s1">&#39;</span><span class="si">%s</span><span class="s1">qmmm.addChargeAngstrom(</span><span class="si">%s</span><span class="s1">,</span><span class="si">%s</span><span class="s1">,</span><span class="si">%s</span><span class="s1">,</span><span class="si">%s</span><span class="s1">)</span><span class="se">\n</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">spaces</span><span class="p">,</span> <span class="n">mobj</span><span class="o">.</span><span class="n">group</span><span class="p">(</span><span class="mi">1</span><span class="p">),</span> <span class="n">mobj</span><span class="o">.</span><span class="n">group</span><span class="p">(</span><span class="mi">2</span><span class="p">),</span>
                                                                       <span class="n">mobj</span><span class="o">.</span><span class="n">group</span><span class="p">(</span><span class="mi">3</span><span class="p">),</span> <span class="n">mobj</span><span class="o">.</span><span class="n">group</span><span class="p">(</span><span class="mi">4</span><span class="p">))</span>
            <span class="k">if</span> <span class="n">units</span> <span class="o">==</span> <span class="s1">&#39;bohr&#39;</span><span class="p">:</span>
                <span class="n">extern</span> <span class="o">+=</span> <span class="s1">&#39;</span><span class="si">%s</span><span class="s1">qmmm.addChargeBohr(</span><span class="si">%s</span><span class="s1">,</span><span class="si">%s</span><span class="s1">,</span><span class="si">%s</span><span class="s1">,</span><span class="si">%s</span><span class="s1">)</span><span class="se">\n</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">spaces</span><span class="p">,</span> <span class="n">mobj</span><span class="o">.</span><span class="n">group</span><span class="p">(</span><span class="mi">1</span><span class="p">),</span> <span class="n">mobj</span><span class="o">.</span><span class="n">group</span><span class="p">(</span><span class="mi">2</span><span class="p">),</span> <span class="n">mobj</span><span class="o">.</span><span class="n">group</span><span class="p">(</span><span class="mi">3</span><span class="p">),</span>
                                                                   <span class="n">mobj</span><span class="o">.</span><span class="n">group</span><span class="p">(</span><span class="mi">4</span><span class="p">))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">lines2</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">line</span><span class="p">)</span>
    <span class="n">lines</span> <span class="o">=</span> <span class="n">lines2</span>

    <span class="c1"># 5. Look for diffuse regions, which are XYZ molecules seperated by the usual -- lines</span>
    <span class="n">spacer_re</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">compile</span><span class="p">(</span><span class="sa">r</span><span class="s1">&#39;^\s*--\s*$&#39;</span><span class="p">)</span>
    <span class="n">frags</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">frags</span><span class="o">.</span><span class="n">append</span><span class="p">([])</span>
    <span class="k">for</span> <span class="n">line</span> <span class="ow">in</span> <span class="n">lines</span><span class="p">:</span>
        <span class="n">mobj</span> <span class="o">=</span> <span class="n">spacer_re</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="n">line</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">mobj</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">frags</span><span class="p">[</span><span class="nb">len</span><span class="p">(</span><span class="n">frags</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]):</span>
                <span class="n">frags</span><span class="o">.</span><span class="n">append</span><span class="p">([])</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">frags</span><span class="p">[</span><span class="nb">len</span><span class="p">(</span><span class="n">frags</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">line</span><span class="p">)</span>

    <span class="n">extern</span> <span class="o">+=</span> <span class="s1">&#39;</span><span class="si">%s</span><span class="s1">extern_mol_temp = core.get_active_molecule()</span><span class="se">\n</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">spaces</span><span class="p">)</span>

    <span class="n">mol_re</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">compile</span><span class="p">(</span><span class="sa">r</span><span class="s1">&#39;\s*\S+\s+&#39;</span> <span class="o">+</span> <span class="n">NUMBER</span> <span class="o">+</span> <span class="sa">r</span><span class="s1">&#39;\s+&#39;</span> <span class="o">+</span> <span class="n">NUMBER</span> <span class="o">+</span> <span class="sa">r</span><span class="s1">&#39;\s+&#39;</span> <span class="o">+</span> <span class="n">NUMBER</span> <span class="o">+</span> <span class="sa">r</span><span class="s1">&#39;\s*$&#39;</span><span class="p">)</span>
    <span class="n">lines</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">frag</span> <span class="ow">in</span> <span class="n">frags</span><span class="p">:</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="nb">len</span><span class="p">(</span><span class="n">frag</span><span class="p">):</span>
            <span class="k">continue</span>

        <span class="n">extern</span> <span class="o">+=</span> <span class="s1">&#39;</span><span class="si">%s</span><span class="s1">external_diffuse = geometry(&quot;&quot;&quot;</span><span class="se">\n</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">spaces</span><span class="p">)</span>
        <span class="n">extern</span> <span class="o">+=</span> <span class="s1">&#39;</span><span class="si">%s</span><span class="s1">0 1</span><span class="se">\n</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">spaces</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">line</span> <span class="ow">in</span> <span class="n">frag</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">mol_re</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="n">line</span><span class="p">):</span>
                <span class="n">lines</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">line</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">extern</span> <span class="o">+=</span> <span class="s1">&#39;</span><span class="si">%s%s</span><span class="se">\n</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">spaces</span><span class="p">,</span> <span class="n">line</span><span class="p">)</span>

        <span class="n">extern</span> <span class="o">+=</span> <span class="s1">&#39;</span><span class="si">%s</span><span class="s1">units </span><span class="si">%s</span><span class="se">\n</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">spaces</span><span class="p">,</span> <span class="n">units</span><span class="p">)</span>
        <span class="n">extern</span> <span class="o">+=</span> <span class="s1">&#39;</span><span class="si">%s</span><span class="s1">symmetry c1</span><span class="se">\n</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">spaces</span><span class="p">)</span>
        <span class="n">extern</span> <span class="o">+=</span> <span class="s1">&#39;</span><span class="si">%s</span><span class="s1">no_reorient</span><span class="se">\n</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">spaces</span><span class="p">)</span>
        <span class="n">extern</span> <span class="o">+=</span> <span class="s1">&#39;</span><span class="si">%s</span><span class="s1">no_com</span><span class="se">\n</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">spaces</span><span class="p">)</span>
        <span class="n">extern</span> <span class="o">+=</span> <span class="s1">&#39;</span><span class="si">%s</span><span class="s1">&quot;&quot;&quot;)</span><span class="se">\n</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">spaces</span><span class="p">)</span>
        <span class="n">extern</span> <span class="o">+=</span> <span class="s2">&quot;</span><span class="si">%s</span><span class="s2">diffuse = Diffuse(external_diffuse,&#39;</span><span class="si">%s</span><span class="s2">&#39;,&#39;</span><span class="si">%s</span><span class="s2">&#39;)</span><span class="se">\n</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">spaces</span><span class="p">,</span> <span class="n">basis</span><span class="p">,</span> <span class="n">df_basis_scf</span><span class="p">)</span>
        <span class="n">extern</span> <span class="o">+=</span> <span class="s1">&#39;</span><span class="si">%s</span><span class="s1">diffuse.fitScf()</span><span class="se">\n</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">spaces</span><span class="p">)</span>
        <span class="n">extern</span> <span class="o">+=</span> <span class="s1">&#39;</span><span class="si">%s</span><span class="s1">qmmm.addDiffuse(diffuse)</span><span class="se">\n</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">spaces</span><span class="p">)</span>
        <span class="n">extern</span> <span class="o">+=</span> <span class="s1">&#39;</span><span class="se">\n</span><span class="s1">&#39;</span>

    <span class="n">extern</span> <span class="o">+=</span> <span class="s1">&#39;</span><span class="si">%s</span><span class="s1">core.set_active_molecule(extern_mol_temp)</span><span class="se">\n</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">spaces</span><span class="p">)</span>

    <span class="c1"># 6. If there is anything left, the user messed up</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">lines</span><span class="p">):</span>
        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Input parsing for external </span><span class="si">{}</span><span class="s1">: Extra line(s) present:&#39;</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">line</span> <span class="ow">in</span> <span class="n">lines</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">TestComparisonError</span><span class="p">(</span><span class="n">line</span><span class="p">)</span>

    <span class="c1"># Return is actually an ExternalPotential, not a QMMM</span>
    <span class="n">extern</span> <span class="o">+=</span> <span class="s1">&#39;</span><span class="si">%s</span><span class="s1">qmmm.populateExtern()</span><span class="se">\n</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">spaces</span><span class="p">)</span>
    <span class="n">extern</span> <span class="o">+=</span> <span class="s1">&#39;</span><span class="si">%s%s</span><span class="s1"> = qmmm.extern</span><span class="se">\n</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">spaces</span><span class="p">,</span> <span class="n">name</span><span class="p">)</span>

    <span class="n">extern</span> <span class="o">+=</span> <span class="s1">&#39;</span><span class="si">%s</span><span class="s1">core.set_global_option_python(&quot;EXTERN&quot;, extern)</span><span class="se">\n</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">spaces</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">extern</span>


<span class="k">def</span> <span class="nf">check_parentheses_and_brackets</span><span class="p">(</span><span class="n">input_string</span><span class="p">,</span> <span class="n">exit_on_error</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Function to check that all parenthesis and brackets</span>
<span class="sd">    in *input_string* are paired. On that condition, *exit_on_error* =1,</span>
<span class="sd">    otherwise 0.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># This returns 1 if the string&#39;s all matched up, 0 otherwise</span>
    <span class="kn">import</span> <span class="nn">collections</span>

    <span class="c1"># create left to right parenthesis mappings</span>
    <span class="n">lrmap</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;(&quot;</span><span class="p">:</span> <span class="s2">&quot;)&quot;</span><span class="p">,</span> <span class="s2">&quot;[&quot;</span><span class="p">:</span> <span class="s2">&quot;]&quot;</span><span class="p">,</span> <span class="s2">&quot;{&quot;</span><span class="p">:</span> <span class="s2">&quot;}&quot;</span><span class="p">}</span>

    <span class="c1"># derive sets of left and right parentheses</span>
    <span class="n">lparens</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">lrmap</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span>
    <span class="n">rparens</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">lrmap</span><span class="o">.</span><span class="n">values</span><span class="p">())</span>

    <span class="n">parenstack</span> <span class="o">=</span> <span class="n">collections</span><span class="o">.</span><span class="n">deque</span><span class="p">()</span>
    <span class="n">all_matched</span> <span class="o">=</span> <span class="mi">1</span>
    <span class="k">for</span> <span class="n">ch</span> <span class="ow">in</span> <span class="n">input_string</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">ch</span> <span class="ow">in</span> <span class="n">lparens</span><span class="p">:</span>
            <span class="n">parenstack</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">ch</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">ch</span> <span class="ow">in</span> <span class="n">rparens</span><span class="p">:</span>
            <span class="n">opench</span> <span class="o">=</span> <span class="s2">&quot;&quot;</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">opench</span> <span class="o">=</span> <span class="n">parenstack</span><span class="o">.</span><span class="n">pop</span><span class="p">()</span>
            <span class="k">except</span> <span class="ne">IndexError</span><span class="p">:</span>
                <span class="c1"># Run out of opening parens</span>
                <span class="n">all_matched</span> <span class="o">=</span> <span class="mi">0</span>
                <span class="k">if</span> <span class="n">exit_on_error</span><span class="p">:</span>
                    <span class="n">message</span> <span class="o">=</span> <span class="p">(</span><span class="s2">&quot;Input error: extra </span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">ch</span><span class="p">))</span>
                    <span class="k">raise</span> <span class="n">TestComparisonError</span><span class="p">(</span><span class="n">message</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">lrmap</span><span class="p">[</span><span class="n">opench</span><span class="p">]</span> <span class="o">!=</span> <span class="n">ch</span><span class="p">:</span>
                <span class="c1"># wrong type of parenthesis popped from stack</span>
                <span class="n">all_matched</span> <span class="o">=</span> <span class="mi">0</span>
                <span class="k">if</span> <span class="n">exit_on_error</span><span class="p">:</span>
                    <span class="n">message</span> <span class="o">=</span> <span class="p">(</span><span class="s2">&quot;Input error: </span><span class="si">%s</span><span class="s2"> closed with a </span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">opench</span><span class="p">,</span> <span class="n">ch</span><span class="p">))</span>
                    <span class="k">raise</span> <span class="n">TestComparisonError</span><span class="p">(</span><span class="n">message</span><span class="p">)</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">parenstack</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">all_matched</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">if</span> <span class="n">exit_on_error</span><span class="p">:</span>
            <span class="n">message</span> <span class="o">=</span> <span class="p">(</span><span class="s2">&quot;Input error: Unmatched </span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">parenstack</span><span class="o">.</span><span class="n">pop</span><span class="p">()))</span>
            <span class="k">raise</span> <span class="n">TestComparisonError</span><span class="p">(</span><span class="n">message</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">all_matched</span>


<span class="k">def</span> <span class="nf">parse_multiline_array</span><span class="p">(</span><span class="n">input_list</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Function to squash multiline arrays into a single line</span>
<span class="sd">    until all parentheses and brackets are fully paired.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">line</span> <span class="o">=</span> <span class="n">input_list</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
    <span class="c1"># Keep adding lines to the current one, until all parens match up</span>
    <span class="k">while</span> <span class="ow">not</span> <span class="n">check_parentheses_and_brackets</span><span class="p">(</span><span class="n">line</span><span class="p">,</span> <span class="mi">0</span><span class="p">):</span>
        <span class="n">thisline</span> <span class="o">=</span> <span class="n">input_list</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">strip</span><span class="p">()</span>
        <span class="n">line</span> <span class="o">+=</span> <span class="n">thisline</span>
    <span class="k">return</span> <span class="s2">&quot;</span><span class="si">%s</span><span class="se">\n</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">line</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">process_multiline_arrays</span><span class="p">(</span><span class="n">inputfile</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Function to find array inputs that are spread across multiple</span>
<span class="sd">    lines and squash them into a single line.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># This function takes multiline array inputs, and puts them on a single line</span>
    <span class="c1"># Start by converting the input to a list, splitting at newlines</span>
    <span class="n">input_list</span> <span class="o">=</span> <span class="n">inputfile</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">)</span>
    <span class="n">set_re</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">compile</span><span class="p">(</span><span class="sa">r</span><span class="s1">&#39;^(\s*?)set\s+(?:([-,\w]+)\s+)?(\w+)[\s=]+\[.*&#39;</span><span class="p">,</span> <span class="n">re</span><span class="o">.</span><span class="n">IGNORECASE</span><span class="p">)</span>
    <span class="n">newinput</span> <span class="o">=</span> <span class="s2">&quot;&quot;</span>
    <span class="k">while</span> <span class="nb">len</span><span class="p">(</span><span class="n">input_list</span><span class="p">):</span>
        <span class="n">line</span> <span class="o">=</span> <span class="n">input_list</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">set_re</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="n">line</span><span class="p">):</span>
            <span class="c1"># We&#39;ve found the start of a set matrix [ .... line - hand it off for more checks</span>
            <span class="n">newinput</span> <span class="o">+=</span> <span class="n">parse_multiline_array</span><span class="p">(</span><span class="n">input_list</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># Nothing to do - just add the line to the string</span>
            <span class="n">newinput</span> <span class="o">+=</span> <span class="s2">&quot;</span><span class="si">%s</span><span class="se">\n</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">input_list</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="mi">0</span><span class="p">))</span>
    <span class="k">return</span> <span class="n">newinput</span>


<div class="viewcode-block" id="process_input"><a class="viewcode-back" href="../../../api/psi4.driver.process_input.html#psi4.driver.process_input">[docs]</a><span class="k">def</span> <span class="nf">process_input</span><span class="p">(</span><span class="n">raw_input</span><span class="p">,</span> <span class="n">print_level</span><span class="o">=</span><span class="mi">1</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Function to preprocess *raw input*, the text of the input file, then</span>
<span class="sd">    parse it, validate it for format, and convert it into legitimate Python.</span>
<span class="sd">    *raw_input* is printed to the output file unless *print_level* =0. Does</span>
<span class="sd">    a series of regular expression filters, where the matching portion of the</span>
<span class="sd">    input is replaced by the output of the corresponding function (in this</span>
<span class="sd">    module) call. Returns a string concatenating module import lines, a copy</span>
<span class="sd">    of the user&#39;s .psi4rc files, a setting of the scratch directory, a dummy</span>
<span class="sd">    molecule, and the processed *raw_input*.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Check if the infile is actually an outfile (yeah we did)</span>
    <span class="n">psi4_id</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">compile</span><span class="p">(</span><span class="sa">r</span><span class="s1">&#39;Psi4: An Open-Source Ab Initio Electronic Structure Package&#39;</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">re</span><span class="o">.</span><span class="n">search</span><span class="p">(</span><span class="n">psi4_id</span><span class="p">,</span> <span class="n">raw_input</span><span class="p">):</span>
        <span class="n">input_lines</span> <span class="o">=</span> <span class="n">raw_input</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="n">input_re</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">compile</span><span class="p">(</span><span class="sa">r</span><span class="s1">&#39;^\s*?\=\=&gt; Input File &lt;\=\=&#39;</span><span class="p">)</span>
        <span class="n">input_start</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>
        <span class="k">for</span> <span class="n">line_count</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">input_lines</span><span class="p">)):</span>
            <span class="n">line</span> <span class="o">=</span> <span class="n">input_lines</span><span class="p">[</span><span class="n">line_count</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">re</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="n">input_re</span><span class="p">,</span> <span class="n">line</span><span class="p">):</span>
                <span class="n">input_start</span> <span class="o">=</span> <span class="n">line_count</span> <span class="o">+</span> <span class="mi">3</span>
                <span class="k">break</span>

        <span class="n">stop_re</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">compile</span><span class="p">(</span><span class="sa">r</span><span class="s1">&#39;^-</span><span class="si">{74}</span><span class="s1">&#39;</span><span class="p">)</span>
        <span class="n">input_stop</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>
        <span class="k">for</span> <span class="n">line_count</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">input_start</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">input_lines</span><span class="p">)):</span>
            <span class="n">line</span> <span class="o">=</span> <span class="n">input_lines</span><span class="p">[</span><span class="n">line_count</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">re</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="n">stop_re</span><span class="p">,</span> <span class="n">line</span><span class="p">):</span>
                <span class="n">input_stop</span> <span class="o">=</span> <span class="n">line_count</span>
                <span class="k">break</span>

        <span class="k">if</span> <span class="n">input_start</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span> <span class="ow">or</span> <span class="n">input_stop</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">:</span>
            <span class="n">message</span> <span class="o">=</span> <span class="p">(</span><span class="s1">&#39;Cannot extract infile from outfile.&#39;</span><span class="p">)</span>
            <span class="k">raise</span> <span class="n">TestComparisonError</span><span class="p">(</span><span class="n">message</span><span class="p">)</span>

        <span class="n">raw_input</span> <span class="o">=</span> <span class="s1">&#39;</span><span class="se">\n</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">input_lines</span><span class="p">[</span><span class="n">input_start</span><span class="p">:</span><span class="n">input_stop</span><span class="p">])</span>
        <span class="n">raw_input</span> <span class="o">+=</span> <span class="s1">&#39;</span><span class="se">\n</span><span class="s1">&#39;</span>

    <span class="c1"># Echo the infile on the outfile</span>
    <span class="k">if</span> <span class="n">print_level</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">core</span><span class="o">.</span><span class="n">print_out</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">  ==&gt; Input File &lt;==</span><span class="se">\n\n</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="n">core</span><span class="o">.</span><span class="n">print_out</span><span class="p">(</span><span class="s2">&quot;--------------------------------------------------------------------------</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="n">core</span><span class="o">.</span><span class="n">print_out</span><span class="p">(</span><span class="n">raw_input</span><span class="p">)</span>
        <span class="n">core</span><span class="o">.</span><span class="n">print_out</span><span class="p">(</span><span class="s2">&quot;--------------------------------------------------------------------------</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="n">core</span><span class="o">.</span><span class="n">flush_outfile</span><span class="p">()</span>

    <span class="c1">#NOTE: If adding mulitline data to the preprocessor, use ONLY the following syntax:</span>
    <span class="c1">#   function [objname] { ... }</span>
    <span class="c1">#   which has the regex capture group:</span>
    <span class="c1">#</span>
    <span class="c1">#   r&#39;^(\s*?)FUNCTION\s*(\w*?)\s*\{(.*?)\}&#39;, re.MULTILINE | re.DOTALL | re.IGNORECASE</span>
    <span class="c1">#</span>
    <span class="c1">#   your function is in capture group #1</span>
    <span class="c1">#   your objname is in capture group #2</span>
    <span class="c1">#   your data is in capture group #3</span>

    <span class="c1"># Sections that are truly to be taken literally (spaces included)</span>
    <span class="c1">#   Must be stored then subbed in the end to escape the normal processing</span>

    <span class="c1"># Process &quot;cfour name? { ... }&quot;</span>
    <span class="n">cfour</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">compile</span><span class="p">(</span><span class="sa">r</span><span class="s1">&#39;^(\s*?)cfour[=\s]*(\w*?)\s*\{(.*?)\}&#39;</span><span class="p">,</span> <span class="n">re</span><span class="o">.</span><span class="n">MULTILINE</span> <span class="o">|</span> <span class="n">re</span><span class="o">.</span><span class="n">DOTALL</span> <span class="o">|</span> <span class="n">re</span><span class="o">.</span><span class="n">IGNORECASE</span><span class="p">)</span>
    <span class="n">temp</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">sub</span><span class="p">(</span><span class="n">cfour</span><span class="p">,</span> <span class="n">process_cfour_command</span><span class="p">,</span> <span class="n">raw_input</span><span class="p">)</span>

    <span class="c1"># Return from handling literal blocks to normal processing</span>

    <span class="c1"># Nuke all comments</span>
    <span class="n">comment</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">compile</span><span class="p">(</span><span class="sa">r</span><span class="s1">&#39;(^|[^</span><span class="se">\\</span><span class="s1">])#.*&#39;</span><span class="p">)</span>
    <span class="n">temp</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">sub</span><span class="p">(</span><span class="n">comment</span><span class="p">,</span> <span class="s1">&#39;&#39;</span><span class="p">,</span> <span class="n">temp</span><span class="p">)</span>
    <span class="c1"># Now, nuke any escapes from comment lines</span>
    <span class="n">comment</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">compile</span><span class="p">(</span><span class="sa">r</span><span class="s1">&#39;</span><span class="se">\\</span><span class="s1">#&#39;</span><span class="p">)</span>
    <span class="n">temp</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">sub</span><span class="p">(</span><span class="n">comment</span><span class="p">,</span> <span class="s1">&#39;#&#39;</span><span class="p">,</span> <span class="n">temp</span><span class="p">)</span>

    <span class="c1"># Check the brackets and parentheses match up, as long as this is not a pickle input file</span>
    <span class="c1">#if not re.search(r&#39;pickle_kw&#39;, temp):</span>
    <span class="c1">#    check_parentheses_and_brackets(temp, 1)</span>

    <span class="c1"># First, remove everything from lines containing only spaces</span>
    <span class="n">blankline</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">compile</span><span class="p">(</span><span class="sa">r</span><span class="s1">&#39;^\s*$&#39;</span><span class="p">)</span>
    <span class="n">temp</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">sub</span><span class="p">(</span><span class="n">blankline</span><span class="p">,</span> <span class="s1">&#39;&#39;</span><span class="p">,</span> <span class="n">temp</span><span class="p">,</span> <span class="n">re</span><span class="o">.</span><span class="n">MULTILINE</span><span class="p">)</span>

    <span class="c1"># Look for things like</span>
    <span class="c1"># set matrix [</span>
    <span class="c1">#              [ 1, 2 ],</span>
    <span class="c1">#              [ 3, 4 ]</span>
    <span class="c1">#            ]</span>
    <span class="c1"># and put them on a single line</span>
    <span class="n">temp</span> <span class="o">=</span> <span class="n">process_multiline_arrays</span><span class="p">(</span><span class="n">temp</span><span class="p">)</span>

    <span class="c1"># Process all &quot;set name? { ... }&quot;</span>
    <span class="n">set_commands</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">compile</span><span class="p">(</span><span class="sa">r</span><span class="s1">&#39;^(\s*?)set\s*([-,\w]*?)[\s=]*\{(.*?)\}&#39;</span><span class="p">,</span> <span class="n">re</span><span class="o">.</span><span class="n">MULTILINE</span> <span class="o">|</span> <span class="n">re</span><span class="o">.</span><span class="n">DOTALL</span> <span class="o">|</span> <span class="n">re</span><span class="o">.</span><span class="n">IGNORECASE</span><span class="p">)</span>
    <span class="n">temp</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">sub</span><span class="p">(</span><span class="n">set_commands</span><span class="p">,</span> <span class="n">process_set_commands</span><span class="p">,</span> <span class="n">temp</span><span class="p">)</span>

    <span class="c1"># Process all individual &quot;set (module_list) key  {[value_list] or $value or value}&quot;</span>
    <span class="c1"># N.B. We have to be careful here, because \s matches \n, leading to potential problems</span>
    <span class="c1"># with undesired multiline matches.  Better the double-negative [^\S\n] instead, which</span>
    <span class="c1"># will match any space, tab, etc., except a newline</span>
    <span class="n">set_command</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">compile</span><span class="p">(</span>
        <span class="sa">r</span><span class="s1">&#39;^(\s*?)set\s+(?:([-,\w]+)[^\S\n]+)?(\w+)(?:[^\S\n]|=)+((\[.*\])|(\$?[-+,*()\.\w]+))\s*$&#39;</span><span class="p">,</span>
        <span class="n">re</span><span class="o">.</span><span class="n">MULTILINE</span> <span class="o">|</span> <span class="n">re</span><span class="o">.</span><span class="n">IGNORECASE</span><span class="p">)</span>
    <span class="n">temp</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">sub</span><span class="p">(</span><span class="n">set_command</span><span class="p">,</span> <span class="n">process_set_command</span><span class="p">,</span> <span class="n">temp</span><span class="p">)</span>

    <span class="c1"># Process &quot;molecule name? { ... }&quot;</span>
    <span class="n">molecule</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">compile</span><span class="p">(</span><span class="sa">r</span><span class="s1">&#39;^(\s*?)molecule[=\s]*(\S*?)\s*\{(.*?)\}&#39;</span><span class="p">,</span> <span class="n">re</span><span class="o">.</span><span class="n">MULTILINE</span> <span class="o">|</span> <span class="n">re</span><span class="o">.</span><span class="n">DOTALL</span> <span class="o">|</span> <span class="n">re</span><span class="o">.</span><span class="n">IGNORECASE</span><span class="p">)</span>
    <span class="n">temp</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">sub</span><span class="p">(</span><span class="n">molecule</span><span class="p">,</span> <span class="n">process_molecule_command</span><span class="p">,</span> <span class="n">temp</span><span class="p">)</span>

    <span class="c1"># Process &quot;external name? { ... }&quot;</span>
    <span class="n">external</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">compile</span><span class="p">(</span><span class="sa">r</span><span class="s1">&#39;^(\s*?)external[=\s]*(\w*?)\s*\{(.*?)\}&#39;</span><span class="p">,</span> <span class="n">re</span><span class="o">.</span><span class="n">MULTILINE</span> <span class="o">|</span> <span class="n">re</span><span class="o">.</span><span class="n">DOTALL</span> <span class="o">|</span> <span class="n">re</span><span class="o">.</span><span class="n">IGNORECASE</span><span class="p">)</span>
    <span class="n">temp</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">sub</span><span class="p">(</span><span class="n">external</span><span class="p">,</span> <span class="n">process_external_command</span><span class="p">,</span> <span class="n">temp</span><span class="p">)</span>

    <span class="c1"># Process &quot;pcm name? { ... }&quot;</span>
    <span class="n">pcm</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">compile</span><span class="p">(</span><span class="sa">r</span><span class="s1">&#39;^(\s*?)pcm[=\s]*(\w*?)\s*\{(.*?)^\}&#39;</span><span class="p">,</span> <span class="n">re</span><span class="o">.</span><span class="n">MULTILINE</span> <span class="o">|</span> <span class="n">re</span><span class="o">.</span><span class="n">DOTALL</span> <span class="o">|</span> <span class="n">re</span><span class="o">.</span><span class="n">IGNORECASE</span><span class="p">)</span>
    <span class="n">temp</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">sub</span><span class="p">(</span><span class="n">pcm</span><span class="p">,</span> <span class="n">process_pcm_command</span><span class="p">,</span> <span class="n">temp</span><span class="p">)</span>

    <span class="c1"># Then remove repeated newlines</span>
    <span class="n">multiplenewlines</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">compile</span><span class="p">(</span><span class="sa">r</span><span class="s1">&#39;\n+&#39;</span><span class="p">)</span>
    <span class="n">temp</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">sub</span><span class="p">(</span><span class="n">multiplenewlines</span><span class="p">,</span> <span class="s1">&#39;</span><span class="se">\n</span><span class="s1">&#39;</span><span class="p">,</span> <span class="n">temp</span><span class="p">)</span>

    <span class="c1"># Process &quot; extract&quot;</span>
    <span class="n">extract</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">compile</span><span class="p">(</span><span class="sa">r</span><span class="s1">&#39;(\s*?)(\w+)\s*=\s*\w+\.extract_subsets.*&#39;</span><span class="p">,</span> <span class="n">re</span><span class="o">.</span><span class="n">IGNORECASE</span><span class="p">)</span>
    <span class="n">temp</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">sub</span><span class="p">(</span><span class="n">extract</span><span class="p">,</span> <span class="n">process_extract_command</span><span class="p">,</span> <span class="n">temp</span><span class="p">)</span>

    <span class="c1"># Process &quot;print&quot; and transform it to &quot;core.print_out()&quot;</span>
    <span class="c1">#print_string = re.compile(r&#39;(\s*?)print\s+(.*)&#39;, re.IGNORECASE)</span>
    <span class="c1">#temp = re.sub(print_string, process_print_command, temp)</span>

    <span class="c1"># Process &quot;memory ... &quot;</span>
    <span class="n">memory_string</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">compile</span><span class="p">(</span><span class="sa">r</span><span class="s1">&#39;(\s*?)memory\s+(\d*\.?\d+)\s*([KMGTPBE]i?B)&#39;</span><span class="p">,</span> <span class="n">re</span><span class="o">.</span><span class="n">IGNORECASE</span><span class="p">)</span>
    <span class="n">temp</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">sub</span><span class="p">(</span><span class="n">memory_string</span><span class="p">,</span> <span class="n">process_memory_command</span><span class="p">,</span> <span class="n">temp</span><span class="p">)</span>

    <span class="c1"># Process &quot;basis name? { ... }&quot;</span>
    <span class="n">basis_block</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">compile</span><span class="p">(</span>
        <span class="sa">r</span><span class="s1">&#39;^(\s*?)(basis|df_basis_scf|df_basis_mp2|df_basis_cc|df_basis_sapt|df_basis_sad|df_basis_dct)[=\s]*(\w*?)\s*\{(.*?)\}&#39;</span><span class="p">,</span>
        <span class="n">re</span><span class="o">.</span><span class="n">MULTILINE</span> <span class="o">|</span> <span class="n">re</span><span class="o">.</span><span class="n">DOTALL</span> <span class="o">|</span> <span class="n">re</span><span class="o">.</span><span class="n">IGNORECASE</span><span class="p">)</span>
    <span class="n">temp</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">sub</span><span class="p">(</span><span class="n">basis_block</span><span class="p">,</span> <span class="n">process_basis_block</span><span class="p">,</span> <span class="n">temp</span><span class="p">)</span>

    <span class="c1"># Process literal blocks by substituting back in</span>
    <span class="n">lit_block</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">compile</span><span class="p">(</span><span class="sa">r</span><span class="s1">&#39;literals_psi4_yo-(\w</span><span class="si">{8}</span><span class="s1">)&#39;</span><span class="p">)</span>
    <span class="n">temp</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">sub</span><span class="p">(</span><span class="n">lit_block</span><span class="p">,</span> <span class="n">process_literal_blocks</span><span class="p">,</span> <span class="n">temp</span><span class="p">)</span>

    <span class="n">future_imports</span> <span class="o">=</span> <span class="p">[]</span>

    <span class="k">def</span> <span class="nf">future_replace</span><span class="p">(</span><span class="n">m</span><span class="p">):</span>
        <span class="n">future_imports</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">m</span><span class="o">.</span><span class="n">group</span><span class="p">(</span><span class="mi">0</span><span class="p">))</span>
        <span class="k">return</span> <span class="s1">&#39;&#39;</span>

    <span class="n">future_string</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">compile</span><span class="p">(</span><span class="s1">&#39;^from __future__ import .*$&#39;</span><span class="p">,</span> <span class="n">flags</span><span class="o">=</span><span class="n">re</span><span class="o">.</span><span class="n">MULTILINE</span><span class="p">)</span>
    <span class="n">temp</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">sub</span><span class="p">(</span><span class="n">future_string</span><span class="p">,</span> <span class="n">future_replace</span><span class="p">,</span> <span class="n">temp</span><span class="p">)</span>

    <span class="c1"># imports</span>
    <span class="n">imports</span> <span class="o">=</span> <span class="s1">&#39;</span><span class="se">\n</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">future_imports</span><span class="p">)</span> <span class="o">+</span> <span class="s1">&#39;</span><span class="se">\n</span><span class="s1">&#39;</span>
    <span class="n">imports</span> <span class="o">+=</span> <span class="s1">&#39;import psi4</span><span class="se">\n</span><span class="s1">&#39;</span>
    <span class="n">imports</span> <span class="o">+=</span> <span class="s1">&#39;from psi4 import *</span><span class="se">\n</span><span class="s1">&#39;</span>
    <span class="n">imports</span> <span class="o">+=</span> <span class="s1">&#39;from psi4.core import *</span><span class="se">\n</span><span class="s1">&#39;</span>
    <span class="n">imports</span> <span class="o">+=</span> <span class="s1">&#39;from psi4.driver.diatomic import anharmonicity</span><span class="se">\n</span><span class="s1">&#39;</span>
    <span class="n">imports</span> <span class="o">+=</span> <span class="s1">&#39;from psi4.driver.gaussian_n import *</span><span class="se">\n</span><span class="s1">&#39;</span>
    <span class="n">imports</span> <span class="o">+=</span> <span class="s1">&#39;from psi4.driver.frac import ip_fitting, frac_traverse</span><span class="se">\n</span><span class="s1">&#39;</span>
    <span class="n">imports</span> <span class="o">+=</span> <span class="s1">&#39;from psi4.driver.aliases import *</span><span class="se">\n</span><span class="s1">&#39;</span>
    <span class="n">imports</span> <span class="o">+=</span> <span class="s1">&#39;from psi4.driver.driver_cbs import *</span><span class="se">\n</span><span class="s1">&#39;</span>
    <span class="n">imports</span> <span class="o">+=</span> <span class="s1">&#39;from psi4.driver.wrapper_database import database, db, DB_RGT, DB_RXN</span><span class="se">\n</span><span class="s1">&#39;</span>
    <span class="n">imports</span> <span class="o">+=</span> <span class="s1">&#39;from psi4.driver.wrapper_autofrag import auto_fragments</span><span class="se">\n</span><span class="s1">&#39;</span>
    <span class="n">imports</span> <span class="o">+=</span> <span class="s1">&#39;psi4_io = core.IOManager.shared_object()</span><span class="se">\n</span><span class="s1">&#39;</span>

    <span class="c1"># psirc (a baby PSIthon script that might live in ~/.psi4rc)</span>
    <span class="n">psirc_file</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">expanduser</span><span class="p">(</span><span class="s1">&#39;~&#39;</span><span class="p">)</span> <span class="o">+</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">sep</span> <span class="o">+</span> <span class="s1">&#39;.psi4rc&#39;</span>
    <span class="k">if</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">isfile</span><span class="p">(</span><span class="n">psirc_file</span><span class="p">):</span>
        <span class="n">fh</span> <span class="o">=</span> <span class="nb">open</span><span class="p">(</span><span class="n">psirc_file</span><span class="p">)</span>
        <span class="n">psirc</span> <span class="o">=</span> <span class="n">fh</span><span class="o">.</span><span class="n">read</span><span class="p">()</span>
        <span class="n">fh</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
        <span class="n">psirc</span> <span class="o">=</span> <span class="n">psirc</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s1">&#39;psi4.IOManager&#39;</span><span class="p">,</span> <span class="s1">&#39;psi4.core.IOManager&#39;</span><span class="p">)</span>
        <span class="n">psirc</span> <span class="o">+=</span> <span class="s2">&quot;</span><span class="se">\n</span><span class="s2">psi4.core.print_out(&#39;Warning: As of v1.5, the ~/.psi4rc file will no longer be read into Psi4 input.</span><span class="se">\\</span><span class="s2">n&#39;)</span><span class="se">\n</span><span class="s2">&quot;</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">psirc</span> <span class="o">=</span> <span class="s1">&#39;&#39;</span>

    <span class="n">blank_mol</span> <span class="o">=</span> <span class="s1">&#39;geometry(&quot;&quot;&quot;</span><span class="se">\n</span><span class="s1">&#39;</span>
    <span class="n">blank_mol</span> <span class="o">+=</span> <span class="s1">&#39;0 1</span><span class="se">\n</span><span class="s1">H 0 0 0</span><span class="se">\n</span><span class="s1">H 0.74 0 0</span><span class="se">\n</span><span class="s1">&#39;</span>
    <span class="n">blank_mol</span> <span class="o">+=</span> <span class="s1">&#39;&quot;&quot;&quot;,&quot;blank_molecule_psi4_yo&quot;)</span><span class="se">\n</span><span class="s1">&#39;</span>

    <span class="n">temp</span> <span class="o">=</span> <span class="n">imports</span> <span class="o">+</span> <span class="n">psirc</span> <span class="o">+</span> <span class="n">blank_mol</span> <span class="o">+</span> <span class="n">temp</span>

    <span class="c1"># Move up the psi4.core namespace</span>
    <span class="k">for</span> <span class="n">func</span> <span class="ow">in</span> <span class="nb">dir</span><span class="p">(</span><span class="n">core</span><span class="p">):</span>
        <span class="n">temp</span> <span class="o">=</span> <span class="n">temp</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s2">&quot;psi4.&quot;</span> <span class="o">+</span> <span class="n">func</span><span class="p">,</span> <span class="s2">&quot;psi4.core.&quot;</span> <span class="o">+</span> <span class="n">func</span><span class="p">)</span>

    <span class="c1"># Move pseudonamespace for physconst into proper namespace</span>
    <span class="kn">from</span> <span class="nn">psi4.driver</span> <span class="kn">import</span> <span class="n">constants</span>
    <span class="k">for</span> <span class="n">pc</span> <span class="ow">in</span> <span class="nb">dir</span><span class="p">(</span><span class="n">constants</span><span class="p">):</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">pc</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="s1">&#39;__&#39;</span><span class="p">):</span>
            <span class="n">temp</span> <span class="o">=</span> <span class="n">temp</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s1">&#39;psi_&#39;</span> <span class="o">+</span> <span class="n">pc</span><span class="p">,</span> <span class="s1">&#39;psi4.constants.&#39;</span> <span class="o">+</span> <span class="n">pc</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">temp</span></div>


<span class="k">if</span> <span class="vm">__name__</span> <span class="o">==</span> <span class="s2">&quot;__main__&quot;</span><span class="p">:</span>
    <span class="n">result</span> <span class="o">=</span> <span class="n">process_input</span><span class="p">(</span><span class="s2">&quot;&quot;&quot;</span>
<span class="s2">molecule h2 {</span>
<span class="s2">H</span>
<span class="s2">H 1 R</span>

<span class="s2">R = .9</span>
<span class="s2">}</span>

<span class="s2">set basis 6-31G**</span>

<span class="s2">&quot;&quot;&quot;</span><span class="p">)</span>

    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Result</span><span class="se">\n</span><span class="s2">==========================&quot;</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="n">result</span><span class="p">)</span>
</pre></div>

            <div class="clearer"></div>
          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
        <p class="logo"><a href="../../../index.html" title="index">
          <img class="logo" src="../../../_static/psi4square.png" alt="Logo"/>
        </a></p><!-- 
#
# @BEGIN LICENSE
#
# Psi4: an open-source quantum chemistry software package
#
# Copyright (c) 2007-2017 The Psi4 Developers.
#
# The copyrights for code used from other parties are included in
# the corresponding files.
#
# This file is part of Psi4.
#
# Psi4 is free software; you can redistribute it and/or modify
# it under the terms of the GNU Lesser General Public License as published by
# the Free Software Foundation, version 3.
#
# Psi4 is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU Lesser General Public License for more details.
#
# You should have received a copy of the GNU Lesser General Public License along
# with Psi4; if not, write to the Free Software Foundation, Inc.,
# 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
#
# @END LICENSE
# -->


<div id="searchbox" style="display: none" role="search">
  <!--<h3>Quick search</h3>-->
    <form class="search" action="../../../search.html" method="get">
      <!--<div><input type="text" name="q" placeholder="search docs" /></div>-->
      <div><input type="text" name="q" placeholder="&#xF002;" style="font-family:FontAwesome, Ariel" /></div>
      <!--<div><input type="submit" value="Go" /></div>-->
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
    
    
        <div class="sidebar-toggle-group no-js">
            
            <button class="sidebar-toggle" id="sidebar-hide" title="Hide the sidebar menu">
                 «
                <span class="show-for-small">hide menu</span>
                
            </button>
            <button class="sidebar-toggle" id="sidebar-show" title="Show the sidebar menu">
                
                <span class="show-for-small">menu</span>
                <span class="hide-for-small">sidebar</span>
                 »
            </button>
        </div>
    
      <div class="clearer"></div>
    </div>
    <div class="relbar-bottom">
        
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../../genindex.html" title="General Index"
             >Index</a></li>
        <li class="right" >
          <a href="../../../py-modindex.html" title="Python Module Index"
             >modules</a> &nbsp; &nbsp;</li>
        <li class="right" >
          <a href="../../../index.html" title="Table Of Contents"
             ><i class="fa fa-book fa-lg"></i></a> &nbsp; &nbsp;</li>
    <li><a href="http://psicode.org/"><i class="fa fa-home fa-lg"></i></a></li>
    <li><a href="http://github.com/psi4/psi4"><i class="fa fa-github fa-lg"></i></a></li>
    <li><a href="http://forum.psicode.org"><i class="fa fa-comments-o fa-lg"></i></a></li>
    <li><a href="http://github.com/psi4/psi4/edit/master/doc/sphinxman/source/_modules/psi4/driver/inputparser.rst"><i class="fa fa-pencil fa-lg"></i></a></li>
    <li style="color: #1a4162">&nbsp;&middot;&nbsp;</li>
    <li><a href="http://github.com/psi4/psi4/tree/19c2642">1.6a1.dev39</a></li>
    <li style="color: #1a4162">&nbsp;&middot;&nbsp;</li>
    <li class="nav-item nav-item-0"><a href="../../../index.html">
        <span style="font-family: Optima, sans-serif;">P<span style="font-size: 82%;">SI</span>4</span>
        </a><i class="fa fa-angle-double-right" style="color: #a2a7b3; text-shadow: none;"></i></li>

          <li class="nav-item nav-item-1"><a href="../../index.html" >Module code</a><i class="fa fa-angle-double-right" style="color: #a2a7b3; text-shadow: none;"></i></li>
        <li class="nav-item nav-item-this"><a href="">psi4.driver.inputparser</a></li> 
      </ul>
    </div>
    </div>

    <div class="footer" role="contentinfo">
        &#169; Copyright 2022, The Psi4 Project.
      Last updated on Saturday, 05 February 2022 03:47PM.
      Created using <a href="https://www.sphinx-doc.org/">Sphinx</a> 4.4.0.
    </div>
    <!-- cloud_sptheme 1.4 -->
  </body>
</html>